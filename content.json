{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"ToolList","text":"anyproxy fiddler mitmproxy wsl/powershell+ssh+termial xshell MobaXterm mycli mysqlshell workbench phpmyadmin DataGrip navicat name desc IsGui php script false git 版本管理 false composer php包管理 true deployer 基于php的部署工具 false phpstan php静态检测工具 false Supervisor 进程管理 false vscode true phpstorm true wsl Windows Subsystem for Linux false MobaXterm gui tablePlus Datagrip 数据库可视化管理工具 true everything true mycli tmux logo在线生成 接口mock 厉害了","link":"/2020/04/03/amazing_tool/ToolList/"},{"title":"how to use Termux","text":"Termux 起步 开启ssh 安装环境 最后 TermuxTermux是一个Android下一个高级的终端模拟器, 开源且不需要root, 支持apt管理软件包，十分方便安装软件包, 完美支持Python, PHP, Ruby, Go, Nodejs, MySQL等。随着智能设备的普及和性能的不断提升，如今的手机、平板等的硬件标准已达到了初级桌面计算机的硬件标准, 用心去打造完全可以把手机变成一个强大的工具. 起步安装Termux，推荐google play 更换清华源 12sed -i 's@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux stable main@' $PREFIX/etc/apt/sources.listapt update &amp;&amp; apt upgrade Termux 镜像使用帮助 开启ssh手机端 12345678910# 安装服务apt install openssh# 开启服务sshd# 导入公钥cat id_rsa.pub &gt;&gt; authorized_keys# 查看ipifconfig -a# 查看用户whoami 客户端（pc） 1ssh xxx@xxx.xxx.xxx.xxx -p 8022 通过ssh登录到手机 Termux 安装环境默认环境目录结构与常用ubuntu，centos目录不同，且apt有些使用上的其他问题，采取使用proot使用ubuntu，termux可运行htop等，proot中不可运行htop等 12345678apt install wget prootapt install screenfetchmkdir -p ~/jails/ubuntucd ~/jails/ubuntuwget https://raw.githubusercontent.com/Neo-Oli/termux-ubuntu/master/ubuntu.shchmod +x ubuntu.sh./ubuntu.sh./start-ubuntu.sh 进入 ubuntu 1234# 忽略每次出现的提示root@localhost:~# touch ~/.hushloginapt updateapt install vim software-properties-common 安卓上用Termux终端模拟器安装MC Forge 1.12.2服务器! 123456789101112131415$ screenfetch ╲ ▁▂▂▂▁ ╱ ▄███████▄ ▄██ ███ ██▄ OnePlus_3T ▄███████████▄ OS: Android 8.0.0 ▄█ ▄▄▄▄▄▄▄▄▄▄▄▄▄ █▄ Device: ONEPLUS A3010 (OnePlus3T) ██ █████████████ ██ ROM: ONEPLUS A3010_28_180621 ██ █████████████ ██ Baseband: msm ██ █████████████ ██ Kernel: aarch64 Linux 3.18.66-perf+ ██ █████████████ ██ Uptime: █████████████ CPU: Qualcomm Technologies, Inc MSM8996pro ███████████ GPU: Qualcomm Technologies, Inc MSM8996pro ██ ██ RAM: 2627MiB / 5739MiB ██ ██ 安装环境php 1234add-apt-repository ppa:ondrej/phpapt-get updateapt-get install php7.4 php7.4-fpm php7.4-mysql php7.4-gd php7.4-mbstring#(安装pecl的依赖忘记了，其他需要的扩展自行安装，使用pecl有点慢，不知道是不是编译的问题) [PHP] Ubuntu快速安装起PHP7.4 安装node,从官网下载x64不行的话，下载arm包进行安装 1234567wget https://npm.taobao.org/mirrors/node/v12.14.1/node-v12.14.1-linux-arm64.tar.xztar -xvf node-v12.14.1-linux-arm64.tar.xzecho &quot;export PATH=$PATH:/usr/local/node/binexport PATH=$PATH:/root/bin&quot; &gt;&gt; ~/.bashrcsource ~/.bashrc 12apt install nginxapt install php7.4-fpm 【注】linux下1024一下端口需要root权限，由于并不打算将手机进行root，所以需要改nginx.conf的server端口，同理上面ssh连接也没有使用22，而实使用的8022 nginx，php-fpm未进行调优，测试比较惨烈。测试swoole、node rswoole.php 12345678910111213&lt;?php$http = new swoole_http_server(&quot;0.0.0.0&quot;, 8080);$http-&gt;on(&quot;start&quot;, function ($server) { echo &quot;Swoole http server is started at http://127.0.0.1:8080\\n&quot;;});$http-&gt;on(&quot;request&quot;, function ($request, $response) { $response-&gt;header(&quot;Content-Type&quot;, &quot;text/plain&quot;); $response-&gt;end(&quot;Hello World\\n&quot;);});$http-&gt;start(); howtorun 1php rswoole.php node.js 1234567891011121314//引入http模块var http = require(&quot;http&quot;);//设置主机名var hostName = '0.0.0.0';//设置端口var port = 8080;var server = http.createServer(function(req,res){ res.setHeader('Content-Type','text/plain'); res.end(&quot;hello nodejs&quot;);});server.listen(port,hostName,function(){ console.log(`服务器运行在http://${hostName}:${port}`);}); howtorun 1node node.js 在同一局域网中进行压测swoole 1234567891011PS D:\\WorkSpace\\GoPath\\bin&gt; .\\bombardier.exe -c 1000 -n 1000000 &quot;http://192.168.0.103:8080/&quot;Bombarding http://192.168.0.103:8080/ with 1000000 request(s) using 1000 connection(s) 1000000 / 1000000 [=========================================================================================================================================================================] 100.00% 14853/s 1m7sDone!Statistics Avg Stdev Max Reqs/sec 14888.71 6029.68 39199.76 Latency 67.08ms 65.80ms 7.18s HTTP codes: 1xx - 0, 2xx - 1000000, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 3.29MB/s 头一次node和swoole差这么大，不知道环境哪里影响了。 1234567891011PS D:\\WorkSpace\\GoPath\\bin&gt; .\\bombardier.exe -c 1000 -n 1000000 &quot;http://192.168.0.103:8080/&quot;Bombarding http://192.168.0.103:8080/ with 1000000 request(s) using 1000 connection(s) 1000000 / 1000000 [=========================================================================================================================================================================] 100.00% 6135/s 2m42sDone!Statistics Avg Stdev Max Reqs/sec 6135.45 1840.50 30283.66 Latency 162.87ms 69.88ms 9.53s HTTP codes: 1xx - 0, 2xx - 1000000, 3xx - 0, 4xx - 0, 5xx - 0 others - 0 Throughput: 1.19MB/s 最后1234567891011121314151617181920root@localhost:~# screenfetchawk: cannot open /proc/fb (Permission denied) ./+o+- root@localhost yyyyy- -yyyyyy+ OS: Ubuntu 19.04 disco ://+//////-yyyyyyo Kernel: aarch64 Linux 3.18.66-perf+ .++ .:/++++++/-.+sss/` Uptime: .:++o: /++++++++/:--:/- Packages: 372 o:+o+:++.`..```.-/oo+++++/ Shell: bash 5.0.3 .:+o:+o/. `+sssoo+/ CPU: 4x Qualcomm Technologies, Inc MSM8996pro .++/+:+oo+o:` /sssooo. GPU: /+++//+:`oo+o /::--:. RAM: 2487MiB / 5739MiB \\+/+o+++`o++o ++////. .++.o+++oo+:` /dddhhh. .+.o+oo:. `oddhhhh+ \\+.++o+o``-````.:ohdhhhhh+ `:o+++ `ohhhhhhhhyo++os: .o:`.syhhhhhhh/.oo++o` /osyyyyyyo++ooo+++/ ````` +oo+++o\\: `oo++. 某问题的啦","link":"/2020/01/09/amazing_tool/h2u_Termux/"},{"title":"how to use docker","text":"wsl2 后可以配合docker desktop在本地环境快速搭建 redis/mongodb/mysql/nginx/php 等环境的部署。 dockerdockerhubformysql 1docker search mysql 拉取 docker images 1docker pull mysql:latest 查看本地镜像 1docker images docker-composedocker-compose up -d 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950version: '3'services: #表示这是一组服务 redis: image: redis container_name: redis restart: always #docker服务重启后nginx的docker容器也重启 ports: - &quot;6379:6379&quot; #映射的端口，redis容器的6379端口映射到本地的6379端口，可以通过ip:6379访问容器 networks: db_local: #应用docker网络的名称 ipv4_address: 192.170.129.111 #分配的局域网ip volumes: # 挂载数据目录 - D:\\WorkSpace\\work-docker\\docker-data\\redis\\data:/data # links: # - php # 连接php的docker容器 会在host文件生成 php 192.170.1.101(php 容器的局域网ip) mysql: image: mysql #应用的mysql的镜像名称 container_name: mysql #应用的mysql的镜像名称 restart: always #docker服务重启后nginx的docker容器也重启 ports: - &quot;3306:3306&quot; #映射的端口，redis容器的6379端口映射到本地的6379端口，可以通过ip:6379访问容器 environment: MYSQL_ROOT_PASSWORD: root_password # root用户的密码 MYSQL_USER: user # 创建新用户 MYSQL_PASSWORD: user_password # 新用户的密码 volumes: # - D:\\WorkSpace\\work-docker\\docker-data\\mysql-conf:/etc/mysql #本地mysql映射到docker - D:\\WorkSpace\\work-docker\\docker-data\\mysql\\data:/var/lib/mysql #本地mysql映射到docker networks: db_local: #应用docker网络的名称 ipv4_address: 192.170.129.112 #分配的局域网ip mongo: image: mongo container_name: mongo restart: always #docker服务重启后nginx的docker容器也重启 ports: - &quot;27017:27017&quot; #映射的端口，redis容器的6379端口映射到本地的6379端口，可以通过ip:6379访问容器 volumes: # 挂载数据目录 - D:\\WorkSpace\\work-docker\\docker-data\\mongodb\\db:/data/db networks: db_local: #应用docker网络的名称 ipv4_address: 192.170.129.113 #分配的局域网ipnetworks: db_local: driver: bridge #网络类型 ipam: config: - subnet: 192.170.129.0/17 #区域网ip 关于php容器内在不关联 mysql 情况下连接mysql可以将本机局域网ip让php容器内连接 Docker容器后台运行,就必须有一个前台进程。主线程结束，容器会退出。直接运行docker命令，路径为work_dir1docker exec -it php-80 php -version","link":"/2019/01/02/amazing_tool/h2u_docker/"},{"title":"how to use golang","text":"go环境设置 go get 代理设置 go mod go env 关于下载库和下载软件 基础 包推荐 练习 闭包练习 gin gorm gorm 分表写法 model 开发 cgo 取苹果 go环境设置go get 代理设置 对应的shell代理设置，cmd/powershell git代理设置 12345678set http_proxy=http://127.0.0.1:1081set https_proxy=http://127.0.0.1:1081$ENV:http_proxy=&quot;http://127.0.0.1:1081&quot;$ENV:https_proxy=&quot;http://127.0.0.1:1081&quot;git config --global http.proxy http://127.0.0.1:1081git config --global https.proxy http://127.0.0.1:1081git config --global --unset http.proxygit config --global --unset https.proxy go mod123456789go mod download //下载依赖包go mod edit //工具或脚本编辑go.modgo mod graph //打印模块依赖图go mod init //在当前目录初始化modgo mod tidy //拉取缺少的模块，移除不用的模块。go mod vendor //将依赖复制到vendor下go mod verify //验证依赖是否正确go mod why //解释为什么需要依赖go list -m -json all //依赖详情 go mod 练习 123456789101112首先mkdir go_t &amp;&amp; cd go_tgo mod init appgo get -u github.com/codesenberg/bombardier // 这是一个http压测客户端，cat go.sum // go.sum 安装了没有用的东西，因为打算全局安装，但是并不想要引入当前项目go mod tidy // 无效 因为当前目录没有impact 任何go的包// 创建一个go文件go mod tidy cat go.sum// 不会影响全局go install github.com/codesenberg/bombardier@latest go envgo 1.13提供了 go env -w命令来写环境变量 12345go env -w XXX=&quot;XXX&quot;go env -u XXXgo env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,direct win: 用户\\AppData\\Roaming\\go\\envlinux: /root/.config/go/env 关于下载库和下载软件 以下基于 go 1.17 如果你要下载一个由go编写的的可执行程序，你应该执行 go install xxxx。这会在 GO_PATH/bin/ 下安装可执行文件。如果你要引用第三方库进行代码开发，你可以使用 go get -d （仅下载代码不进行编译）。 可以认为目前是 go 1.17 还是一个过渡时期，未来 go get应该不再进行编译操作，-d 会演变为默认参数。而 go install则进化为下载可执行软件的专用方法。 目前 go 1.17 用 go get 还是可以下载+编译的。未来应该是不能这么操作了 基础包推荐练习闭包练习12345678package main func add(x1, x2 int) func(x3 int, x4 int) (int, int, int) { i := 0 return func(x3 int, x4 int) (int, int, int) { i++ return i, x1 + x2, x3 + x4 }} gingormgorm 分表写法假设 user 按照 uid 分表。关键点：设置db.Table，同时在查询前调用Scopes，因为Scopes传递的是闭包，所以可以编写一个构建闭包的函数进行设置。 123456789101112131415161718192021222324252627282930313233343536373839404142434445type KUser struct { ID uint32 `gorm:&quot;primaryKey;column:id;type:int(10) unsigned;not null&quot;` // 用户表自增id UId uint64 `gorm:&quot;unique;column:uid;type:bigint(20) unsigned;not null&quot;` // 用户中心passId NickName string `gorm:&quot;column:nick_name;type:varchar(255);not null;default:''&quot;` // 用户昵称}func (u KUser) getSuffixByUid() uint64 { return u.UId % uint64(32)}type kUserRepository struct {}var kur *kUserRepositoryfunc init() { kur = new(kUserRepository)}func setGetSuffix(suffix int) func(db *gorm.DB) *gorm.DB { return func(db *gorm.DB) *gorm.DB { return db.Table(&quot;user_&quot; + types.ToString(suffix)) }}func setGetSuffixByUid(uid int64) func(db *gorm.DB) *gorm.DB { return setGetSuffix(getSuffixByUid(uid))}func getSuffixByUid(uid int64) int { return types.ToInt(uid % 32)}func (kur kUserRepository) FindBySuffix(suffix int) []KUser { var kUsers []KUser r := dbPool.GetDB().Scopes(setGetSuffix(suffix)).Find(&amp;kUsers) fmt.Println(r.Error) return kUsers}func GetKUserRepository() *kUserRepository { return kur} model 开发go 模块的开发并不复杂，但是其为了兼容老版本，所采取的策略比较有意思。相比与 composer、npm 这种每个包指定版本的做法。go mod 可以在一个项目下依赖同一个库的不同版本的代码。 首先 1234567891011121314151617mkdir hello-go-modcd hello-go-modgit init go mod init github.com/hzjoyous/hello-go-modmkdir hellocd helloecho &quot;package hellofunc Hello() string{ return &quot;hello&quot;}&quot; &gt; function.gocd ..git add .git commit -m 'code a lib for go'git push 当推送完成之后你就可以使用 1go get -u github.com/hzjoyous/hello-go-mod 在其他项目拉取该项目了。默认为v0.0.0。 接下来就是不一样的地方了。你可以在这个项目上打tag，当tag为 v1.x.x/v0.x.x 拉取是没有任何问题的。 当你把 tag 打到 v2.x.x。你会发现无法拉取 拉取代码的时候会出现 12go get: github.com/hzjoyous/hello@v2.0.1: reading https://goproxy.cn/github.com/hzjoyous/hello/@v/v2.0.1.info: 404 Not Found server response: not found: github.com/hzjoyous/hello@v2.0.1: invalid version: module contains a go.mod file, so major version must be compatible: should be v0 or v1, not v2 是不是满脑子充满了问号？ 这里有一篇官方的blogv2-go-modules。官网的内容中定义了一个原则 如果旧包和新包的导入路径相同，新包必须向后兼容旧的包对比以下之前用过的包管理，是不是有点不一样？比如 php 的 composer ，里面的高版本都是为了进行破坏性的升级才修改的。升级高版本是不是要修改代码？虽然go中高版本也可以写api破坏性的代码，但是其高于v2的版本通过go get 后本地位置是不一样的。所以在go的项目中，你可以在一个项目中同时引入一个库的v1,v2,v3代码进行编译。这里如果你想要发布非v0、v1的版本你需要把go.mod文件修改 修改前 123module github.com/hzjoyous/hello-go-modgo 1.16 修改后 123module github.com/hzjoyous/hello-go-mod/v3go 1.16 这样，即使你发布的新版本存在破坏性，但是拉取的时候go按照顶级版本划分了目录，就可以使其同时使用高低版本代码 https://github.com/rsc/quote/tree/master 根据官网的demo你可以一个项目多个目录，也可以一个项目多个分支来控制版本。 cgo GCC原名为GNU C语言编译器（GNU C Compiler），只能处理C语言。但其很快扩展，变得可处理C++，后来又扩展为能够支持更多编程语言，如Fortran、Pascal、Objective -C、Java、Ada、Go以及各类处理器架构上的汇编语言等，所以改名GNU编译器套件 MinGW-w64下载地址：https://sourceforge.net/projects/mingw-w64/files/ 选择合适的版本 i686纯32位版供32位win系统使用 x86_64是64位系统用的版本 seh结尾是纯64位编译 sjlj结尾是32 64两种编译，需加-m32或-m64参数 posix通常用于跨平台，比win32兼容性好一些 最终下载版本x86_64-posix-sjlj 解压后bin目录加入到环境变量 取苹果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package mainimport ( &quot;fmt&quot; &quot;time&quot;)func main() { fmt.Println(&quot;this is a demoC&quot;) plate := make(chan int) apple := make(chan int) orange := make(chan int) go func() { for { time.Sleep(time.Second) dadPlate := &lt;-plate fmt.Println(&quot;盘子可以放入一个水果 dad Plate&quot;, dadPlate) apple &lt;- 1 fmt.Println(&quot;dad放入一个苹果&quot;) } }() go func() { for { time.Sleep(time.Second) momPlate := &lt;-plate fmt.Println(&quot;盘子可以放入一个水果mom Plate&quot;, momPlate) orange &lt;- 1 fmt.Println(&quot;mom放入一个橘子&quot;) } }() go func() { for { time.Sleep(time.Second) sonOrange := &lt;-orange fmt.Println(&quot;儿子取走一个橘子 sonOrange Plate&quot;, sonOrange) plate &lt;- 1 fmt.Println(&quot;儿子清空盘子&quot;) } }() go func() { for { time.Sleep(time.Second) daughterApple := &lt;-apple fmt.Println(&quot;女儿取走一个苹果 daughterApple Plate&quot;, daughterApple) plate &lt;- 1 fmt.Println(&quot;女儿清空盘子&quot;) } }() plate &lt;- 1 for { time.Sleep(time.Second) }}","link":"/2021/01/27/amazing_tool/h2u_golang/"},{"title":"how to use git","text":"git config set git 代理的设置和取消 初始化仓库提交并push至远程仓库 切换远程分支 使用 vimdiff 进行 git diff 清除提交记录缓存 win下换行问题处理 如果经常产生文件属性变更的情况，可以设置 几乎所有的 git 撤销 如何使用 vimdiff 来 git diff /svn diff 账号修改后推送拉取问题 oh-my-zsh git 慢/卡顿问题解决 账号每次输入问题 同时push 多个地址 dns 设置 rebase git config set12git config user.name 'github用户名' git config user.email '邮箱' git 代理的设置和取消12345git config --global http.proxy http://127.0.0.1:11000git config --global https.proxy http://127.0.0.1:11000git config --global --unset http.proxygit config --global --unset https.proxy 初始化仓库提交并push至远程仓库12345git initgit add README.mdgit commit -m &quot;first commit&quot;git remote add origin git@github.com:hzj991/hexo.gitgit push -u origin master 切换远程分支123git remote rm origingit remote add origin git@github.com:hzj991/hexo-next.gitgit push --set-upstream origin master 使用 vimdiff 进行 git diff123git config --global diff.tool vimdiffgit config --global difftool.prompt falsegit config --global alias.d difftool 清除提交记录缓存1234567git rm --cached application.loggit rm -r --cached . git add .gitignore git commit -m &quot;update .gitignore&quot; git remote add origin git@23123.comgit remote prune origin#也就是说你可以刷新本地仓库与远程仓库的保持这些改动的同步 win下换行问题处理 如果是linux和windows混合开发，很容易会遇到行尾换行符的问题，windows下默认是\\r\\n，linux下是\\n。如果没做处理，git提交时很有可能产生问题，解决办法为设置git config的 core.autocrlf， 1234567891011git config --global core.autocrlf true # 表示自动更换crlf，windows下如果checkout是\\n，则自动换为\\r\\n，在提交时在自动换回\\ngit config --global core.autocrlf input # 自动把\\r\\n换为\\ngit config --global core.autocrlf false # 就是不作处理# 如果已经产生了\\r\\n，merge时产生问题，可以设置git config merge.renormalize true # merge时忽略行尾对比如果只需要执行一次merge可以是用命令git merge -s recursive -X ignore-space-at-eol origin/master# 还可以设置crlf安全检查git config --global core.safecrlf true # 禁止提交混合\\n和\\r\\n的文件git config --global core.safecrlf false # 允许提交git config --global core.safecrlf warn # 提交时产生警告 如果经常产生文件属性变更的情况，可以设置git config –global core.filemode false 几乎所有的 git 撤销1234567891011cd /home/users/hzj/tmpgit/web/ git checkout master oldTimetime=$(date -d &quot;3 days ago&quot; +%Y_%m_%d_%H) git branch -d hotfix/hzj/${oldTimetime} git push origin --delete hotfix/hzj/${oldTimetime} git pull time=$(date &quot;+%Y_%m_%d_%H&quot;) branchName=hotfix/xxx/${time} git checkout -b ${branchName} git pull git push origin ${branchName}:${branchName} 如何使用 vimdiff 来 git diff /svn diff1234#git 如何实现vimdiffgit config --global diff.tool vimdiffgit config --global difftool.prompt falsegit config --global alias.d difftool 账号修改后推送拉取问题原因：将gitee和github的登录邮箱更换了，导致推送代码出现认证失败，需要重置账号密码 执行权限不够可以切换至管理员权限执行 1git config --system --unset credential.helper oh-my-zsh git 慢/卡顿问题解决设置 oh-my-zsh 不读取文件变化信息（在 git 项目目录执行下列命令）如果你还觉得慢，可以再设置 oh-my-zsh 不读取任何 git 信息 123git config --global --add oh-my-zsh.hide-dirty 1git config --add oh-my-zsh.hide-status 1 账号每次输入问题如果我们git clone的下载代码的时候是连接的https://而不是git@git (ssh)的形式，当我们操作git pull/push到远程的时候， 总是提示我们输入账号和密码才能操作成功，频繁的输入账号和密码会很麻烦，也特别烦恼。 1git config --global credential.helper store 同时push 多个地址12git remote set-url --add origin https://github.com/hzjoyous/SimpleHexoBlog.git dns 设置123查询dnshttp://tool.chinaz.com/dns/设置对应host rebase12345git pull --rebase git rebase xxxx# 冲突解决后git rebase --continue git merge --squash","link":"/2020/01/28/amazing_tool/h2u_git/"},{"title":"how to use kibaba","text":"过滤语句12message:(&quot;Argument 10 passed &quot; AND &quot;4000&quot;)&quot;arg1&quot; NOT &quot;arg2&quot;","link":"/2018/11/04/amazing_tool/h2u_kibaba/"},{"title":"how to use hexo","text":"搓手手 开发点评系统 编写迁移脚本 搓手手开发点评系统周末两天用 symfony 写了个小的点评系统，接入到 hexo 搭建的博客上，下面放上 git 地址 https://github.com/hzjoyous/api.nonodi.com前端代码 –baseUri要替换成自己的– 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;blog&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style type=&quot;text/css&quot;&gt; @charset &quot;utf-8&quot;; #commentsProvidedHzj { padding: 10px; border-top: 2px solid #cccccc; border-bottom: 2px solid #cccccc; font-family: &quot;Helvetica Neue&quot;, Helvetica, Arial, &quot;Hiragino Sans GB&quot;, &quot;Hiragino Sans GB W3&quot;, &quot;WenQuanYi Micro Hei&quot;, &quot;Microsoft YaHei UI&quot;, &quot;Microsoft YaHei&quot;, sans-serif; letter-spacing: 0.05em; } #commentsProvidedHzj .avatar { width: 10%; float: left; padding-top: 7px; } #commentsProvidedHzj .comment-info { width: 85%; float: left; line-height: 1em; margin-left: 10px; } #commentsProvidedHzj .comment-info .nickname { font-size: 18px; font-weight: bold; line-height: 1.5em; } #commentsProvidedHzj .comment-info .time { font-size: 13px; color: #999999; } #commentsProvidedHzj .comment-info .content { border-top: 2px dotted #cccccc; padding-top: 5px; font-size: 15px; font-weight: 300; line-height: 1.5em; width: auto; } #commentsProvidedHzj .comment-info a.reply { display: block; float: right; font-size: 14px; color: #999999; cursor: pointer; } #commentsProvidedHzj input, #commentsProvidedHzj textarea, #commentsProvidedHzj button { border: none; box-shadow: 0px 1px 2px 0px rgba(0, 0, 0, 0.25); border-radius: 2px; } #commentsProvidedHzj input { width: 28%; margin: 0; padding: 5px; margin-right: 2%; height: 32px; font-size: 18px; line-height: 32px; } @media only screen and (max-width: 720px) { #commentsProvidedHzj input, #commentsProvidedHzj textarea { border: 1px solid #cccccc; } #commentsProvidedHzj input { width: 27%; } } @media only screen and (max-width: 400px) { #commentsProvidedHzj input { margin-right: 1%; } } @media only screen and (max-width: 350px) { #commentsProvidedHzj input { margin-right: 0; } } #commentsProvidedHzj textarea { width: 96%; font-size: 18px; line-height: 24px; margin-top: 10px; padding: 5px; } #commentsProvidedHzj button { width: 10%; margin-left: 5px; margin-top: 10px; appearance: button; cursor: pointer; color: #fff; background-color: #5cb85c; border-color: #4cae4c; height: 32px; min-width: 80px; } &lt;/style&gt; &lt;div id=&quot;commentsProvidedHzj&quot;&gt; &lt;div class=&quot;commment&quot;&gt; &lt;div v-for=&quot;comment in info&quot; class=&quot;comment&quot;&gt; &lt;div class=&quot;avatar&quot;&gt;&lt;img :src=&quot;comment.avatarUri&quot; alt=&quot;nihao avatar&quot;&gt;&lt;/div&gt; &lt;div class=&quot;comment-info&quot;&gt; &lt;div class=&quot;nickname&quot;&gt;${comment.nickname}&lt;/div&gt; &lt;div class=&quot;time&quot;&gt;${comment.createTime}&lt;/div&gt; &lt;div class=&quot;content&quot;&gt;${comment.content}&lt;/div&gt; &lt;a class=&quot;reply&quot; herf=&quot;#submit4hzj&quot;&gt;回复&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div style=&quot;clear: both; height: 30px;&quot;&gt;&lt;/div&gt; &lt;div class=&quot;submit&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;nickname&quot; v-model=&quot;submit.nickname&quot; placeholder=&quot;nickname（必填）&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;email&quot; v-model=&quot;submit.email&quot; placeholder=&quot;email&quot;&gt; &lt;input type=&quot;text&quot; class=&quot;website&quot; v-model=&quot;submit.website&quot; placeholder=&quot;website&quot;&gt; &lt;br&gt; &lt;textarea name=&quot;&quot; id=&quot;submit4hzj&quot; cols=&quot;30&quot; rows=&quot;10&quot; class=&quot;content&quot; v-model=&quot;submit.content&quot; placeholder=&quot;content（必填）&quot;&gt;&lt;/textarea&gt; &lt;button v-on:click=&quot;submitComment()&quot;&gt;提交评论&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- &lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;https://vuejs.org/js/vue.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt; &lt;script&gt; $app = new Vue({ delimiters: ['${', '}'], el: '#commentsProvidedHzj', data: { info: null, submit: { 'nickname': '', 'email': '', 'website': '', 'uuid': '', 'content': '' }, baseUri: 'https://xxx.xxx.com', }, mounted() { var identity = window.location.href; axios.get(this.baseUri + '/comments', { params: { uuid: this.submit.uuid, identity: identity } }).then(response =&gt; ( this.info = response.data.value.comments, this.submit.uuid = response.data.value.uuid )) .catch(error =&gt; console.log(error)) }, methods: { submitComment: function () { axios.get(this.baseUri + '/addComment', { params: { nickname: this.submit.nickname, email: this.submit.email, website: this.submit.website, uuid: this.submit.uuid, content: this.submit.content } }) .then(response =&gt; (console.log(response.data))) .catch(error =&gt; console.log(error)) var identity = window.location.href; axios.get(this.baseUri + '/comments', { params: { uuid: this.submit.uuid, identity: identity } }).then(response =&gt; ( this.info = response.data.value.comments, this.submit.uuid = response.data.value.uuid )) .catch(error =&gt; console.log(error)) } } }); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 编写迁移脚本之前由于用不惯hexo自带的生成文章的方式于是单独写了个php文件辅助生成，由于写的比较匆忙导致也有些bug。时间推移就想改进以下，因为不想在hexo中大量引入php，于是决定废弃这个项目中的php运行文件。（个人看法是不希望php项目中夹杂node工具，node项目中也不要夹杂php工具，这样容易使项目所有功能都跑起来依赖的基建比较多，增加别人参考的成本） 这里先放上之前的php脚本 phelper.php 里面主要部分就是创建文件夹，创建默认文件，日期，和用vscode唤起 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?php$blogPath = __DIR__ . DIRECTORY_SEPARATOR . 'source' . DIRECTORY_SEPARATOR . '_posts' . DIRECTORY_SEPARATOR;if (isset($argv[1]) &amp;&amp; isset($argv[2])) { $blogName = $argv[2]; $blogNamespace = $argv[1];} else if (isset($argv[1])) { $blogName = $argv[1]; $blogNamespace = 'other';} else { $blogName = date('Y_m_d') . &quot;杂谈&quot;; $blogNamespace = 'other';}$createTime = date('Y-m-d H:i:s');$content = &quot;---\\n&quot;;$content .= &quot;title: &quot; . $blogName . &quot;\\n&quot;;$content .= &quot;date: &quot; . $createTime . &quot;\\n&quot;;$content .= &quot;tags: &quot; . 'other' . &quot;\\n&quot;;$content .= &quot;categories: &quot; . 'other' . &quot;\\n&quot;;$content .= &quot;---\\n&quot;;$content .= &quot;&lt;!--more--&gt;&quot;;$newBlogFilePath = $blogPath . DIRECTORY_SEPARATOR . $blogNamespace . DIRECTORY_SEPARATOR . 'z_' . $blogName . '.md';if (file_exists($newBlogFilePath) == 1) { $newBlogFilePath = $blogPath . DIRECTORY_SEPARATOR . $blogNamespace . DIRECTORY_SEPARATOR . 'z_' . $blogName . time() . '.md';}file_put_contents($newBlogFilePath, $content, 8);echo realpath($newBlogFilePath);echo PHP_EOL;exec('code '.$newBlogFilePath); 如果我继续使用php编写cli脚本的话，我可能就会期望选用 symfony/console 来定制我需要的交互式命令，因为决定不使用php，所以我需要在npm中寻找对应的包，毕竟都不是新型语言，所以在这种辅助类工具开发上，一旦需求变高，找轮子要优于造轮子，首先我在npm中搜索 command 和 console ,但是结果显示的包更新日期都比在数个月以上了。所以决定更换查找方式。于是决定先参考以下vue-cli引用了类似的包，这里用的everything进行的查询 打开该目录，进入bin文件夹下打开vue（win下可执行文件都是.exe后缀，直接可运行的脚本大多都是.bat然后驱动一个其他脚本语言的脚本，所以这个文件大概率就是个node编写的脚本） 打开bin/vue 12345678910111213#!/usr/bin/env nodeconst program = require('commander')program .version(require('../package').version) .usage('&lt;command&gt; [options]') .command('init', 'generate a new project from a template') .command('list', 'list available official templates') .command('build', 'prototype a new project') .command('create', '(for v3 warning only)')program.parse(process.argv) 这个文件中引入了commander，于是我们可以去npm查以下这个包，查询结果 最后一次更新也比较近（虽然这不是评价一个包好坏的标准）。 进入文档查询。然后就比较失望了，这个commander只提供了参数式的使用方式并没有提供交互式的cli方式。所以并不满足我的需求。 下一步直接查询node 交互式cli，然后在第一个结果中看到有人指出了inquirer，chalk这两个包，接下来又到知乎逛了以下，了解了以下inquirer和commander，基本确认inquirer、chalk、commander这三个包是我需要的扩展。也比较主流，只是觉得并不像symfony/console对控制台提供的那样全面一些吧，symfony/console提供了参数式、交互式及一定程度的美化、也提供了一些进度条呀，table之类的展示方式。感觉未来node的这三个包也会被其他开发整合到一起来使用。","link":"/2020/01/19/amazing_tool/h2u_hexo/"},{"title":"how to use linux","text":"ubuntu 更换源 ubuntu下crontab启动，重启，关闭命令 bash设置代理 linux 添加用户 lnmp 多彩日志 ifconfig 命令不存在 日志过滤 多用户 nohup &amp; ubuntu 更换源 备份/etc/apt/sources.list 更改/etc/apt/sources.list 中科大源 12345678910deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse 更新命令 12sudo apt-get updatesudo apt-get upgrade 阿里源 12345678910deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 网易163源 12345678910deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse 清华源 12345678910deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse ubuntu下crontab启动，重启，关闭命令123456#检查是否已经开启 cronsudo service cron status启动：/etc/init.d/cron start ( service cron start )重启：/etc/init.d/cron restart ( service cron restart )关闭：/etc/init.d/cron stop ( service cron stop ) bash设置代理12345export https_proxy=10.0.0.52:8080export https_proxy=user:pass@192.158.8.8:8080export https_proxy=socks://10.0.0.52:1080export https_proxy=socks4://10.0.0.52:1080export https_proxy=socks5://10.0.0.52:1080 linux 添加用户12useradd -m getianmengpasswd getianmeng W4v1iQt***************** 添加yum的root执行权限 12#vim sudoerscd /etc/sudoers.d getianmeng ALL=(root) /usr/bin/yum lnmp123456789101112131415php -S 0.0.0.0:8080 index.phpsudo service nginx reloadsudo service nginx restartsudo service php-fpm reloadsudo service php-fpm restartmysqldump -h 10.0.1.90 -u username -p -P 3306 --no-data --skip-lock-table --databases databaseName &gt; dump.sqlmysql -h 10.0.2.72 -u username -p -P 3306 bookorder &lt; dump.sql *ssh-keygen -t rsa cat id_rsa.pub &gt;&gt; authorized_keys 多彩日志12345678910111213141516171819tail -f test_stub.log | perl -pe 's/(500)|(200)|(404)|(error)/\\e[1;31m$1\\e\\e[1;32m$2\\e\\e[1;36m$3\\e\\e[1;31m$4\\e[0m/g' echo -e &quot;\\033[30m 黑色字 \\033[0m&quot;echo -e &quot;\\033[31m 红色字 \\033[0m&quot;echo -e &quot;\\033[32m 绿色字 \\033[0m&quot;echo -e &quot;\\033[33m 黄色字 \\033[0m&quot;echo -e &quot;\\033[34m 蓝色字 \\033[0m&quot;echo -e &quot;\\033[35m 紫色字 \\033[0m&quot;echo -e &quot;\\033[36m 天蓝字 \\033[0m&quot;echo -e &quot;\\033[37m 白色字 \\033[0m&quot;echo -e &quot;\\033[40;37m 黑底白字 \\033[0m&quot;echo -e &quot;\\033[41;37m 红底白字 \\033[0m&quot;echo -e &quot;\\033[42;37m 绿底白字 \\033[0m&quot;echo -e &quot;\\033[43;37m 黄底白字 \\033[0m&quot;echo -e &quot;\\033[44;37m 蓝底白字 \\033[0m&quot;echo -e &quot;\\033[45;37m 紫底白字 \\033[0m&quot;echo -e &quot;\\033[46;37m 天蓝底白字 \\033[0m&quot;echo -e &quot;\\033[47;30m 白底黑字 \\033[0m&quot; ifconfig 命令不存在ifconfig为 net-tools包中的软件，需要下载net-tools。如果查找apt search ifconfig可能会找不到对应的软件 12apt-get install net-tools 日志过滤 2019-07-02T22:18:09+08:00 发现腾讯云上的mysql被删库了，原因是lnmp预装的phpadmin没有做隐藏处理，被攻击者猜到了，下面是一句日志过滤的语句 1cat access.log | awk '{a[$1]+=1;} END {for(i in a){print a[i]&quot; &quot;i;}}' | sort -t &quot; &quot; -k 1 -n 12345sudo apt install net-toolsnetstat -anp |grep ps -aux | grep 'xxx' 多用户 因为公司对git user.name git user.email 以及 ssh 的生成有要求。所以采用多用户配置 可以创建一个文件写入 1hwork:x:1001:1001:,,,:/home/hwork:/usr/bin/zsh 之后 addusers &lt; waitadduserlist.txt。这样就可以创建好了 之后可以用root设置密码 sudo passwd hwork 当然你也可以删除这个用户的密码 sudo passwd -d hwork 这样你在切换用户的时候可以直接 su hwork，就不用再此输入密码了 切换后的 git 和 ssh 与之前的用户是独立的。所以可以在这个用户下配置工作需要的一些属性。这样就不用修改原有的用户名和邮箱了。就可以将工作和个人信息隔离开了。（完美） nohup &amp;nohup:不挂断的运行&amp;:后台运行","link":"/2021/01/28/amazing_tool/h2u_linux/"},{"title":"powershell &amp; linux bash","text":"pwsh docs 地址 pwsh vs bash my profile other PowerShell 是构建于 .NET 上基于任务的命令行 shell 和脚本语言。 PowerShell 可帮助系统管理员和高级用户快速自动执行用于管理操作系统（Linux、macOS 和 Windows）和流程的任务。 pwsh docs 地址pwsh docs pwsh vs bash pwsh bash Start-Job -ScriptBlock {hexo s} hexo s &amp; get-job remove-job Receive-Job stop-job wait-job unknow [command1] ; [command2] [command1] ; [command2] try{[command1] ; [command2]} catch{$error[0];break} [command1] &amp;&amp; [command2] [command1] | [command2] [command1] | [command2] [command1] &gt; 1.txt [command1] &gt; 1.txt [command1] &gt;&gt; 1.txt [command1] &gt;&gt; 1.txt my profile普通用户下执行$profile以获取启动脚本路径powershell 需要在管理员权限下执行 set-executionpolicy remotesigned 以使用自建脚本 ，等价~/.bashrc 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168# 为了防止以后新版本的powershell 会出现冲突命令# 对于一些存在于cmd hash的已有命令，# 如果需要自己实现相同共能尽量不要起相同的名字# 例如 cmd 存在where bash存在的which 命令 ，powershell 暂未发现对应命令，# 但是在win + powershell + cmd 中可以在powershell通过 cmd /c where 使用相同效果，如封装成函数，不应命名为where 或者whichfunction hexocgd { hexo clean; hexo g; hexo d;}function hexogd { hexo g; hexo d;}function editpspre { code $PROFILE}function cddesktop { Set-Location C:\\Users\\HZJ\\Desktop;}$startUpPath = 'C:\\Users\\HZJ\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup';function echoStartUpPath { $startUpPath;}function hosts { code &quot;%SystemRoot%\\system32\\drivers\\etc\\hosts&quot;;}function updatehosts { ipconfig /flushdns;}function restartWsl { net stop LxssManager; net start LxssManager;}function zwhichis() { cmd /c where $command}function Simple-Date() { Get-Date -Format 'yyyy-MM-dd HH:mm:ss'}set-alias sDate Simple-Dateset-alias grep select-stringImport-Module posh-gitImport-Module oh-my-posh# Set-Theme ParadoxSet-Theme DarkbloodSet-PSReadlineKeyHandler -Key Tab -Function Complete # 设置 Tab 键补全Set-PSReadLineKeyHandler -Key &quot;Ctrl+d&quot; -Function MenuComplete # 设置 Ctrl+d 为菜单补全和 IntellisenseSet-PSReadLineKeyHandler -Key &quot;Ctrl+z&quot; -Function Undo # 设置 Ctrl+z 为撤销Set-PSReadLineKeyHandler -Key UpArrow -Function HistorySearchBackward # 设置向上键为后向搜索历史记录Set-PSReadLineKeyHandler -Key DownArrow -Function HistorySearchForward # 设置向下键为前向搜索历史纪录function godocstart() { godoc -http=:6060 ; Start-Process &quot;http://127.0.0.1:6060/doc&quot;}function godocshow() { Start-Process &quot;http://127.0.0.1:6060/doc&quot;}function ll() { Get-ChildItem}function gitsetp() { git config --global http.proxy http://127.0.0.1:11000 git config --global https.proxy http://127.0.0.1:11000}function gitunsetp() { git config --global --unset http.proxy git config --global --unset https.proxy}function setp() { $env:HTTPS_PROXY = &quot;http://127.0.0.1:11000&quot; $env:HTTP_PROXY = &quot;http://127.0.0.1:11000&quot;}function unsetp() { Remove-Item Env:http_proxy Remove-Item Env:https_proxy}function work() { Set-Location 'C:\\Users\\HZJ\\Desktop\\work'}function workspace { Set-Location D:\\WorkSpace\\;}function cddr ($ps) { switch ($ps) { 'n' { &quot;准备进入nginx容器&quot; docker exec -it nginx_lumen //bin//sh } 'p' { &quot;准备进入php容器&quot; docker exec -it php_lumen //bin//sh } default { &quot;容器不存在&quot; } }}function xqssh($ps) { switch ($ps) { '1' { &quot;准备进入st&quot; + $ps ssh httpd@172.17.224.7 } '2' { &quot;准备进入st&quot; + $ps ssh httpd@172.17.225.9 } '3' { &quot;准备进入st&quot; + $ps ssh httpd@172.17.226.7 } Default { &quot;准备进入st1&quot; ssh httpd@172.17.224.7 } }}function wblog() { code C:\\Users\\HZJ\\Desktop\\blog}function cdworktool{ Set-Location D:\\WorkSpace\\simple\\laravel8}function gitpushall($message = &quot;update all&quot;){ git add . ; git commit -m '&quot;'$message'&quot;' ; git push}function gitcpush($message = &quot;update all&quot;){ git commit -m '&quot;'$message'&quot;' ; git push}function adbscreencap(){ $time = Get-Date -Format 'yyyyMMddHHmmssfff' $filePath = '/sdcard/'+$time+'.png' C:\\Users\\HZJ\\AppData\\Local\\Android\\Sdk\\platform-tools\\adb.exe shell screencap -p $filePath C:\\Users\\HZJ\\AppData\\Local\\Android\\Sdk\\platform-tools\\adb.exe pull $filePath}function echoadbpath(){ &quot;C:\\Users\\HZJ\\AppData\\Local\\Android\\Sdk\\platform-tools\\adb.exe&quot;} other123456789101112:: 端口映射操作:: sqlssh -fNg -L [映射端口]:[远程ip]:[远程端口] [username]@[ip]:: redisssh -fNg -L 6379:10.0.2.222:6379 hanzhijie@10.0.2.222:: memcachessh -fNg -L 11211:10.0.2.221:11211 hanzhijie@10.0.2.222:: order-app-startstart /b php -S localhost:8081 C:\\Users\\username\\Desktop\\xz\\xz_app\\public\\index.php:: order-facade-startstart /b php -S localhost:8082 C:\\Users\\username\\Desktop\\xz\\xz_facade\\public\\index.php","link":"/2020/05/22/amazing_tool/h2u_powershell/"},{"title":"how to use mysql","text":"mysql 密码重置那些事儿 mysql 8.0 导致的 pdo 链接问题 crud create alter insert read update delete other 思考 删除一个数据库所有表 mysql 密码重置那些事儿好久没有整理云服务器，今天上去把前端代码和服务端代码进行了一下拆分，结果发现忘记了mysql的密码（真·很久没有用过）~,于是去查了一下MySQL的密码重置操作，MySQL(root用户)密码重置，其实就是除了正常的启动 MySQL 之外还可以通过 MySQL 提供的另个可执行文件进行安全启动，我的安装的版本是 mysqld_safe ，找不到的同学可以先用 which mysql 然后进入 mysql 的安装目录查找带有 safe 的可执行文件，执行后通过密码重置语句进行更改就可以愉快的继续使用了 123use mysqlupdate user set password=password(&quot;new_pass&quot;) where user=&quot;root&quot;;flush privileges mysql 8.0 导致的 pdo 链接问题12ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root';flush privileges; crudcreate create alter insertread selectupdate updatedelete delete truncate create12345678910111213141516171819202122-- 创建数据库create database simple_demo;-- 选择数据库use simple_demo;-- 创建表CREATE TABLE `users` ( `id` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '车场ID' , `name` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `email` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `email_verified_at` timestamp NULL DEFAULT NULL, `password` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL, `remember_token` varchar(100) COLLATE utf8mb4_unicode_ci DEFAULT NULL, `created_at` timestamp NULL DEFAULT NULL, `updated_at` timestamp NULL DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=10790252 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;-- 展示建表语句 + /G 为格式化输出show create table usersshow create table users\\Gdesc usersdesc users\\G alter12345678-- 去除索引alter table users drop index `users_email_unique`;-- 增加字段alter table user add age int ;-- 更改字段类型alter table user modify s int;-- 更改字段名+字段类型alter table user change s sex int; insert1234567-- 插入一条数据，且对应字段insert into `bookorder` (`id`,`price`) values(&quot;123&quot;,123.12);-- 插入一条数据，且对应默认字段insert into `bookorder` values(&quot;123&quot;,123.12);-- 插入多条数据，且对应默认字段insert into `bookorder` values(&quot;123&quot;,123.12),values(&quot;124&quot;,123.12); read1234567891011121314-- 查询所有数据select * from bookorder;-- 别名select * from bookorder as b;-- id升序 ，限制10条select * from bookorder as b order by id limit 10;-- id降序，从第10条起取3条数据select * from bookorder as b order by id desc limit 10,3;-- 内联select * from loginunit as l inner join loginUnit as address on l.id = address.luid;-- 左连接，即使右边数据没有select * from loginunit as l left join smartlock as s on l.id = s.luid;-- adderssid 字段非 null 的 并且 city 为 1或2或3select * from loginunit where addressid is not null and city in (1,2,3); update1update bookorder set status='wait' where status='pay'; delete1234-- 删除数据，索引不重置delete from bookorder where createtime &gt;'2019-01-01';-- 删除数据，重置索引truncate table bookorder; other12345678910111213141516171819202122-- 统计某table占用空间，其中TABLE_SCHEMA为数据库名，TABLE_NAME为表名selectTABLE_NAME,concat(truncate(data_length/1024/1024,2),' MB') as data_size,concat(truncate(index_length/1024/1024,2),' MB') as index_sizefrom information_schema.tableswhere TABLE_SCHEMA = 'simple_laravel'order by data_length desc;Alter table tabname drop primary key(col)drop index idxnamecreate view viewname as select statementdrop view viewnameselect count as totalcount from table1求和：select sum(field1) as sumvalue from table1平均：select avg(field1) as avgvalue from table1最大：select max(field1) as maxvalue from table1最小：select min(field1) as minvalue from table1 思考之前出过一次因为因为主库写入数量过多而从库数量不少，但是带宽不够导致的主从同步延迟严重的问题，所以想到了一个树状多层级的mysql主从同步结构，之后有时间可能会用虚拟机进行一下模拟 这篇 blog 主要从带宽的角度来讨论这个问题。 平常常见的一主多从结构 在上图中假设每台 myql 的上传速度均为 U1,下载速度均为D1，master为1台，salve位n台，从主库到从库同步时，主库下载占用带宽忽略不计，从库上传带宽忽略不计，此时分析无延迟同步的速度为 U1/n,每台从库的下载带宽浪费为 D1-(U1/n) ，一旦数据超过U1/n每秒则会产生主从延迟。这种模式比较像平时用的usb扩展坞，转接线之类的情况，一个usb3.0接口分成3个3.0接口其实只是接收方变多了，但是由于传送方的带宽没有变化，会导致copy的总时间没有发生任何变化。体现到数据库上就会产生所谓的主从延迟。就像在学校同学们会互相拷贝软件一样，大家都会选择先从某个同学那拷贝第一份，之后每个拷贝过的同学都具备将信息传递给其他人的能力，从而提交拷贝效率 我想到的比较常见的树状拓扑结构，如下 下图中从根节点开始每个节点都有属于salve，每个节点除根节点外都作为上层master的salve接收上层master传来的数据，同时为下层salve传输数据。这样的好处是减少了master对上传带宽的要求，如上述简单主从同步中每个master的上传带宽为 salve数量n*salve的下载带宽 ，每次增加从库都会给需要给唯一的master增加带宽，容易导致master的带宽变成一个无底洞。树型接口的好处是定好一组结构就可以无线的扩展下取，每个节点的上传带宽和下载带宽都是一个定制（前提需要确定一个节点需要挂在几个子节点）。相比简单的一主多从，底层的同步是经过了更多的节点，例如深度为4的情况下最长的路线是master-&gt;salve(1,1)-&gt;salve(2,1)-&gt;salve(3,1),会天然的产生一定的延迟，所以需要具体情况具体分析。 注：这次讨论的话题主要是有关mysql同步带宽的问题，其中master的写入带宽，树状分布情况下同意结点即作master，又做salve时，用户查询所占用的下载带宽并没有进行深入讨论。仅对同步结构改造减轻一主多从，master承担的带宽压力。因为本职工作并非db所以只是进行了一下浅显的分析/ 后记：这个问题最后线上的解决方案是让写数据的脚本设置的慢一点，同时加大线上带宽。但是从问题产生的原因上来说并没有消除因为带宽导致主从延迟的隐患（这次是选择了减少脚本写入的量，如果由于用户写入过于频繁那有当如何限制？限制每分钟只能有一定量用户可以进行写入操作吗？），同时由于没有对线上服务器做流量规划导致今后是否因为从库更多导致带宽又不够用了，或者由于master出问题，但是代替的master没有设置足够的带宽，导致一替代原有master就立刻产生更严重的主从延迟问题？ 删除一个数据库所有表12SHOW FULL TABLES WHERE table_type = 'BASE TABLE'; 然后一个一个drop 。查看的laravel源码","link":"/2018/11/04/amazing_tool/h2u_mysql/"},{"title":"python[001]:install","text":"1 由于使用环境为 windows（虽然子系统安装了，但是是为了安装基于 python 的进程管理工具，并非使用 python 在 linux 下开发），所以很简单的啦~，这里略过需要注意的是 pip 的使用 123pip install NumPy pip install Pandas pip install Matplotlib 迁移模块 12pip freeze &gt; requirement.txtpip install -r requirement.txt 这个迁移方式不是很习惯 python闭包写法12345678910def func() return def func1(): def func(): return 1 return funcfunc2 = func1()print(func2)","link":"/2019/03/18/amazing_tool/h2u_python/"},{"title":"how to use regex","text":"12345678#匹配出所有的codecept_debug代码,包括已经注释掉的(//)?codecept_debug\\(.*\\)(;)?# 匹配单行sql^select (.)*;$# 阻止贪婪^select \\* (.|\\n)*?;$# 匹配单行换行^\\n$","link":"/2018/12/05/amazing_tool/h2u_regex/"},{"title":"how to use svn","text":"回滚 合并分支 svn 根据提交人过滤 / sed 命令的使用 匹配文件后缀为 .jpg 的文件并且删除 grep and kill svn 如何实现vimdiff 回滚12svn merge -rhead:[old version] [file]#将file 的 old 版本合并到当前 合并分支1234svn --dry-run merge -r51744:head svn://svn1.idc.xiaozhu.com/xiaozhu/webV2/branches/dev/r_neworderv2-hanzhijie-2018-09-13#展示效果不实际执行svn merge -r51744:head svn://svn1.idc.xiaozhu.com/xiaozhu/webV2/branches/dev/r_neworderv2-hanzhijie-2018-09-13#将指定svn -r51744 到head 的所有变化 合并到当前本地仓库 svn 根据提交人过滤 / sed 命令的使用1svn log --limit 10 -v | sed -n '/username/,/-----$/ p' 匹配文件后缀为 .jpg 的文件并且删除1find ./ -name '*.jpg' | xargs rm grep and kill1ps -ef|grep &quot;zhaoyinfan/supervisor&quot; | grep -v grep | awk '{print $1}' | xargs kill -9 svn 如何实现vimdiff123vim ~/.subversion/configdiff-cmd = /usr/local/bin/svndiff 12345678#!/bin/sh#配置你喜欢的diff程序路径 svndiff DIFF=&quot;vimdiff&quot;#SVN diff命令会传入两个文件的参数 LEFT=${6} RIGHT=${7}# 拼接成diff命令所需要的命令格式 $DIFF $LEFT $RIGHT","link":"/2020/01/28/amazing_tool/h2u_svn/"},{"title":"如何使用uwp制作一个视频播放器(How to use uwp to make a video player)","text":"UWP-001:什么是通用 Windows 平台 (UWP) 应用？ UWP-002:开发目的+起步 开发原因 起步 使用grid，并在左上添加一段文字 使用listView绑定数据渲染 UWP-003:视频组件和创建自定义传输控件 UWP-004:事件和sqlite的引用 UWP-001:什么是通用 Windows 平台 (UWP) 应用？UWP 应用的特点： 安全：UWP 应用声明其访问哪些设备资源和数据 用户必须对该访问授权。 能够在运行 Windows 10 的所有设备上使用常见的 API。 可以使用设备的特定功能并让 UI 适应不同的设备屏幕尺寸、分辨率和 DPI。 通过运行 Windows 10 的所有设备（或只是你指定的设备）上的 Microsoft Store 提供。 Microsoft Store 提供了多种利你的应用赚钱的方式。 能够在不对计算机构成风险或引起“计算机腐烂”的情况下安装和卸载。 互动：使用动态磁贴、推送通知以及与 Windows 时间线和 Cortana 的“Pick Up Where I Left Off”交互的用户活动吸引用户。 可使用 C#、C++、Visual Basic 和 Javascript 编程。 对于 UI，使用 XAML、HTML 或 DirectX。 什么是通用 Windows 平台 (UWP) 应用？ UWP-002:开发目的+起步开发原因由于暴风gg了，win10 win store里面也没有觉得很好的播放器，而各大互联网厂商的播放器主要目的不是播放本地文件，win10自带的播放器又过分简陋，所以打算开发一个基于uwp的播放器，选择这个的原因呢通过有以下几点 q:为什么不选择可跨平台的一些开发方案?a:跨平台成本高，并且主要用win本子，跨平台的一些虽然看着美好，实际上个人开发只会关注一个平台q:为什么选择开发uwp？a:因为uwp可以发布在商店，相比于传统的exe更安全，分发途径比较好，小众软件商店下载比较好一点q:有啥不好的地方吗？a:微软开发者账号注册不能用微信支付宝银行卡，，，有点费劲啊，这整的 目的：开发一个简洁的播放器，方便调节倍速就好 起步开发环境使用的是vs2019，安装uwp开发相关的选项， 本文比较糙，如作参考，切勿钻牛角尖音响效率 simpleM’s GitHub uwp 里其实和 web网页开发类似， xaml、cs文件与html、css、js等算是也有对应关系，同时uwp中grid的布局方式我使用起来比较顺手，所以起步还是比较方便的 使用grid，并在左上添加一段文字简单布局,在MainPage.xaml中添加一个2*2的布局,并在左上的格子添加一段文字 1234567891011121314&lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;7*&quot;/&gt; &lt;ColumnDefinition Width=&quot;3*&quot;/&gt;&lt;/Grid.ColumnDefinitions&gt;&lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition Height=&quot;9.5*&quot;/&gt;&lt;/Grid.RowDefinitions&gt;&lt;Grid Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot;&gt;&lt;TextBlock Text=&quot;提示&quot; FontSize=&quot;20&quot; FontWeight=&quot;Medium&quot; /&gt;&lt;/Gird&gt; 使用listView绑定数据渲染123456789&lt;Grid Grid.Row=&quot;0&quot;&gt; &lt;ListView Name=&quot;MItems&quot; ItemsSource=&quot;{x:Bind VideoFileInfoList}&quot; ItemClick=&quot;MItems_ItemClick&quot; IsItemClickEnabled=&quot;True&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;TextBlock Text=&quot;{Binding FilePath}&quot;/&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt;&lt;/Grid&gt; 1234567public sealed partial class MainPage : Page{ public ObservableCollection&lt;VideoFileInfoData&gt; VideoFileInfoList = new ObservableCollection&lt;VideoFileInfoData&gt;(); /* ... */} UWP-003:视频组件和创建自定义传输控件本文比较糙，如作参考，切勿钻牛角尖音响效率 simpleM’sGitHub uwp 视频播放器元素类 MediaPlayerElement 简单引入并播放 1&lt;MediaPlayerElement Source=&quot;ms-appx:///Media/video1.mp4&quot; AutoPlay=&quot;True&quot; /&gt; 创建自定义传输控件 从windows (Program Files)\\Windows Kits\\10\\DesignTime\\CommonConfiguration\\Neutral\\UAP(SDK version)\\Generic 中的xaml复制需要的空间默认样式至项目中的Themes\\generic.xaml ,如没有自行创建 更改 123&lt;Style TargetType=&quot;local:自定义控件名称名字&quot;&gt;&lt;ControlTemplate TargetType=&quot;local:自定义控件名称名字&quot;&gt; 创建新类自定义控件名称名字.cs并在构造函数中引用自定义的配置 123456789public sealed class SuperSimpleMediaTransportControls : MediaTransportControls{ public SuperSimpleMediaTransportControls() { // 我定义的空间名称为SuperSimpleMediaTransportControls this.DefaultStyleKey = typeof(SuperSimpleMediaTransportControls); } UWP-004:事件和sqlite的引用本文比较糙，如作参考，切勿钻牛角尖音响效率 simpleM’s GitHub 123456789101112131415161718192021&lt;Grid Grid.Row=&quot;1&quot; &gt; &lt;Grid&gt; &lt;MediaPlayerElement Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Name=&quot;mediaPlayer&quot; AutoPlay=&quot;True&quot; Visibility=&quot;Visible&quot; AreTransportControlsEnabled=&quot;True&quot;&gt; &lt;MediaPlayerElement.TransportControls&gt; &lt;local:SuperSimpleMediaTransportControls IsCompact=&quot;True&quot; IsZoomButtonVisible=&quot;True&quot; IsZoomEnabled=&quot;True&quot; IsPlaybackRateButtonVisible=&quot;True&quot; IsPlaybackRateEnabled=&quot;True&quot; AddPlaybackRated=&quot;SuperSimpleMediaTransportControls_AddPlaybackRated&quot; InitPlaybackRated=&quot;SuperSimpleMediaTransportControls_InitPlaybackRated&quot; ReducePlaybackRated=&quot;SuperSimpleMediaTransportControls_ReducePlaybackRated&quot; &gt; &lt;/local:SuperSimpleMediaTransportControls&gt; &lt;/MediaPlayerElement.TransportControls&gt; &lt;/MediaPlayerElement&gt; &lt;/Grid&gt;&lt;/Grid&gt; 123456private void SuperSimpleMediaTransportControls_ReducePlaybackRated(object sender, EventArgs e){ mediaPlayer.MediaPlayer.PlaybackSession.PlaybackRate -= 0.1; UpShowText(&quot;当前播放速度为：&quot; + mediaPlayer.MediaPlayer.PlaybackSession.PlaybackRate);} 在 UWP 应用中使用 SQLite 数据库 官方数据库示例貌似有缺陷，在我的版本不能正常运行，最下方也有人提出相同问题，并且官方数据库的使用范例为先写一个lib，然后引入lib，目前所写的播放器并用不到这种分离，就在simpleM项目中直接进行sqlite的引用","link":"/2020/01/09/amazing_tool/h2u_uwp/"},{"title":"how to use vargrant","text":"12345678910111213$ vagrant init # 初始化 $ vagrant up # 启动虚拟机 $ vagrant halt # 关闭虚拟机 $ vagrant reload # 重启虚拟机 $ vagrant ssh # SSH 至虚拟机 $ vagrant suspend # 挂起虚拟机 $ vagrant resume # 唤醒虚拟机 $ vagrant status # 查看虚拟机运行状态 $ vagrant destroy # 销毁当前虚拟机 #box管理命令 $ vagrant box list # 查看本地box列表 $ vagrant box add # 添加box到列表 $ vagrant box remove # 从box列表移除 1234# 更改Homestead.yaml 后 执行以下指令，进行重新配置vagrant.exe up --provision==&gt; homestead-7: Machine already provisioned. Run `vagrant provision` or use the `--provision`","link":"/2018/11/04/amazing_tool/h2u_vargrant/"},{"title":"how to use win","text":"如何设置开机启动项 代理设置 cmd代理设置和恢复（win 下推荐使用 powershell） powershell代理设置 软件推荐 TrafficMonitor Everything pandoc net 端口查看 如何设置开机启动项windows 设置开启启动除了设置注册表这种比较不够win的方式，还可以将执行文件的快捷方式放入启动目录，这样也可以做到开机启动 123C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartupC:\\Users\\{usename}\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs\\Startup注册表 代理设置cmd代理设置和恢复（win 下推荐使用 powershell）123456789101112set http_proxy=socks5://127.0.0.1:10010set https_proxy=socks5://127.0.0.1:10010set http_proxy_user=userset http_proxy_pass=passset https_proxy_user=userset https_proxy_pass=passset http_proxy=set https_proxy= powershell代理设置123456Set-Item Env:http_proxy &quot;http://127.0.0.1:1080&quot; Set-Item Env:https_proxy &quot;http://127.0.0.1:1080&quot;Remove-Item Env:http_proxyRemove-Item Env:https_proxy 软件推荐TrafficMonitor TrafficMonitor 简介Traffic Monitor是一款用于Windows平台的网速监控悬浮窗软件，可以显示当前网速、CPU及内存利用率，支持嵌入到任务栏显示，支持更换皮肤、历史流量统计等功能。 github地址download地址 Everything 基于名称快速定位文件和文件夹。 Everything-voidtools pandoc一个word转md的软件 1pandoc -s example.docx -t markdown -o example.md net端口查看1234netstat -anonetstat -ano |findstr &quot;端口号&quot;tasklist |findstr &quot;进程id号&quot;# taskkill /f /t /im &quot;进程id或者进程名称&quot; markdown-itKaTeXMathJax","link":"/2021/01/28/amazing_tool/h2u_win/"},{"title":"how to use wsl","text":"1. WSL2 linux权限问题 chmod(): Operation not permitted 解决方法 1. WSL2 linux权限问题 chmod(): Operation not permitted解决方法最近在 WSL 下碰到PHP chmod(): Operation not permitted 这个问题，看起来是文件权限的问题，不过查看该文件的权限是 777，不知道是 Bug 还是什么原因导致的，Google 找了下，有说是 Windows 文件系统是 NTFS 的问题，Linux 挂载需要开启一些特性，解决办法是更改 wsl.conf文件。 1sudo vim /etc/wsl.conf 添加挂载磁盘的一些默认设置。 1234567891011# 2. 添加下面内容[automount]enabled = trueroot = /mnt/options = &quot;metadata,umask=22,fmask=111&quot;mountFsTab = true[filesystem]umask = 022 更改重启之后，一些文件的权限会改为跟 Linux 权限一样，不再是默认的全部 777 了。 12# 管理员权限启动windows cmd命令行net.exe stop LxssManager","link":"/2020/05/04/amazing_tool/h2u_wsl/"},{"title":"my awesome","text":"浏览器收藏栏收藏了了许多看过的。一直没清理，导致越来越多，不不方便管理，所以把一些已经看完/或者以后可能会查询但是目前不看的收藏的放在这 收藏文档类Nest.js 中文文档📙 Emojipedia — 😃 Home of Emoji Meanings 💁👌🎍😍TensorFlow中文社区-首页国家信息安全漏洞库在线工具 | 冰羽の博客 | A Blog Focused on Technology简书吾爱破解菜鸟教程csdn廖雪峰实验楼 牛客网语义化版本 2.0.0 | Semantic Versioning文档简介 · TypeScript中文网 · TypeScript——JavaScript的超集Docker 教程 | 菜鸟教程《Laravel 8 中文文档》 | Laravel China 社区The Go Programming LanguagePHP: 核心配置选项列表 - ManualSemantic Versioning 2.0.0 | Semantic Versioning吾爱破解 - LCG - LSG|安卓破解|病毒分析|破解软件|www.52pojie.cnnginx 之 proxy_pass详解 - 简书 toolMermaid live editorAdoptOpenJDK - Open source, prebuilt OpenJDK binaries扩展程序Inspect with Chrome Developer ToolsUrlEncode编码/UrlDecode解码 - 站长工具在线工具 - 程序员的工具箱在线JSON校验格式化工具（Be JSON）JSON Editor Online - view, edit and format JSON online兔二工具 - 一个很有范的工具合集如何制作纯 ASCII 文本流程图 - DiggLifePackagistTheia - Cloud and Desktop IDESupervisor: A Process Control System — Supervisor 4.2.2 documentationPNG转SVG - 在线转换图像文件Windows Terminal ThemesPhp2Golang - Golang alternatives to PHP functions, classes and libraries - Php2GolangJSON-to-Go: Convert JSON to Go instantlyHome · pkg.go.dev githubzhaoolee/StarsAndClown: ☀️Github星聚弃疗榜,为Github优秀项目写一封推荐信，让Github优秀项目造福人类~ Github apocalypse list, write a letter of recommendation for Github's outstanding projects, and let Github excellent projects JanDeDobbeleer/oh-my-posh: A prompt theming engine for Powershell running in ConEmugoproxy.cn/README.zh-CN.md at master · goproxy/goproxy.cnfacert/awesome-spider: 爬虫集合ar414-com/php-source-lib: phper common resources and libWarpPrism/AutoPiano: 自由钢琴 🎹 AutoPiano ( https://www.autopiano.cn ) Simple &amp; Elegant Piano OnlineGet started with GitHubSpaceVim/SpaceVim: A community-driven modular vim distribution - The ultimate Vim configurationproject-mirai/mirai-api-http: Mirai HTTP API (console) pluginrichardchien/coolq-http-api: 为 酷Q 提供通过 HTTP 或 WebSocket 接收事件和调用 API 的能力brndnmtthws/conky: Light-weight system monitor for X.ziadoz/awesome-php: A curated list of amazingly awesome PHP libraries, resources and shiny things.艺术 - Google 相册RAP2 php鸟哥博客pthreadsreactphpphp_gtk 用php写桌面应用，哈哈哈，我看的都是啥东西 symfonydoctrinelaravelcodeceptionlaravel源码研究 我当时查看的时候还是这个刚更新的时候，现在应该是落后时代了哈哈哈。laravel关于规范phpbookphp-fig_psrphp-figphp-watchdeployer基于 PHP 的内网穿透工具 “Spike”imagineimageglide goGo 编程语言首页 - beego: 简约 &amp; 强大并存的 Go 应用框架sync/atomic[go-resty/resty: Simple HTTP and REST client library for Go](https://github.com/go-resty/restygo前景 · Go语言中文文档The Go Programming LanguageCodeReviewComments · golang/go Wiki《Go 编程实例 Go by Example》 | Go 技术论坛Gin Web FrameworkJSON-to-Go: Convert JSON to Go instantlyAwesome Gospf13/cobra: A Commander for modern Go CLI interactionsPhp2Golang - Golang alternatives to PHP functions, classes and libraries - Php2GolangHome · pkg.go.devtensorflow · pkg.go.devfrpgo-gomail/gomail: The best way to send emails in Go.实用 Docker 速查大全：快速认识 Docker 的概念和使用方法 | Server 运维论坛fatedier/frp: A fast reverse proxy to help you expose a local server behind a NAT or firewall to the internet.Php2Golang - Golang alternatives to PHP functions, classes and libraries - Php2Golanghttps://learnku.com/go/t/51595 fronthexo-theme-icarus/community - Gitter文件上传之multer - DJL箫氏 - 博客园Supported Functions · KaTeXKaTeX – The fastest math typesetting library for the web前端学习路线（很长，建议收藏） - 知乎Butterfly - A Simple and Card UI Design theme for HexoStandard ECMA-119ES6 入门教程 - ECMAScript 6入门Electron | 使用 JavaScript，HTML 和 CSS 构建跨平台的桌面应用程序。electron-builderelectron/windows-installer: Build Windows Installers for Electron appsVue.jsVuex 是什么？ · VuexReact – 用于构建用户界面的 JavaScript 库React 菜单组件 - Material-UINW.jsBootstrap中文网webpack 中文文档 | webpack 中文网export - JavaScript | MDNllh911001/mostly-adequate-guide-chinese: JS 函数式编程指南中文版Yarn &amp;&amp; npm设置镜像源 - 灯塔下的守望者 - 博客园终于讲清楚了nodejs中exports和module.exports的区别_JavaScript_嘿嘿-CSDN博客Swiper使用方法 - Swiper中文网入门篇 - JavaScript 教程 - 网道Getting Started | bluebirdInfinitown | A WebGL Experiment by Little Workshop默认主题 - Material-UI[Preview] \\README.md - conwnet/github1s - GitHub1sThe HTML presentation framework | reveal.jsWePY Document windowsWindows Terminal ThemesPNG转SVG - 在线转换图像文件MinGW-w64 - for 32 and 64 bit Windows - Browse Files at SourceForge.netWSL2来了！但是能正常使用并不简单 - 知乎BASH和PowerShell命令对照表 – PowerShell 中文博客PowerShell中Job相关命令及并行执行任务详解_PowerShell_脚本之家PowerShell 在线教程 - PowerShell 中文博客批处理之家 批处理_BAT_CMD_DOS_VBS_Perl_Python_PowerShell - Powered by Discuz!chocoScoop【已完结】面向新手的 UWP 开发教程中文字幕视频 - 知乎在 UWP 应用中使用 SQLite 数据库 - UWP apps | Microsoft DocsWindows 终端概述 | Microsoft DocsHyper™ linuxGit:代码冲突常见解决方法 - CSDN博客nohup和&amp;后台运行，进程查看及终止 - 弥尘 - 博客园GoAccess - 常见问题grep命令_Linux grep 命令用法详解：强大的文本搜索工具史上最全Vim快捷键键位图（入门到进阶） | 菜鸟教程Linux命令大全(手册)_Linux常用命令行实例详解_Linux命令学习手册从 p12 格式 SSL 证书解出 pem 格式公钥私钥给 Postman 使用 - 常伟佳 - 博客园Ubuntu 安装mysql和简单操作 - Rogn - 博客园 otherTermux 入门教程：架设手机 Server 下载文件qqbotarchitect-awesomeowncloudnextcloudcloudreve","link":"/2021/06/21/amazing_tool/hot_to_see/"},{"title":"JekyllToHexo","text":"githubPage 博客迁移 从 jeyll 到 hexo hexo 的中文文档较为健全，我这里就只引入一下我参考部署相关的一些参考网站， 12https://hexo.io/zh-cn/http://theme-next.iissnan.com/getting-started.html 个人补充 jeyll 和 hexo 虽然从效果上看都可以将个人博客部署到 githubPage , 但个人看来在部署上还是有实现上的差别, jeyll 是基于 reby 由模板引擎渲染生成, hexo 则是将一整套静态网页部署到github。(个人感觉在 jeyll 投入过多，只是在重复的学习后端轮子的使用，倒不如切换到 hexo) 关于 hexo 的部署，网上有详细的操作，这里只是对 hexo generator repo 保存的补充，当使用 git 引入别的 themes 时，如果对themes 进行改动时，要注意将 themes 进行保存提交 ，一个方案是将 themes 单独作为一个项目保存， 另一个方案是将该主题的仓库清除，并入 hexo generator repo 保存，命令如下 123git rm -r --cached some-directorygit commit -m &quot;Remove the now ignored directory some-directory&quot;git push -u origin master 参考:github上文件夹都是灰色-解决办法使用hexo，如果换了电脑怎么更新博客？Hexo Next主题 设置圆形头像并旋转 hexo hello worldWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2018/11/05/blog/JekyllToHexo/"},{"title":"my-config","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118alias workspace='cd /Users/thh/workspace'alias sha='shasum -a 256 'alias untar='tar -zxvf 'alias vi='vim'alias wget='wget -c 'alias ipi='ifconfig getifaddr en0'alias ipe='curl ipinfo.io/ip'alias c='clear'alias cls='clear'alias ipe='curl ipinfo.io/ip'alias ipi='ifconfig getifaddr en0'alias ping='ping -c 5'alias sha='shasum -a 256 '#alias phpstan='~/tools/vendor/bin/phpstan'alias rphpstan='phpstan analyse --error-format table -c ~/tools/phpstan.neon'alias needpwd=' openssl rand -base64 16'alias showip='cat /etc/resolv.conf'hello(){ echo &quot;\\n&quot; echo &quot;needpwd\\n&quot; echo &quot;ii\\n&quot; echo &quot;showip\\n&quot; echo &quot;gitcbr\\n&quot;}gitcbr(){ $1 git checkout -b $1 origin/$1}gitpp(){ $1 git push origin $1:$1}alias upsource=&quot;source ~/.zshrc&quot;alias hosts='code /etc/hosts'alias phpunit='./vendor/bin/phpunit'cddr(){ echo $1 case $1 in php71 ) docker exec -it php-71 /bin/zsh ;; p71 ) docker exec -it php-71 /bin/zsh ;; php72 ) docker exec -it php-72 /bin/zsh ;; p72 ) docker exec -it php-72 /bin/zsh ;; php ) docker exec -it php-super /bin/zsh ;; p ) docker exec -it php-super /bin/zsh ;; nginx) docker exec -it nginx /bin/sh ;; ng) docker exec -it nginx /bin/sh ;; php8) docker exec -it php-80 /bin/zsh ;; p8) docker exec -it php-80 /bin/zsh ;; n) docker exec -it nginx bash ;; esac}upngconfig(){ docker exec nginx nginx -s reload}pdate(){ php -r 'echo date(&quot;Y-m-d H:i:s&quot;,time()).PHP_EOL;'}ptime(){ php -r 'echo time();'}source ~/.bash_profilegitsetp(){ git config --global http.proxy 'http://127.0.0.1:11000' git config --global https.proxy 'http://127.0.0.1:11000'}gitunsetp(){ git config --global --unset http.proxy git config --global --unset https.proxy}# export PATH=$PATH:/Users/thh/go/bin# export PATH=$PATH:/Users/thh/.local/platform-tools# export PATH=$PATH:/Users/thh/.local/bin# export MAVEN_HOME=/Users/thh/.local/apache-maven-3.8.1# export PATH=$PATH:$MAVEN_HOME/bin# export PATH=&quot;/opt/homebrew/opt/php@7.4/bin:$PATH&quot;# export PATH=&quot;/opt/homebrew/opt/php@7.4/sbin:$PATH&quot;# export PATH=&quot;/opt/homebrew/opt/node@12/bin:$PATH&quot;","link":"/2021/09/26/amazing_tool/my-config/"},{"title":"你的一阳指","text":"Before You Feel PressureAlright, everyone looking forward, please. 请大家都朝我这边看。 Good morning , year elevens. 早上好，11年级的同学们。 Today’s assembly is about the start of a journey 今天的集会是关于一段新的开始。 The start of the rest of your lives. 它将开启你们今后的余生。 In 2 years time all of you will be finishing your A levels. 再过两年，你们就会完成A levels的学业。 In 3 yeas time you’ll be studying across the world, studying at the university of your choice. 再过三年，你们就会去到自己想去的国家，上自己想上的大学。 In 5 years time you’ll have started your careers. 再过五年，你们就会开启自己的职业生涯。 Many of you will be in this room working for the top institutions across the globe. 你们在座的很多同学会进入世界顶尖公司工作。 You will then get married, you then may buy a house. 然后你们会结婚，买房。 In 10 years time your life will be set for you. 十年之后，你的人生就会安定下来。 In 15 years you’ll be 30 and from then on your path, your life will be set. 再过十五年，你就三十岁了，你的人生轨迹就会定型。 I’m sorry, Mr.Headmaster, let me tell you why that approach may fail you. 抱歉，校长，我想告诉你为什么你的这些话是错的。 I know people who graduated at 21 and didn’t get a job until they were 27. 有的人21岁毕业，到27岁才找到工作。 I know people who graduated late at 25 and they found work immediately. 有的人25岁才毕业，但马上就找到了工作。 I know people who never went to university, but found what they love at 18. 有的人没上过大学，却在18岁就找到了热爱的事。 I know people who found a job straight out of college making decent money, but hate what they do. 有的人毕业就找到好工作，赚很多钱，却过得不开心。 I know people who took gap years and found their purpose. 有的人选择间隔年，去寻找自我。 I know people who were so sure about what they were going to do at 16, they change their mind at 26. 有的人在16岁就清楚知道自己要什么，但在26岁时改变了想法。 I know people who have children but are single, and I know people who are married but had to wait 8 to 10 years to have children. 有的人有了孩子，却还是单身。有的人结了婚，却等了10年才生孩子。 I know people in relationships who love someone else. 有的人身处一段感情，爱的却是别人。 I know people who love each other but aren’t together. 有的人明明彼此相爱，却没有在一起。 So my point is everything in life happens according to our time, our clock. 我想说的是，人生中的每一件事都取决于我们自己的时间。 You may look at some of your friends and think that they’re ahead of you, maybe some of them you feel are behind, but everything happens at their own pace. 你身边有些朋友也许遥遥领先于你。有些朋友也许落后于你，但凡事都有它自己的节奏。 They have their own time and clock and so do you. 他们有他们的节奏，你有你自己的。 Be patient. 耐心一点。 At age 25, Mark Cuban was a bartender in Dallas. 库班25岁的时候还在酒吧做酒保。 It took till 32 for J.K.Rowling to be published for Harry Potter after being rejected by 12 publishers. 在被拒12次之后，JK罗琳到32岁才出版了哈利波特。 Ortega launched ZARA when he was 39. Ortega 到39岁才创办了ZARA。 Jack Ma started Alibaba when 35. 马爸爸35岁才建立了阿里巴巴。 Morgan Freeman got his big break at 52. 摩根佛里曼到52岁才迎来他演艺事业的大爆发。 Steve Carell only got his break after40 yeas old. Steve Carell 40岁才红。 Virgin was started by Richard Branson at 34. Richard Branson 34岁才创办维珍航空。 Getting your degree after 25 is still an achievement. 25岁后才拿到文凭，依然值得骄傲。 Not being married at 30 but still happy is beautiful. 30岁没结婚，但过得快乐也是一种成功。 Starting a family after 35 is still possible and buying a house after 40 is still great. 35岁之后成家也完全可以，40岁买房也没什么丢脸的。 Don’t let anyone rush you with their time lines. 不要让任何人扰乱你的时间表。 Because as Einstein said, “ Not everything that counts can be counted and not everything that’s counted truly counts.” 因为爱因斯坦曾经说过：并不是每一件算的出来的事，都有意义，也不是每一件有意义的事，都能够被算出来。 And this is the most important thing, I want you to be able to create meaningful, purposeful fulfilling lives for yourselves and learn how to use that to make an impact and a difference in the lives of others. 这才是最重要的事，我希望你们可以创造属于自己的充满意义的人生，我希望你们可以创造属于自己的充满意义的人生。学会用这些去影响点亮他人的生活。 That will be true success. 这才是真正的成功。 本文截取字天龙八部 本因、本观、本相、本参四僧见了鸠摩智献演三种指力，都不禁怦然心动，知道三卷奇书中所载，确是名闻天下的少林寺七十二门绝技，是否要将“六脉神剑”的图谱另录副本与之交换，确是大费踌躇。 本因道：“师叔，明王远来，其意甚诚。咱们该当如何应接，请师叔见示。” 枯荣大师道：“本因，咱们练功习艺，所为何来？” 本因方丈没料到师叔竟会如此询问，微微一愕，答道：“为的是弘法护国。”枯荣大师道：“外魔来时，若是吾等道浅，难用佛法点化，非得出手降魔不可，该用何种功夫？”本因道：“若不得已而出手，当用一阳指。”枯荣大师问道：“你在一阳指上的修为，已到第几品境界？”本因额头出汗，答道：“弟子根钝，又兼未能精进，只修得到第四品。”枯荣大师再问： “以你所见，大理段氏的一阳指与少林拈花指、多罗叶指、无相劫指三项指法相较，孰优孰劣？”本因道：“指法无优劣，功力有高下。”枯荣大师道：“不错。咱们的一阳指若能练到第一品，那便如何？”本因道：“渊深难测，弟子不敢妄说。”枯荣道：“倘若你再活一百岁，能练到第几品？”本因额上汗水涔涔而下，颤声道：“弟子不知。”枯荣道：“能修到第一品吗？” 本因道：“决计不能。”枯荣大师就此不再说话。","link":"/2018/11/19/blog/Just/"},{"title":"我的2021","text":"我的2021 2021/06/20 星期日 2021/05/19 星期三 2021/05/16 星期日 2021/05/03 星期一 2021/04/36 星期一 2021/04/24 星期六 去参加扶风国王子的婚礼 2021/04/17 星期六 2021/04/09 星期五 2021/04/08 星期四 2021/04/04 清明节 2021/03/28 星期日 2021/03/27 星期六 2021/03/26 星期六 2021/03/17 星期三 2021/03/17 星期二 2021/03/12 星期五 2021/03/08 星期一 2021/02/24 星期三 2021/02/19 星期五 2021/02/15 星期一 2021/01/30 星期六 2021/01/28 星期四 2021/06/20 星期日打疫苗呀打疫苗 2021/05/19 星期三旧代码中的高级代码的存留问题 2021/05/16 星期日知乎收藏夹整理大作战 pacvim PacVim：一个学习 vim 命令的命令行游戏 2021/05/03 星期一宅了三天，晚上去了一趟东方明珠 2021/04/36 星期一wsl2 不夸系统访问 io 表现正常 2021/04/24 星期六 去参加扶风国王子的婚礼去参加扶风国王子的婚礼 2021/04/17 星期六终于是个平安的周末，进行了入职体检 2021/04/09 星期五去了发热门诊 2021/04/08 星期四晚上发烧了，睡得很热 2021/04/04 清明节今天体检机构放假，所以需要下周体检了 2021/03/28 星期日早上初试，下午复试，结束的比较早，坐飞机回上海了 2021/03/27 星期六早上出发，晚上9点到达兰州，10点入住，背了背题 2021/03/26 星期六接到调剂信息，购买了去兰州的票 2021/03/17 星期三2021/03/17 星期二去看了传说中的木核老师 2021/03/12 星期五2021/03/08 星期一面了4天半，下雨挺多的 2021/02/24 星期三 嚯，原来是你小子 今天用 gin+gorm 组合来进行压测，结果基本上是没法测试。一开始以为是链接未关闭导致的阻塞。但是没有数据库请求的链接是没有问题的。各种工具试了一遍。一开始是bombardier压测，后来用ab测试，都是跟抽筋一样。最后查的mysql连接数。如下 123456789101112131415161718192021222324252627mysql&gt; show status like &quot;%connect%&quot;;+-------------------------------------------------------+---------------------+| Variable_name | Value |+-------------------------------------------------------+---------------------+| Aborted_connects | 1 || Connection_errors_accept | 0 || Connection_errors_internal | 0 || Connection_errors_max_connections | 0 || Connection_errors_peer_address | 0 || Connection_errors_select | 0 || Connection_errors_tcpwrap | 0 || Connections | 172 || Locked_connects | 0 || Max_used_connections | 27 || Max_used_connections_time | 2021-02-24 00:14:24 || Mysqlx_connection_accept_errors | 0 || Mysqlx_connection_errors | 0 || Mysqlx_connections_accepted | 0 || Mysqlx_connections_closed | 0 || Mysqlx_connections_rejected | 0 || Performance_schema_session_connect_attrs_longest_seen | 128 || Performance_schema_session_connect_attrs_lost | 0 || Ssl_client_connects | 0 || Ssl_connect_renegotiates | 0 || Ssl_finished_connects | 0 || Threads_connected | 26 |+-------------------------------------------------------+---------------------+ 但是我gorm里面设置的链接数为100，导致数据库连接出现了阻塞。将连接数调小之后，压测顺利进行。因为最后设置的为20。数据尚可。扩大mysql的链接数后，应该可以更多。 2021/02/19 星期五 今天晚上可是算blogs好好整理了一波 欢迎来到超级微小的编译器! 中文翻译版 代码作妖记 go 的 add(1)(2)(3) 算是写出来了。就是混入了一些奇怪的东西 1234567891011121314151617181920package mainfunc main(){ fmt.Println(add(1,2,3).(func(n ...int) interface{})(1).(func(n ...int) interface{})(2).(func(n ...int) interface{})().(int))}func add(n ...int) interface{} { if len(n)==1 { return n[0] } else { sum:=0 for _,value:=range n{ sum+=value } return func(newN...int) interface {}{ newN = append(newN,sum) return add(newN...) } }} 2021/02/15 星期一嚯，今天用https://github.com/oxequa/realize,这个工具可真是一波三折，go get 后提示依赖有问题，issue里面有人也提出这个问题，是关闭GO111MODULE,反正我用了，还是无效，他的那个依赖在 gopkg.in直接打开地址也是404，最后还是对master的代码git clone+go install一把梭。不过看了本地的许多包，好像都是把所有的tag都拉取下来了。不知道这个设计的摸底是为了啥。问题解决了，很好。 2021/01/30 星期六 只有记性好的人才会记得自己忘记了什么，而记性差的人是不记得自己忘记了什么 2021/01/28 星期四 下午好困 picgo感觉很不稳定，与其在picgo的基础基于github上做一个图库，倒不如直接本地用单文件做一个web服务进行更全面的管理。定制化更高。个人使用的话，应该不会超过1w张图吧。过去qq空间的图片乱七八糟拍了很多年的数量估计。数量应该不会有巨大影响。 多则惑少则得 今天上午整理了一下之前的博客，因为都是断断续续写的，所以比较零散。有的也比较重复文章太多导致有些时候查找起来不是很方便，有些分类已经随着各种零散记录的增加变得不再合。所以做了一些合并，整理成了 how to use 这个分类，当然以后其他的记录可能会变成篇少字多方便查阅。 y~~","link":"/2021/12/31/blog/amazing-diary-2021/"},{"title":"中文文案排版指北","text":"转载 中文文案排版指北 统一中文文案、排版的相关用法，降低团队成员之间的沟通成本，增强网站气质。 其他语言： 英语 繁体中文 简体中文 简体中文（外部链接） 目录空格「有研究显示，打字的时候不喜欢在中文和英文之间加空格的人，感情路都走得很辛苦，有七成的比例会在 34 岁的时候跟自己不爱的人结婚，而其余三成的人最后只能把遗产留给自己的猫。毕竟爱情跟书写都需要适时地留白。 与大家共勉之。」——vinta/paranoid-auto-spacing 中英文之间需要增加空格正确： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。 错误： 在LeanCloud上，数据存储是围绕AVObject进行的。 在 LeanCloud上，数据存储是围绕AVObject 进行的。 完整的正确用法： 在 LeanCloud 上，数据存储是围绕 AVObject 进行的。每个 AVObject 都包含了与 JSON 兼容的 key-value 对应的数据。数据是 schema-free 的，你不需要在每个 AVObject 上提前指定存在哪些键，只要直接设定对应的 key-value 即可。 例外：「豆瓣FM」等产品名词，按照官方所定义的格式书写。 中文与数字之间需要增加空格正确： 今天出去买菜花了 5000 元。 错误： 今天出去买菜花了 5000元。 今天出去买菜花了5000元。 数字与单位之间需要增加空格正确： 我家的光纤入屋宽带有 10 Gbps，SSD 一共有 20 TB 错误： 我家的光纤入屋宽带有 10Gbps，SSD 一共有 20TB 例外：度 / 百分比与数字之间不需要增加空格： 正确： 今天是 233° 的高温。 新 MacBook Pro 有 15% 的 CPU 性能提升。 错误： 今天是 233 ° 的高温。 新 MacBook Pro 有 15 % 的 CPU 性能提升。 全角标点与其他字符之间不加空格正确： 刚刚买了一部 iPhone，好开心！ 错误： 刚刚买了一部 iPhone ，好开心！ 刚刚买了一部 iPhone， 好开心！ 用 text-spacing 来挽救？CSS Text Module Level 4 的 text-spacing 和 Microsoft 的 -ms-text-autospace 可以实现自动为中英文之间增加空白。不过目前并未普及，另外在其他应用场景，例如 macOS、iOS、Windows 等用户介面目前并不存在这个特性，所以请继续保持随手加空格的习惯。 标点符号不重复使用标点符号正确： 德国队竟然战胜了巴西队！ 她竟然对你说「喵」？！ 错误： 德国队竟然战胜了巴西队！！ 德国队竟然战胜了巴西队！！！！！！！！ 她竟然对你说「喵」？？！！ 她竟然对你说「喵」？！？！？？！！ 全角和半角不明白什么是全角（全形）与半角（半形）符号？请查看维基百科词条『全形和半形』。 使用全角中文标点正确： 嗨！你知道嘛？今天前台的小妹跟我说「喵」了哎！ 核磁共振成像（NMRI）是什么原理都不知道？JFGI！ 错误： 嗨! 你知道嘛? 今天前台的小妹跟我说 “喵” 了哎！ 嗨!你知道嘛?今天前台的小妹跟我说”喵”了哎！ 核磁共振成像 (NMRI) 是什么原理都不知道? JFGI! 核磁共振成像(NMRI)是什么原理都不知道?JFGI! 数字使用半角字符正确： 这个蛋糕只卖 1000 元。 错误： 这个蛋糕只卖 １０００ 元。 例外：在设计稿、宣传海报中如出现极少量数字的情形时，为方便文字对齐，是可以使用全形数字的。 遇到完整的英文整句、特殊名词，其内容使用半角标点正确： 贾伯斯那句话是怎么说的？「Stay hungry, stay foolish.」 推荐你阅读《Hackers &amp; Painters: Big Ideas from the Computer Age》，非常的有趣。 错误： 贾伯斯那句话是怎么说的？「Stay hungry，stay foolish。」 推荐你阅读《Hackers＆Painters：Big Ideas from the Computer Age》，非常的有趣。 名词专有名词使用正确的大小写大小写相关用法原属于英文书写范畴，不属于本 wiki 讨论内容，在这里只对部分易错用法进行简述。 正确： 使用 GitHub 登录 我们的客户有 GitHub、Foursquare、Microsoft Corporation、Google、Facebook, Inc.。 错误： 使用 github 登录 使用 GITHUB 登录 使用 Github 登录 使用 gitHub 登录 使用 gｲんĤЦ8 登录 我们的客户有 github、foursquare、microsoft corporation、google、facebook, inc.。 我们的客户有 GITHUB、FOURSQUARE、MICROSOFT CORPORATION、GOOGLE、FACEBOOK, INC.。 我们的客户有 Github、FourSquare、MicroSoft Corporation、Google、FaceBook, Inc.。 我们的客户有 gitHub、fourSquare、microSoft Corporation、google、faceBook, Inc.。 我们的客户有 gｲんĤЦ8、ｷouЯƧquﾑгє、๓เςг๏ร๏Ŧt ς๏гק๏гคtเ๏ภn、900913、ƒ4ᄃëв๏๏к, IПᄃ.。 注意：当网页中需要配合整体视觉风格而出现全部大写／小写的情形，HTML 中请使用标淮的大小写规范进行书写；并通过 text-transform: uppercase;／text-transform: lowercase; 对表现形式进行定义。 不要使用不地道的缩写正确： 我们需要一位熟悉 JavaScript、HTML5，至少理解一种框架（如 Backbone.js、AngularJS、React 等）的前端开发者。 错误： 我们需要一位熟悉 Js、h5，至少理解一种框架（如 backbone、angular、RJS 等）的 FED。 争议以下用法略带有个人色彩，即：无论是否遵循下述规则，从语法的角度来讲都是正确的。 链接之间增加空格用法： 请 提交一个 issue 并分配给相关同事。 访问我们网站的最新动态，请 点击这里 进行订阅！ 对比用法： 请提交一个 issue并分配给相关同事。 访问我们网站的最新动态，请点击这里进行订阅！ 简体中文使用直角引号用法： 「老师，『有条不紊』的『紊』是什么意思？」 对比用法： “老师，‘有条不紊’的‘紊’是什么意思？” 工具 仓库 语言 vinta/paranoid-auto-spacing JavaScript huei90/pangu.node Node.js huacnlee/auto-correct Ruby sparanoid/space-lover PHP (WordPress) nauxliu/auto-correct PHP jxlwqq/chinese-typesetting PHP hotoo/pangu.vim Vim sparanoid/grunt-auto-spacing Node.js (Grunt) hjiang/scripts/add-space-between-latin-and-cjk Python hustcc/hint Python studygolang/autocorrect Go 谁在这样做？ 网站 文案 UGC Apple 中国 是 N/A Apple 香港 是 N/A Apple 台湾 是 N/A Microsoft 中国 是 N/A Microsoft 香港 是 N/A Microsoft 台湾 是 N/A LeanCloud 是 N/A V2EX 是 是 Apple4us 是 N/A Ruby China 是 标题达成 PHPHub 是 标题达成 少数派 是 N/A 参考文献 Guidelines for Using Capital Letters - ThoughtCo. Letter case - Wikipedia Punctuation - Oxford Dictionaries Punctuation - The Purdue OWL How to Use English Punctuation Correctly - wikiHow 格式 - openSUSE 全形和半形 - 维基百科 引号 - 维基百科 疑问惊叹号 - 维基百科","link":"/2020/08/18/blog/chinese-copywriting-guidelines/"},{"title":"Happy new year(qq)","text":"流程分析 获取所有好友列表 便利列表获取好友信息 单个好友发送信息 单个好友分析性别，备注，是否是老师，进而生成对应的带昵称（老x,x老板,xx老师）的拜年信息 单个好友发送多次拜年信息 end 安装 酷q 及 CoolQ HTTP API 插件 启用http插件，然后编写php代码批量发送拜年信息 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211 /** * @return |null * @throws \\GuzzleHttp\\Exception\\GuzzleException */ public function handle() { try { $webHook = 'http://127.0.0.1:6701'; $client = new Client([ 'base_uri' =&gt; $webHook, 'timeout' =&gt; 10.0, 'http_errors' =&gt; false, ]); $response = $client-&gt;request('get', '/get_friend_list', [ 'query' =&gt; [ 'access_token' =&gt; 'hzjmytoken', ] ]); $data = json_decode($response-&gt;getBody(), true); $friendList = array_map(function ($item) { return [ 'nickname' =&gt; $item['nickname'] ?? '', 'remark' =&gt; $item['remark'] ?? '', 'user_id' =&gt; $item['user_id'] ?? '' ]; }, $data['data'] ?? []); foreach($friendList as $item){ echo $item['user_id'].PHP_EOL; } $num = 0; foreach ($friendList as $friend) { $nickname = $friend['nickname']; $remark = $friend['remark']; $user_id = $friend['user_id']; $name = str_replace(['信科', '一·', '一中', '软件', '能动', '统计', ' ', '美术', '是长得像RE的RE', '20－', '~继国', '1502', '自动', '～'], '', $remark); if (in_array($user_id, ['563724681', '176104400', '289883273', '1750686113', '1870786623'])) { dump('## 跳过 ：' . $name); continue; } $userInfo = ($this-&gt;getUserInfo($user_id)); $userInfo = json_decode($userInfo, true); $sex = $userInfo['data']['sex'] ?? ''; if (strlen($name) % 3 !== 0) { dump('## 跳过（格式问题） :' . $name); continue; } $result = $this-&gt;senderMessage($user_id, $name, $sex); if ($user_id == '31792690') { echo 1;// $result = $this-&gt;senderMessage($user_id, $name, $sex); } $num += 1; dump(&quot;############## $num ################&quot;); } } catch (\\Exception $e) { dump($e-&gt;getMessage()); } return null; } /** * @param $userId * @param $message * @return string * @throws \\GuzzleHttp\\Exception\\GuzzleException */ public function sender($userId, $message): string { $webHook = 'http://127.0.0.1:6701'; $client = new Client([ 'base_uri' =&gt; $webHook, 'timeout' =&gt; 10.0, 'http_errors' =&gt; false, ]); $query = [ 'access_token' =&gt; 'hzjmytoken', 'message' =&gt; $message, 'user_id' =&gt; $userId, ];// $response = $client-&gt;request('get', '/send_private_msg_rate_limited', [// 'query' =&gt; $query// ]); dump($query); return '##heihei'; } /** * @param $userId * @param $name * @param $sex * @return string * @throws \\GuzzleHttp\\Exception\\GuzzleException */ public function senderMessage($userId, $name, $sex): string { $flag = true; $message = &quot;&quot;; $firstName = str_split($name, 3)[0] ?? $name; $firstName = str_replace('rrr', '闫', $firstName); $newYearName = '老' . $firstName . '同学'; if (strpos($name, '老师') !== false) { $message .= $name . '新年快乐，鼠年吉祥, 🐀你健康，🐀你顺利，🐀你快乐'; } else { switch ($sex) { case 'female': $message .= '祝老' . $firstName . '同学' . '.🐀年健康，🐀年顺利，🐀年快乐，鼠年吉祥'; break; case 'male': $t = mt_rand(0, 2); if ($t == 0) { $message .= '老' . $firstName . '新年快乐ha`，'; } else if ($t == 1) { $message .= $firstName . '老板新年快乐ha`，'; } else { $message .= $firstName . '大大新年快乐ha`，'; } $message .= &quot;祝{$newYearName}，新的一年🐀你快乐，🐀你健康，神清气爽，吃嘛嘛香，财源滚滚&quot;; break; default: $message .= $name . &quot;同学新年快乐，鼠年大吉&quot; . PHP_EOL; $message .= &quot;🐀你快乐，🐀你健康，红包多抢，记得分我&quot;; break; } } dump('## 执行：' . $firstName. '**** | message:' . $message); if ($flag) { $result = $this-&gt;sender($userId, '🐀😁😁😁😁😁😁😁😁😁😁😁😁😁'); dump('## run1'); $result = $this-&gt;sender($userId, $message); dump('## run2'); if (strpos($name, '老师') !== false) { switch ($sex) { case 'female': if (mt_rand(0, 1)) { $result = $this-&gt;sender($userId, '🍬🍬🍬'); } else { $result = $this-&gt;sender($userId, '🍭🍭🍭🍭🍭🍭'); } break; default: $result = $this-&gt;sender($userId, '🐀🤞🐀'); break; } } else { $result = $this-&gt;sender($userId, '🐀🤞🐀'); } dump('## run3'); } else { $result = '未发送'; dump('## 未发送'); } return $result; } /** * @param $userId * @return string * @throws \\GuzzleHttp\\Exception\\GuzzleException */ public function getUserInfo($userId): string { $webHook = 'http://127.0.0.1:6701'; $client = new Client([ 'base_uri' =&gt; $webHook, 'timeout' =&gt; 10.0, 'http_errors' =&gt; false, ]); $response = $client-&gt;request('get', '/get_stranger_info', [// 'from_params' =&gt; [// 'bookOrderId' =&gt; 'qwe',// 'remark' =&gt; '',// ],// 'headers' =&gt; [// 'Content-type' =&gt; 'application/json',// ], 'query' =&gt; [ 'access_token' =&gt; 'hzjmytoken', 'user_id' =&gt; $userId, 'no_cache' =&gt; false, ] ]); return $response-&gt;getBody(); } 流程分析 获取所有好友列表 便利列表获取好友信息 单个好友发送信息 单个好友分析性别，备注，是否是老师，进而生成对应的带昵称（老x,x老板,xx老师）的拜年信息 单个好友发送多次拜年信息 end","link":"/2020/01/25/blog/qq%E6%8B%9C%E6%8B%9C%E5%B9%B4/"},{"title":"此","text":"","link":"/2020/12/31/blog/%E6%AD%A4%E9%97%B4%E4%B9%90%E4%B8%8D%E6%80%9D%E8%9C%80/"},{"title":"408_2014_图(c++全代码)","text":"本篇文章针对节点的c++实现版本，针对本题的第二问链使结构的设计，提供一份数据结构以及一份可执行的g++文件，仅供参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;cstring&gt;#include &lt;stdlib.h&gt;#define random(x) (rand() % x)using namespace std;class LinkNode{public: int ID, IP; int Metric; LinkNode *next; LinkNode(int ID = 0, int IP = 0, int metric = 0) { this-&gt;next = NULL; this-&gt;ID = ID; this-&gt;IP = IP; this-&gt;Metric = metric; }};class NetNode{public: int IP; int Metric; NetNode(int IP = 0, int metric = 0) { this-&gt;IP = IP; this-&gt;Metric = metric; }};class RouterHeaderNode{public: LinkNode *linkNext; NetNode *netNext; int IP; RouterHeaderNode *headerNext; RouterHeaderNode(int IP = 0) { this-&gt;IP = IP; this-&gt;linkNext = NULL; this-&gt;netNext = NULL; this-&gt;headerNext = NULL; }};int main(int argc, char **argv){ std::ios::sync_with_stdio(false); class RouterHeaderNode *routerHeaderNode, *headerRouter; class LinkNode *linkNode, *tmpLinkNode; class NetNode *netNode, *tmpNetNode; tmpLinkNode = linkNode = NULL; routerHeaderNode = headerRouter = NULL; for (int routerI = 0; routerI &lt; 5; routerI++) { tmpLinkNode = linkNode = NULL; cout &lt;&lt; &quot;开始构建&quot; &lt;&lt; endl; if (routerHeaderNode == NULL) { headerRouter = routerHeaderNode = new RouterHeaderNode(random(199)); } else { routerHeaderNode-&gt;headerNext = new RouterHeaderNode(random(199)); routerHeaderNode = routerHeaderNode-&gt;headerNext; } int linkLength = 3; linkNode = tmpLinkNode = NULL; for (int i = 0; i &lt; linkLength; i++) { if (tmpLinkNode == NULL) { linkNode = tmpLinkNode = new LinkNode(random(100), random(100), random(100)); } else { tmpLinkNode-&gt;next = new LinkNode(random(100), random(100), random(100)); tmpLinkNode = tmpLinkNode-&gt;next; } cout &lt;&lt; &quot;插入一个link node 成功&quot; &lt;&lt; endl; } routerHeaderNode-&gt;linkNext = linkNode; netNode = new NetNode(random(100)); routerHeaderNode-&gt;netNext = netNode; cout &lt;&lt; &quot;掺入 netNode 成功&quot; &lt;&lt; endl; } routerHeaderNode = headerRouter; while (routerHeaderNode != NULL) { linkNode = routerHeaderNode-&gt;linkNext; cout &lt;&lt; &quot;routerIP:&quot; &lt;&lt; routerHeaderNode-&gt;IP &lt;&lt; endl &lt;&lt; &quot;|-&gt;&quot;; while (linkNode != NULL) { cout &lt;&lt; &quot;{id:&quot; &lt;&lt; linkNode-&gt;ID &lt;&lt; &quot;,ip:&quot; &lt;&lt; linkNode-&gt;IP &lt;&lt; &quot;,metric:&quot; &lt;&lt; linkNode-&gt;Metric &lt;&lt; &quot;}&quot;; linkNode = linkNode-&gt;next; if (linkNode != NULL) { cout &lt;&lt; &quot;-&gt;&quot;; } } netNode = routerHeaderNode-&gt;netNext; cout &lt;&lt; &quot;{metric:&quot; &lt;&lt; netNode-&gt;Metric &lt;&lt; &quot;}&quot; &lt;&lt; endl; routerHeaderNode = routerHeaderNode-&gt;headerNext; } cout &lt;&lt; &quot;end&quot; &lt;&lt; endl;} 运行结果的部分结果截取 1234567891011routerIP:41|-&gt;{id:67,ip:34,metric:0}-&gt;{id:69,ip:24,metric:78}-&gt;{id:58,ip:62,metric:64}{metric:0}routerIP:86|-&gt;{id:81,ip:27,metric:61}-&gt;{id:91,ip:95,metric:42}-&gt;{id:27,ip:36,metric:91}{metric:0}routerIP:121|-&gt;{id:53,ip:92,metric:82}-&gt;{id:21,ip:16,metric:18}-&gt;{id:95,ip:47,metric:26}{metric:0}routerIP:195|-&gt;{id:69,ip:12,metric:67}-&gt;{id:99,ip:35,metric:94}-&gt;{id:3,ip:11,metric:22}{metric:0}routerIP:161|-&gt;{id:64,ip:41,metric:11}-&gt;{id:53,ip:68,metric:47}-&gt;{id:44,ip:62,metric:57}{metric:0}end","link":"/2020/08/22/coding/408_2014_%E5%9B%BE/"},{"title":"c&#x2F;c++[001]:start","text":"cin cout scanf printfscanf()是C语言中的一个输入函数。与printf函数一样，都被声明在头文件stdio.h里，因此在使用 scanf 函数时要加上#include &lt;stdio.h&gt;。（在有一些实现中，printf函数与scanf函数在使用时可以不使用预编译命令#include &lt;stdio.h&gt;。）它是格式输入函数，即按用户指定的格式从键盘上把数据输入到指定的变量之中。 规定符 备注 %d 十进制有符号整数 %u 十进制无符号整数 %f 浮点数 %s 字符串 %c 单个字符 %p 指针的值 %e 指数形式的浮点数 %x, %X 无符号以十六进制表示的整数 %o 无符号以八进制表示的整数 %g 把输出的值按照%e或者%f类型中输出长度较小的方式输出 %p 输出地址符 %lu 32位无符号整数 %llu 64位无符号整数","link":"/2017/05/25/coding/C_001_start/"},{"title":"408_cpp_classNode","text":"利用class析构函数简化内存回收方式123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;using namespace std;#define random(x) (rand() % x)class NewNode{public: NewNode *next = NULL; int data = 0; NewNode(int data = 0) { this-&gt;data = data; } ~NewNode() { cout &lt;&lt; &quot;正在释放data为&quot; &lt;&lt; data &lt;&lt; &quot;的数据&quot; &lt;&lt; endl; delete (next); cout &lt;&lt; &quot;释放完成data为&quot; &lt;&lt; data &lt;&lt; &quot;的数据&quot; &lt;&lt; endl; }};int main(){ NewNode *head, *node; head = node = new NewNode(); for (int i = 1; i &lt; 10; i++) { node-&gt;next = new NewNode(i); node = node-&gt;next; } node = head-&gt;next; while (node != NULL) { cout &lt;&lt; node-&gt;data &lt;&lt; &quot;\\t&quot;; node = node-&gt;next; } cout&lt;&lt;endl; delete(head);}","link":"/2020/08/22/coding/408_cpp_classNode/"},{"title":"c&#x2F;c++:单向链表顺序输出","text":"数据结构实验之链表一：顺序建立链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct node{ int data; struct node *next;};int main (){ std::ios::sync_with_stdio(false); struct node *head, *tail, *p; head = new node; head-&gt;next = NULL; tail = head; int N ; int tmpN; cin&gt;&gt;N; { tmpN = N; while(tmpN--) { p = new node; p-&gt;next = NULL; cin &gt;&gt; p-&gt;data ; tail-&gt;next = p; tail = p; } p = head-&gt;next; while(p-&gt;next!=NULL) { cout&lt;&lt;p-&gt;data&lt;&lt;' '; p=p-&gt;next; } cout&lt;&lt;p-&gt;data&lt;&lt;' '; cout&lt;&lt;endl; } return 0;}","link":"/2017/06/02/coding/C_003_%E9%93%BE%E8%A1%A8/"},{"title":"c&#x2F;c++[002]:01背包","text":"(背包问题?)[https://acm.sdut.edu.cn/onlinejudge2/index.php/Home/Index/problemdetail/pid/3092.html] 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main(){ //std::ios::sync_with_stdio(false); int n; int sum ; int w[2][20000]; int sV[20000]; int i = 0; while (cin &gt;&gt; n &gt;&gt; sum) { i = 1; while(i &lt;= n) { cin&gt;&gt;w[0][i] &gt;&gt; w[1][i]; i++; } memset(sV,0,sizeof(sV)); for(int j = 0; j&lt;= n ; j++) { for( int jj = sum ; jj &gt;= w[0][j]; jj -- ) { sV[jj] = max( sV[jj], sV[jj-w[0][j]]+w[1][j] ); }// for(int z = 0; z&lt;=sum ;z++){ // cout&lt;&lt;sV[z]&lt;&lt;&quot;\\t&quot;; // } // cout&lt;&lt;endl; } cout&lt;&lt; sV[sum]&lt;&lt;endl; } return 0 ;}","link":"/2017/06/02/coding/C_002_01%E8%83%8C%E5%8C%85/"},{"title":"c&#x2F;c++:逆序建立链表","text":"数据结构实验之链表二：逆序建立链表 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct node{ int data; struct node *next;};int main (){ std::ios::sync_with_stdio(false); struct node *head, *tail, *p; head = new node; head-&gt;next = NULL; tail = head; int N ; int tmpN; cin&gt;&gt;N; { tmpN = N; while(tmpN--) { p = new node; cin &gt;&gt; p-&gt;data ; p-&gt;next = head-&gt;next; head-&gt;next = p; } p = head-&gt;next; while(p-&gt;next!=NULL) { cout&lt;&lt;p-&gt;data&lt;&lt;' '; p=p-&gt;next; } cout&lt;&lt;p-&gt;data&lt;&lt;' '; cout&lt;&lt;endl; } return 0;}","link":"/2017/06/02/coding/C_004_%E9%93%BE%E8%A1%A8/"},{"title":"c&#x2F;c++:逆序建立链表","text":"数据结构实验之链表三：链表的逆置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct node{ int data; struct node *next;};int main (){ std::ios::sync_with_stdio(false); struct node *head, *tail, *p, *tmpNode; head = new node; head-&gt;next = NULL; tail = head; int num; while(1) { p = new node; p-&gt;next = NULL; cin &gt;&gt; num ; if(num == -1) { break; } p-&gt;data = num; tail-&gt;next = p; tail = p; } p = head-&gt;next; head-&gt;next = NULL; while(p-&gt;next != NULL) { tmpNode = p-&gt;next; p-&gt;next = head-&gt;next; head-&gt;next = p; p = tmpNode; } p-&gt;next = head-&gt;next; head-&gt;next = p; p = head-&gt;next; while(p-&gt;next != NULL) { cout&lt;&lt;p-&gt;data&lt;&lt;&quot; &quot;; p=p-&gt;next; } cout&lt;&lt;p-&gt;data&lt;&lt;endl;; return 0;}","link":"/2017/06/02/coding/C_005_%E9%93%BE%E8%A1%A8/"},{"title":"c&#x2F;c++:有序链表的归并","text":"数据结构实验之链表四：有序链表的归并 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct node{ int data; struct node *next;};int main (){ std::ios::sync_with_stdio(false); int length1,length2; struct node *head1,*head2,*tail1,*tail2,*p1,*p2,*tmp; head1 = new node; tail1 = head1; head1-&gt;next = NULL; head2 = new node ; tail2 = head2; head2-&gt;next = NULL; cin &gt;&gt;length1&gt;&gt;length2; while(length1 -- ) { p1 = new node ; cin&gt;&gt;p1-&gt;data; tail1-&gt;next = p1; tail1 = p1; } p1-&gt;next = NULL; while(length2 -- ) { p2 = new node ; cin&gt;&gt;p2-&gt;data; tail2-&gt;next = p2; tail2 = p2; } p2-&gt;next = NULL; p1 = head1; p2 = head2; struct node *head,*tail; head = new node; head-&gt;next = NULL; tail = head; p1 = head1-&gt;next; p2 = head2-&gt;next; while(p1&amp;&amp;p2){ if(p1-&gt;data &lt; p2-&gt;data){ tail-&gt;next = p1; p1 = p1-&gt;next; } else { tail-&gt;next = p2; p2 = p2-&gt;next; } tail = tail-&gt;next; } if(p1){ tail-&gt;next = p1; } else { tail-&gt;next = p2; } delete(head2); delete(head1); p1 = head-&gt;next; while(p1-&gt;next!=NULL){ cout&lt;&lt;p1-&gt;data&lt;&lt;' '; p1 = p1-&gt;next; } cout &lt;&lt; p1-&gt;data&lt;&lt;endl; return 0;}","link":"/2017/06/02/coding/C_006_%E9%93%BE%E8%A1%A8/"},{"title":"c&#x2F;c++:单链表的拆分","text":"数据结构实验之链表五：单链表的拆分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;struct node{ int data; struct node *next;};int main (){ std::ios::sync_with_stdio(false); struct node *head , *tail,*p; head =new node; head-&gt;next = NULL; tail = head; int num; int sum1,sum2; cin&gt;&gt;num; while(num--) { p = new node ; cin&gt;&gt;p-&gt;data; tail-&gt;next = p; tail = tail-&gt;next; } p-&gt;next = NULL; struct node *head1 , *head2 ,*tail1,*tail2; head1 = new node; head1-&gt;next = NULL; tail1 = head1; head2 = new node; head2-&gt;next = NULL; tail2 =head2; p = head-&gt;next; sum1 = 0; sum2 = 0; while(p!=NULL){ if(p-&gt;data%2 ==1){ tail1-&gt;next = p; tail1 = tail1-&gt;next; sum1 +=1; } else { tail2-&gt;next = p; tail2 = tail2-&gt;next; sum2 +=1; } p = p-&gt;next; } tail1-&gt;next = NULL; tail2-&gt;next = NULL; cout &lt;&lt; sum2 &lt;&lt; ' '&lt;&lt;sum1&lt;&lt;endl; p = head2-&gt;next; while(p!=NULL){ cout&lt;&lt;p-&gt;data; if(p-&gt;next!=NULL){ cout&lt;&lt; ' '; } p = p-&gt;next; } cout&lt;&lt;endl; p = head1-&gt;next; while(p!=NULL){ cout&lt;&lt;p-&gt;data; if(p-&gt;next!=NULL){ cout&lt;&lt; ' '; } p = p-&gt;next; } cout&lt;&lt;endl; return 0;}","link":"/2017/06/02/coding/C_007_%E9%93%BE%E8%A1%A8/"},{"title":"c&#x2F;c++[00X]:KMP","text":"kmp 的 next 串分析 a b a a b c a c 0 1 1 2 2 3 1 2 a b a a b c a c ‘’ ‘a’ ‘ab’ ‘aba’ ‘abaa’ ‘abaab’ ‘abaabc’ ‘abaabca’ ‘’ ‘ax’ ‘abx’ ‘abax’ ‘abaax’ ‘abaabx’ ‘abaabax’ ‘abaabcx’ ‘’ ‘x’ ‘x’ ‘ax’ ‘ax’ ‘abx’ ‘x’ ‘ax’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;?php/** * 教材 数据结构 c 语言伪代码 * void get_next(SString T,int next[]) * { * i = 1; next[1] = 0; j = 0; * while(i&lt;T[0]){ * if(j==0 || T[i] == T[j]) * { * ++i; * ++j; * next[i]=j; * } * else * { * j = next[j] * } * } * } * *//** * 下述代码为正确的可执行php代码，与上述伪代码不一样的是，$str 的字符串下标是从0 开始，所以将$i,$j的匹配位置迁移1位， * 因为next也是从0开始存储所以循环应在 $i&lt;$lenght-1开始 * （next[0]作为起点未在循环内赋值，循环内赋值皆为$i+1的下表，故可以做到将next[0]~next[$lenght-1]全部赋值成功 ,） */function getNext_success($str){ $next = []; $lenght = strlen($str); $next[0] = -1; $i = 0; $j = -1; while ($i &lt; $lenght-1) { if ($j === -1 || $str[$i] === $str[$j]) { $i += 1; $j += 1; $next[$i] = $j; } else { $j = $next[$j]; } } foreach ($next as $num) { echo $num . &quot;\\t&quot;; } echo &quot;\\n&quot;;}/** * 教材的字符串下表 1 开始 0 下标代表着该字符串长度（这好像不是c吧(lll￢ω￢)） * 所以第一个函数的错误发生于j=0 , 因为j=0下表在下述代码中是字符串的首位所以如果用j=0作为j的初始值则会导致少匹配一位， * 导致实际使用的字串为s[1]~s[n] */function getNext_error($str){ $next = []; $lenght = strlen($str); $next[1] = 0; $i = 1; $j = 0; while ($i &lt; $lenght) { if ($j === 0 || $str[$i] === $str[$j]) { $j += 1; $i += 1; $next[$i] = $j; } else { $j = $next[$j]; } } foreach ($next as $num) { echo $num . &quot;\\t&quot;; } echo &quot;\\n&quot;;}/** * 这是第二个错误，他的输出的next 为 0 1 2 3 4 5 6 7 * 虽然起点为$i=0; $j =-1;但是由于第一次匹配未能成功导致将$j=0,致使$i=0,$j=0开始匹配， * 而kmp中next每次循环所求是前缀， */function getNext_error2($str){ $next = []; $lenght = strlen($str); $next[0] = 0; $i = 0; $j = -1; while ($i &lt; $lenght-1) { if ($j === 0 || $str[$i] === $str[$j]) { $i += 1; $j += 1; $next[$i] = $j; } else { $j = $next[$j]; } } foreach ($next as $num) { echo $num . &quot;\\t&quot;; } echo &quot;\\n&quot;;}$str4kmp = 'abaabcac';$str4kmp ='11111111';getNext_error($str4kmp);getNext_error2($str4kmp);getNext_success($str4kmp); c语言版本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;iostream&gt;#include &lt;string.h&gt;#include &lt;stdio.h&gt;using namespace std;int next_ac[1000005];char s1[1000005];char s2[1000005];void getNext(char *s){ memset(next_ac,-1,sizeof(next_ac)); int sl = strlen(s); int i = 0; int j = -1; /** sl-1 这里循环次数 */ while(i&lt;sl-1) { if(j== -1 || s[i] == s[j]) { i+=1; j+=1; next_ac[i] = j; } else { j = next_ac[j]; } }}int kmp(char *s1,char *s2){ int sl1 = strlen(s1); int sl2 = strlen(s2); getNext(s2); int i=0,j=0; while(i&lt;sl1 &amp;&amp; j&lt;sl2) { if(j==-1||s1[i]==s2[j]) { j++; i++; } else { j = next_ac[j]; } } if(j==sl2) { return i-j+1; } else { return -1; }}int main(){ std::ios::sync_with_stdio(false); int z = -1; while(cin&gt;&gt;s1) { cin&gt;&gt;s2; z= kmp(s1,s2); cout&lt;&lt;z&lt;&lt;endl; } return 0;}/***************************************************User name: loop0875Result: AcceptedTake time: 72msTake Memory: 1408KBSubmit time: 2019-07-02 14:31:44****************************************************/ 过程中，有一趟代码我给把 = 写成了 == 导致next全变成了 -1，但是对于测试数据缺没问题，提交wa，其实如果next都为-1的情况下，kmp的部分在某些情况下可以正常运行，只要本身不存在回溯可以成功的情况，是可以运行的，因为next全是-1，这就导致一旦出错就会把字串从头开始匹配，但是被匹配串缺还保持当前位置导致的当然问题导致的原因还是因为粗心导致的 12345678910111213141516171819202122232425262728void getNext(char *s){ memset(next_ac,-1,sizeof(next_ac)); int sl = strlen(s); int i = 0; int j = -1; /** sl-1 这里循环次数 */ while(i&lt;sl-1) { if(j== -1 || s[i] == s[j]) { i+=1; j+=1; /**************这里是出错的地点********************/ next_ac[i] == j; /**********************************/ } else { j = next_ac[j]; } }}","link":"/2019/07/02/coding/C_KMP/"},{"title":"TS&#39;s enum","text":"1enum Color {Red, Green, Blue} 123456var Color;(function (Color) { Color[Color[&quot;Red&quot;] = 0] = &quot;Red&quot;; Color[Color[&quot;Green&quot;] = 1] = &quot;Green&quot;; Color[Color[&quot;Blue&quot;] = 2] = &quot;Blue&quot;;})(Color || (Color = {})); 12345678910111213141516// 声明var color;// 闭包实现enum的赋值var setColorEnum = function (Color) { Color[Color[&quot;Red&quot;] = 0] = &quot;Red&quot;; Color[Color[&quot;Green&quot;] = 1] = &quot;Green&quot;; Color[Color[&quot;Blue&quot;] = 2] = &quot;Blue&quot;;}// 调用闭包赋值 这里是分了两部，第一步判断Color是否存在，如果不存在将color声明为一个对象，对象的数值操作相当于引用操作，直接会改变原值，if(Color || (Color = {})){ Color[&quot;Red&quot;] = 0; Color[Color[&quot;Red&quot;]] = &quot;Red&quot;;} 由于php中直接声明的变量obj是obj，array是array。所以需要先创建一个enum类实现array接口这样就可以实现与上述代码相同的赋值行为。代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass enum implements ArrayAccess{ private $container = array(); public function offsetSet($offset, $value) { if (is_null($offset)) { $this-&gt;container[] = $value; } else { $this-&gt;container[$offset] = $value; } } public function offsetExists($offset) { return isset($this-&gt;container[$offset]); } public function offsetUnset($offset) { unset($this-&gt;container[$offset]); } public function offsetGet($offset) { return isset($this-&gt;container[$offset]) ? $this-&gt;container[$offset] : null; }}$Color;(function ($Color) { $Color[$Color-&gt;Red = 0] = &quot;Red&quot;; $Color[$Color-&gt;Green = 1] = &quot;Green&quot;; $Color[$Color-&gt;Blue = 2] = &quot;Blue&quot;;})(($Color = new enum()));var_dump($Color);var_dump($Color-&gt;Red);var_dump($Color-&gt;Green);var_dump($Color-&gt;Blue);var_dump($Color[0]);var_dump($Color[1]);var_dump($Color[2]); 终端输出 1234567891011121314151617181920212223object(enum)#2 (4) { [&quot;container&quot;:&quot;enum&quot;:private]=&gt; array(3) { [0]=&gt; string(3) &quot;Red&quot; [1]=&gt; string(5) &quot;Green&quot; [2]=&gt; string(4) &quot;Blue&quot; } [&quot;Red&quot;]=&gt; int(0) [&quot;Green&quot;]=&gt; int(1) [&quot;Blue&quot;]=&gt; int(2)}int(0)int(1)int(2)string(3) &quot;Red&quot;string(5) &quot;Green&quot;string(4) &quot;Blue&quot;","link":"/2020/01/28/coding/ts_enum/"},{"title":"UWP[002]:开发目的+起步","text":"开发原因由于暴风gg了，win10 win store里面也没有觉得很好的播放器，而各大互联网厂商的播放器主要目的不是播放本地文件，win10自带的播放器又过分简陋，所以打算开发一个基于uwp的播放器，选择这个的原因呢通过有以下几点 q:为什么不选择可跨平台的一些开发方案?a:跨平台成本高，并且主要用win本子，跨平台的一些虽然看着美好，实际上个人开发只会关注一个平台q:为什么选择开发uwp？a:因为uwp可以发布在商店，相比于传统的exe更安全，分发途径比较好，小众软件商店下载比较好一点q:有啥不好的地方吗？a:微软开发者账号注册不能用微信支付宝银行卡，，，有点费劲啊，这整的 目的：开发一个简洁的播放器，方便调节倍速就好 起步开发环境使用的是vs2019，安装uwp开发相关的选项， 本文比较糙，如作参考，切勿钻牛角尖音响效率 simpleM’s GitHub uwp 里其实和 web网页开发类似， xaml、cs文件与html、css、js等算是也有对应关系，同时uwp中grid的布局方式我使用起来比较顺手，所以起步还是比较方便的 使用grid，并在左上添加一段文字简单布局,在MainPage.xaml中添加一个2*2的布局,并在左上的格子添加一段文字 1234567891011121314&lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;7*&quot;/&gt; &lt;ColumnDefinition Width=&quot;3*&quot;/&gt;&lt;/Grid.ColumnDefinitions&gt;&lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;auto&quot;/&gt; &lt;RowDefinition Height=&quot;9.5*&quot;/&gt;&lt;/Grid.RowDefinitions&gt;&lt;Grid Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot;&gt;&lt;TextBlock Text=&quot;提示&quot; FontSize=&quot;20&quot; FontWeight=&quot;Medium&quot; /&gt;&lt;/Gird&gt; 使用listView绑定数据渲染123456789&lt;Grid Grid.Row=&quot;0&quot;&gt; &lt;ListView Name=&quot;MItems&quot; ItemsSource=&quot;{x:Bind VideoFileInfoList}&quot; ItemClick=&quot;MItems_ItemClick&quot; IsItemClickEnabled=&quot;True&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;TextBlock Text=&quot;{Binding FilePath}&quot;/&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt;&lt;/Grid&gt; 1234567public sealed partial class MainPage : Page{ public ObservableCollection&lt;VideoFileInfoData&gt; VideoFileInfoList = new ObservableCollection&lt;VideoFileInfoData&gt;(); /* ... */}","link":"/2020/01/09/coding/uwp002/"},{"title":"UWP[003]:视频组件和创建自定义传输控件","text":"本文比较糙，如作参考，切勿钻牛角尖音响效率 simpleM’sGitHub uwp 视频播放器元素类 MediaPlayerElement 简单引入并播放 1&lt;MediaPlayerElement Source=&quot;ms-appx:///Media/video1.mp4&quot; AutoPlay=&quot;True&quot; /&gt; 创建自定义传输控件 从windows (Program Files)\\Windows Kits\\10\\DesignTime\\CommonConfiguration\\Neutral\\UAP(SDK version)\\Generic 中的xaml复制需要的空间默认样式至项目中的Themes\\generic.xaml ,如没有自行创建 更改 123&lt;Style TargetType=&quot;local:自定义控件名称名字&quot;&gt;&lt;ControlTemplate TargetType=&quot;local:自定义控件名称名字&quot;&gt; 创建新类自定义控件名称名字.cs并在构造函数中引用自定义的配置 123456789public sealed class SuperSimpleMediaTransportControls : MediaTransportControls{ public SuperSimpleMediaTransportControls() { // 我定义的空间名称为SuperSimpleMediaTransportControls this.DefaultStyleKey = typeof(SuperSimpleMediaTransportControls); }","link":"/2020/01/19/coding/uwp003/"},{"title":"jsx","text":"首先看一段原生php代码（不了解php没关系，下面就是一个原生html内嵌了一段php代码，在服务端，php的解释器会将php代码转换成html） 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;?phpforeach(['a','b','c'] as $content){ echo &quot; &lt;div&gt; {$content} &lt;/div&gt; &quot;;}?&gt;&lt;/body&gt;&lt;/html&gt; 客户端接收源码 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; a &lt;/div&gt; &lt;div&gt; b &lt;/div&gt; &lt;div&gt; c &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 虽然现如今的php项目很少有这种代码了，但是过去，还有现在的一些单页面用php写的工具仍然有这种写法，一段html文本中内嵌了php代码，php或php-fpm将其中的&lt;?php xxx ?&gt;解析运行然后返回客户端。 接下来我们在看一下react的public/index.html和src/index.js 1&lt;div id=&quot;root&quot;&gt;&lt;/div&gt; 1234567const name = 'Josh Perez';const element = &lt;h1&gt;Hello, {name}&lt;/h1&gt;;ReactDOM.render( element, document.getElementById('root')); 其中 1&lt;h1&gt;Hello, {name}&lt;/h1&gt; 这一段就是js和html的混合体，从是现实上感觉更像模板引擎，从使用上更像是html的增强，或者js的增强，就好比内嵌&lt;?php xxx ?&gt;既像html的增强，也像php增强。编码上更加的方便直观。 jsx 确实挺不错。 代码合久必分分久必合?","link":"/2020/02/05/coding/web_jsx/"},{"title":"UWP[004]事件和sqlite的引用","text":"本文比较糙，如作参考，切勿钻牛角尖音响效率 simpleM’s GitHub 123456789101112131415161718192021&lt;Grid Grid.Row=&quot;1&quot; &gt; &lt;Grid&gt; &lt;MediaPlayerElement Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; Name=&quot;mediaPlayer&quot; AutoPlay=&quot;True&quot; Visibility=&quot;Visible&quot; AreTransportControlsEnabled=&quot;True&quot;&gt; &lt;MediaPlayerElement.TransportControls&gt; &lt;local:SuperSimpleMediaTransportControls IsCompact=&quot;True&quot; IsZoomButtonVisible=&quot;True&quot; IsZoomEnabled=&quot;True&quot; IsPlaybackRateButtonVisible=&quot;True&quot; IsPlaybackRateEnabled=&quot;True&quot; AddPlaybackRated=&quot;SuperSimpleMediaTransportControls_AddPlaybackRated&quot; InitPlaybackRated=&quot;SuperSimpleMediaTransportControls_InitPlaybackRated&quot; ReducePlaybackRated=&quot;SuperSimpleMediaTransportControls_ReducePlaybackRated&quot; &gt; &lt;/local:SuperSimpleMediaTransportControls&gt; &lt;/MediaPlayerElement.TransportControls&gt; &lt;/MediaPlayerElement&gt; &lt;/Grid&gt;&lt;/Grid&gt; 123456private void SuperSimpleMediaTransportControls_ReducePlaybackRated(object sender, EventArgs e){ mediaPlayer.MediaPlayer.PlaybackSession.PlaybackRate -= 0.1; UpShowText(&quot;当前播放速度为：&quot; + mediaPlayer.MediaPlayer.PlaybackSession.PlaybackRate);} 在 UWP 应用中使用 SQLite 数据库 官方数据库示例貌似有缺陷，在我的版本不能正常运行，最下方也有人提出相同问题，并且官方数据库的使用范例为先写一个lib，然后引入lib，目前所写的播放器并用不到这种分离，就在simpleM项目中直接进行sqlite的引用","link":"/2020/01/19/coding/uwp004/"},{"title":"react-router&#x2F;react-router-dom二级目录写法","text":"注意第一种方法是react-route,二三种方法是react-router-dom，但是第二种方法个人不推荐目前博客的jsx语法显示有些缺陷 三种写法，第一种根据react-router但是我没有写成功 1234567891011&lt;Router&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;IndexRoute component={Dashboard} /&gt; &lt;Route path=&quot;about&quot; component={About} /&gt; &lt;Route path=&quot;inbox&quot; component={Inbox}&gt; &lt;Route path=&quot;/messages/:id&quot; component={Message} /&gt; {/* 跳转 /inbox/messages/:id 到 /messages/:id */} &lt;Redirect from=&quot;messages/:id&quot; to=&quot;/messages/:id&quot; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt; 第二种，b站教学视频，可以运行正确，但是失去层级意义，代码有冗余信息个人认为这是一种错误写法，为了要起到二级目录的效果，所有的path都要写成二级目录的形式才能生效，导致该写法Switch中直接在Children编写相同，所以不要用这种写法 1234567891011121314151617181920&lt;Router&gt; &lt;Switch&gt; {/* 下面的Route组件的path没有生效 */} &lt;Route path=&quot;/admin&quot; render={ () =&gt; { return ( &lt;Switch&gt; &lt;Route path=&quot;/admin/&quot; component={Admin} exact /&gt; &lt;Route path=&quot;/admin/article&quot; component={Article} /&gt; {/* 下面的不能正确匹配 */} &lt;Route path=&quot;/articleEdit&quot; component={ArticleEdit} /&gt; &lt;Route path=&quot;/dashboard&quot; component={Dashboard} /&gt; &lt;Route path=&quot;/setting&quot; component={Setting} /&gt; &lt;/Switch&gt; ) } } /&gt; &lt;/Switch&gt;&lt;/Router&gt; 第三种，嵌套一目了然，同react-router但是可运行,有层级结构，代码简洁。推荐 12345678910111213141516171819&lt;Router&gt; &lt;Switch&gt; {/* to do 结构待优化 */} &lt;Route component={Home} path='/home' exact /&gt; &lt;Router basename=&quot;/admin&quot;&gt; &lt;Switch&gt; &lt;Route path=&quot;/&quot; component={Admin} exact /&gt; &lt;Route path=&quot;/article&quot; component={Article} /&gt; {/* 下面的不能正确匹配 */} &lt;Route path=&quot;/articleEdit&quot; component={ArticleEdit} /&gt; &lt;Route path=&quot;/dashboard&quot; component={Dashboard} /&gt; &lt;Route path=&quot;/setting&quot; component={Setting} /&gt; &lt;/Switch&gt; &lt;/Router&gt; &lt;/Switch&gt;&lt;/Router&gt;","link":"/2020/02/14/coding/web_react-route_react-route-dom/"},{"title":"React[001]:初体验","text":"小样儿挺别致呀，写起来的感觉安装nodejs,npm,npx vscode 插件 1ES7 React/Redux/GraphQL/React-Native snippets 如果网差，可能安装失败 123456npx create-react-app simple-react-webcd simple-react-webmv src src-bakmkdir srccd srctouch index.js 123npm i classnames -Snpm i styled-components -Snpm install -S prop-types index.js 123456789101112131415161718192021222324252627282930313233import React from 'react'import ReactDOM from 'react-dom'// const createApp = (props) =&gt; {// return (// &lt;div&gt;// {/*sadasdasd */}// &lt;h1&gt;Welcome {props.title}&lt;/h1&gt;// &lt;/div&gt;// )// }// const app = createApp({// title: 'my react'// })const App = (props) =&gt; { return ( &lt;div&gt; {/*sadasdasd */} &lt;h1&gt;Welcome {props.title}&lt;/h1&gt; &lt;p&gt; 写起来很别致呀{props.title}&lt;/p&gt; &lt;p title={props.title}&gt;&lt;/p&gt; &lt;/div&gt; )}ReactDOM.render( &lt;App title='1901' /&gt; , document.querySelector('#root')) 挺别致","link":"/2020/01/28/coding/web_react001%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"React[002]:jsx","text":"js/jsx/js=&gt;jsx src/index.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React, { Component} from &quot;react&quot;;import { render } from 'react-dom';// 表示一个虚拟DOM树的方式// const app = {// tag: 'div',// attrs: {// className: 'app',// id: 'appRoot'// },// Children: [// {// tag: 'h1',// attrs: {// className:'title'// },// Children:[// 'js原理'// ]// },// {// tag:'p',// attrs:null,// Children:[// '类组件时继承React.Comopnent的'// ]// }// ]// };// 使用类的形式创建的组件// class App extends Component {// render() {// console.log(this.props)// return (// &lt;div className=&quot;app&quot; id=&quot;appRoot&quot;&gt;// &lt;h1 className=&quot;title&quot;&gt;!!!&lt;/h1&gt;// &lt;p&gt;{this.props.desc}&lt;/p&gt;// &lt;/div&gt;// )// }// }// const app = new App({// desc: '类组件时继承React.Comopnent的'// }).render()// 所以react在真正渲染的时候会把z真正的react代码生成js代码class App extends Component { render(){ // React.createElement 用于创建元素 return React.createElement( 'div', { className:'app', id:'appRoot' }, React.createElement( 'h1', { className:'title' }, 'jsx原理' ), React.createElement( 'p', null, '类组件时继承React.Comopnent的' ) ); }}render( &lt;App desc=&quot;类组件时继承React.Comopnent的&quot; /&gt;, document.querySelector('#root'))","link":"/2020/01/29/coding/web_react002/"},{"title":"React[003]样式","text":"123npm i classnames -Snpm i styled-components -Snpm install -S prop-types src/index.js 123456789101112131415161718192021222324252627282930313233import React, { Component } from 'react';import { render } from 'react-dom'import classNames from 'classnames';import styled from 'styled-components'import './index.css'const Title = styled.h1` color:#f00`class App extends Component { render() { const style = { color: '#f00' } return ( &lt;div&gt; &lt;Title&gt;元素中的样式&lt;/Title&gt; &lt;h1 &gt; 元素中的样式 &lt;/h1&gt; &lt;ol&gt; &lt;li style={style}&gt;使用style内敛创建&lt;/ li&gt; &lt;li className='has-text-red'&gt;使用style内敛创建&lt;/ li&gt; &lt;li className={classNames('a', { 'b': true, 'c': false })}&gt; 要动态添加不同的className，就可以使用第三方的包,比如这个li标签只用a,b没有c &lt;/li&gt; &lt;/ol&gt; &lt;/div&gt; ); }}render( &lt;App /&gt;, document.querySelector('#root')); src/index.css 123.has-text-red { color: #f00}","link":"/2020/01/29/coding/web_react003/"},{"title":"React[004] Component+数据传递","text":"src/components/Header/index.js 12345678910import React from 'react'export default function Header() { return ( &lt;h1&gt; 待办事项列表 &lt;/h1&gt; )} src/components/index.js 1export {default as Header} from './Header' src/App.js 12345678910111213141516import React, { Component } from 'react'import { Header} from './components'export default class App extends Component { render() { return ( &lt;&gt; &lt;h1&gt;app&lt;/h1&gt; &lt;Header /&gt; &lt;/&gt; ) }} src/index.js 123456789import React from 'react'import {render} from 'react-dom'import App from './App'render( &lt;App/&gt;, document.querySelector('#root')) 数据传递 App.js 12345678910111213141516171819202122232425262728293031323334353637import React, { Component } from 'react'import { TodoHeader, TodoInput, TodoList} from './components'export default class App extends Component { // state = { // title: '待办事项' // } constructor() { super() this.state = { title: '待办事项', desc: '今日是，今日比' } } render() { return ( &lt;&gt; &lt;h1&gt;app&lt;/h1&gt; &lt;TodoHeader desc={this.state.desc} x={1} y={2} z={3} &gt; {this.state.title} &lt;/TodoHeader&gt; &lt;TodoInput btnText=&quot;Add&quot; /&gt; &lt;TodoList /&gt; &lt;/&gt; ) }} components/TodoHeader/index.js 12345678910111213141516171819202122232425262728import React from 'react'import PropTypes from 'prop-types'export default function TodoHeader(props) { console.log(props) return ( &lt;&gt; &lt;h1&gt; {props.children} &lt;/h1&gt; &lt;h3&gt; {props.desc} &lt;/h3&gt; &lt;p&gt; {props.x + props.y} &lt;/p&gt; &lt;/&gt; )}TodoHeader.propTypes = { desc: PropTypes.string, x: PropTypes.number, y: PropTypes.number, z: PropTypes.number.isRequired, children: PropTypes.string.isRequired}","link":"/2020/01/30/coding/web_react004/"},{"title":"React[005]传值给子组件","text":"index.js外部老生畅谈主要是循环用到了array.map组件需要一层层传递如果需要透传可以使用{...todo} TodoItemList 1234567891011121314151617181920212223242526272829import React, { Component } from 'react'import TodoItem from &quot;./TodoItem&quot;;export default class TodoList extends Component { render() { console.log(this.props) return ( &lt;ul&gt; { this.props.todos.map(todo =&gt; { return ( &lt;TodoItem key={todo.id} {...todo} /&gt; // &lt;TodoItem // key={todo.id} // id={todo.id} // title={todo.title} // isCompleted={todo.isCompleted} // /&gt; ) }) } &lt;/ul&gt; ) }} TodoItem 123456789101112import React, { Component } from 'react'export default class TodoItem extends Component { render() { return ( &lt;li&gt; {this.props.title}{this.props.isCompleted ? '已完成' : '未完成'} &lt;/li&gt; ) }} 数据改变 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, { Component } from 'react'export default class Like extends Component { constructor() { super() this.state = { isLiked: false } } handleLikedClick = () =&gt; { // 这种方式再react中是不允许的，这种方式会改变数据但是不会改变展示 // this.state.isLiked = !this.state.isLiked; // 要修改数据就是用setState的方法 // 方法一 // this.setState({ // isLiked: !this.state.isLiked // }) console.log('setstate外部先驱的this.state.isLiked:', this.state.isLiked) // 方法二 this.setState((prevState) =&gt; { console.log(prevState) console.log('setstate内部的this.state.isLiked:', this.state.isLiked) return { isLiked: !prevState.isLiked } }, () =&gt; { // 由于setState 是异步的，所以要获取最新的state需要在回调中获取 console.log(this.state) }) console.log('setstate外部后续的this.state.isLiked:', this.state.isLiked) } render() { return ( &lt;div&gt; &lt;span onClick={this.handleLikedClick}&gt; {this.state.isLiked.toString()}: {this.state.isLiked ? '取消❤️' : '喜欢'} &lt;/span&gt; &lt;/div&gt; ) }}","link":"/2020/01/30/coding/web_react005/"},{"title":"React[005]01-如何显示定界符","text":"结论如果在jsx中打印{}写法是这样的{'{'}{'}'},相当于{'{'}加一个{'}'} jsx的语法是嵌套{}，所以今天我想打印{}这时候我按照其他语言默认实现都是加’\\‘转义，结果发现不管用，当时试了一下声明变量没问题，{}也不存在html转义码，当时有点懵。因为光想这是个特殊字符忘了以字符串的形式展示，具体实现上面已经说过，所以并没有在网上找到什么有用的信息。最后找到一个html转jsx。这个定界符的做法算是一个和其他语言小小的差异吧， php代码比较,php所有的字符都可以用\\转义，js所有的字符串都可以以字符串变量方式打印，总结上蛮奇怪的。蛤蛤 123456789php -aphp &gt; $a = 0;php &gt; echo &quot;{$a}&quot;;0php &gt; echo &quot;\\{$a}&quot;;\\{0}php &gt; echo &quot;\\{\\$a}&quot;;\\{$a}php &gt; echo &quot;\\{\\$a}&quot;;","link":"/2020/01/31/coding/web_react005_01/"},{"title":"React[006]:事件","text":"this.xxx.bind(this,pram)方法的传递 App.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849···constructor() { super() this.state = { title: '待办事项', desc: '今日是，今日比', article: '&lt;div&gt;asdasd&lt;i&gt;asdasdasdasd&lt;/i&gt;&lt;/div&gt;', todos: [ { id: 1, title: '吃饭', assignee: 'leo', isCompleted: true }, { id: 2, title: '睡觉', assignee: 'xiaoming', isCompleted: false }, ] } } addTodo = (todoTitle) =&gt; { console.log(todoTitle) this.setState({ // push 返回的是数组长度，非数组 // todos: this.state.todos.push({ // id: Math.random(), // title: todoTitle, // assignee: 'xxx', // isCompleted: false // }) todos: this.state.todos.concat({ id: Math.random(), title: todoTitle, assignee: 'xxx', isCompleted: false }) }) }··· &lt;TodoInput btnText=&quot;Add&quot; addTodo={this.addTodo} /&gt;··· input.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, { Component } from 'react'import PropTypes from 'prop-types'export default class TodoInput extends Component { static propTypes = { btnText: PropTypes.string } static defaultProps = { btnText: '添加todo' } constructor() { super(); this.state = { inputValue: 'asdas' } // this.handleAddClickUseBind = this.handleAddClickUseBind.bind(this) } handleInputChange = (e) =&gt; { console.log(e.currentTarget.value); this.setState({ inputValue: e.currentTarget.value }) } handleAddClickUseBind() { console.log(this.state) } handleAddClickTest = (id) =&gt; { console.log(id) console.log(this.state) } handleAddClick = () =&gt; { this.props.addTodo(this.state.inputValue) } render() { return ( &lt;div&gt; &lt;input type=&quot;input&quot; value={this.state.inputValue} onChange={this.handleInputChange}&gt;&lt;/input&gt; &lt;button onClick={this.handleAddClick}&gt;{this.props.btnText}&lt;/button&gt; &lt;br /&gt; other test &lt;button onClick={this.handleAddClickTest}&gt;{this.props.btnText}&lt;/button&gt; &lt;button onClick={this.handleAddClickUseBind.bind(this, 123)}&gt;{this.props.btnText}:usebind&lt;/button&gt; &lt;button onClick={() =&gt; { console.log(this.state) }}&gt;{this.props.btnText}:use()-&gt;{'{'}{'}'}&lt;/button&gt; &lt;button onClick={this.handleAddClickTest.bind(this, 1234)}&gt;{this.props.btnText}:use()-&gt;{'{'}{'}'}&lt;/button&gt; &lt;/div&gt; ) }}","link":"/2020/01/31/coding/web_react006/"},{"title":"React[007]:生命周期","text":"文档图 太偷懒了哈 123import React, { PureComponent } from 'react'const noop = () =&gt; { }export default class TodoItem extends PureComponent { PureComponent 代替 Component 或者 用以下代码进行渲染优化 123shouldComponentUpdate(nextProps, _nextState) { return nextProps.isCompleted !== this.props.isCompleted;}","link":"/2020/01/31/coding/web_react007/"},{"title":"React[008]:ajax","text":"http://jsonplaceholder.typicode.com/","link":"/2020/01/31/coding/web_react008/"},{"title":"React_Webpack_alias&amp;&amp;vscode_use_alias","text":"今天看react的项目目录里view和components是分开的，但是view里面有引用components的组件，然后from’../../xxxx’这种丑陋的引用路径就冒出来了。 之前使用laravel的时候记得里面的js资源（laravel里面的前端资源真是一条龙。全栈工具箱。。。），有用@代替路径，于是进行了查找react 别名 react alias ，查找的结果是customize-cra、react-app-rewired 这两个库，一个用于更改webpack的alias ，一个用于代替react-scripts, 具体使用比较简单，引入上述包后，创建config-overrides.js在项目根目录下 123456789const { override, addWebpackAlias } = require('customize-cra')const path = require('path')const resolve = dir =&gt; path.join(__dirname, '.', dir)module.exports = override( addWebpackAlias({ ['@']: resolve('src') })) 这样就可以稍微美化一下引用路径 然后问题就来了，vscode不知道你这个别名的路径了 (○´･д･)ﾉ fuck 不过这种东西查一下总是有办法的，而且办法超乎寻常的简单。。 在项目目录下创建一个jsconfig.json 12345678910111213{ &quot;compilerOptions&quot;: { &quot;baseUrl&quot;: &quot;./&quot;, &quot;paths&quot;: { &quot;@/*&quot;: [ &quot;src/*&quot; ] } }, &quot;exclude&quot;: [ &quot;build&quot; ]} 万事大吉 🐂🍺","link":"/2020/02/07/coding/web_react_webpack_alias/"},{"title":"react_包优化","text":"把一个react项目打包发布到了githubpage上，结果加载速度异常的慢，同比hexo生成的博客项目，加载速度尚可，打开network分析，两者差距较大，react项目的js文件将近1m，但是react的首屏出了一个nav和一段文字描述，其实并没有什么东西。而hexo项目本身文字较多，但js文件累加不足100k。导致react项目在带宽较低的情况下体验极差（我的腾讯云也只有1mbps理论上也需要将近10s才能加载完成）。因为引入库有限，所以对库文件进行分步引入分析。 react项目引入了 react本身 + ant 库 + echarts 库 + 其他 其中ant + echarts 占比 80% react清单 react 40kb + ant 245kb + react.qr 6kb echarts 272 （不引用地图资源） echarts chinamap world map 320 kb -&gt; main.js 业务产生main.js &lt; 3kb 内容较多展开查看 通过懒加载可以实现这个我已经知道，现在是探究一下到底是什么东西导致懒加载可以生效呢？ 文件引入探索首先有两个js文件 ， 其中一个加入console.log(1111)但不被任何文件import第二个文件加入console.log(2222)同时被引入，结果如下，222很明显在构建后的文件，111却不存在 在这提一下为什么做这个测试，这个结果有的人可能不做就能想到，但是我过去可能被我经历的一些优化方式所干扰，所以导致希望测一下。我所说的干扰场景就是比如php的部分静态检测工具可以针对单文件检测，单文件扫描，php的某些框架可以对单文件进行优化。就拿js一些语法库扩展库来说一样。php的部分框架是可以在安装依赖后构建缓存文件，这些缓存文件就是优化后的php代码，将一部分带有注解类的文件转为高效并且是真正运行的php代码，还有一些xml,yaml的转换，都是单文件转换。所以采用这种方式的可以给工具的开发者带来不用关心引用路径的问题。但是单页面打包并不是这样，他类似于传统文件的构建，或者c的编译，转换器会从入口文件开始对所有从入口文件。 举个单线思考的例子 开发php的时候或者仅仅是开发基于http的网络请求时大多数开发考虑的是单线逻辑，就是另个同级文件不会对我所开发的业务产生影响（比较片面，如果是发布订阅模式的话，许多统计的订阅者会有先后顺序，也会有一定干扰）。如果有人要访问一个基于php-fpm运行下的php代码，那么他的过程是入口-&gt;引导/框架基础处理/中间件处理-&gt;控制器-&gt;业务逻辑1-&gt;-&gt;业务逻辑2-&gt;-&gt;业务逻辑3,当然这条路是服务端提供的规则，前端传入规则（参数）来走通的。非这条路线中的文件是不会被访问和加载的。 类比来讲。web端的项目更多是引入了但是没有被调用。（如引入了一个ui框架但是你只使用了button组件） 这个打包过程类似一个树的遍历，从入口文件开始，import就是指针。通过这种方式就可以所有引入的文件进行编译。 懒加载探索懒加载/延迟加载的本质是将目的资源的通行证/目录先进行存储，之后通过通行证/目录调用。实现上也种类也有多种，如服务端数据的懒加载可以先将类型和id作为变量存储，如果需要使用这个对象则通过事先存储的类型和id进行转换，也可以构建闭包，使用时将闭包展开即刻。第二种也就是react所说的高阶组件（这种方式在php框架大多作为功能的延迟加载存在）。下面附上一段react延迟加载的手动实现 123456789101112131415161718192021222324252627282930313233import React, { Component } from 'react'const Loadable = ({ loader, loading: Loading}) =&gt; { return class LoadableComponent extends Component { state = { LoadedComponent: null } componentDidMount() { loader() .then(resp =&gt; { this.setState({ LoadedComponent: resp.default }) }) } render() { const { LoadedComponent } = this.state return ( LoadedComponent ? &lt;LoadedComponent /&gt; : &lt;Loading /&gt; ) } } }export default Loadable 代码逻辑是传入一个延迟加载的闭包loader()=&gt;import('./About')和一个loading(就是一个loading显示的组件)只用调用这个组件的时候才会真正的去破怪掉loader真正去执行import('./About') 但是~核心内容并没有探究到~~~~~~~~~~~~~~这知识代码的逻辑的懒加载，仅仅是懒加载完全可能是业务逻辑的懒加载，完全不代表文件的懒加载，更不代表主文件减少 其实这个也比较号理解，就是切割点的查找。a(b(c(d(()=&gt;{f}))))就比如上述调用，当我语法解析器或其他分析工具分析到一个闭包中的引用时，我就可以对其进行分割。实现文件上的剪切，打到不可告人的咪咪 皮一下很开心","link":"/2020/02/12/coding/web_react_%E5%8C%85%E4%BC%98%E5%8C%96/"},{"title":"simple request &#x2F; not so simplerequest","text":"浏览器将CORS请求分成两类：简单请求 simple request 和非简单请求not-so-simple request。只要同时满足以下两大条件，就属于简单请求。 12345678910（1) 请求方法是以下三种方法之一： HEAD GET POST（2）HTTP的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 那么对于非简单请求，浏览器会首先发送一个options嗅探。 这里不做示范。直接上一段php解决非简单请求的方法 1header(&quot;Access-Control-Allow-Headers:*&quot;) 直接设置会导致浏览器请求两次，所以还需要一些其他处理，防止重复请求 浏览器规定真。。。","link":"/2020/02/26/coding/web_simple_requestANDnot_so_simple_request/"},{"title":"vue标签隐藏","text":"no use 1&lt;p&gt;{{message}}&lt;/p&gt; use 1&lt;p v-text=&quot;message&quot;&gt;默认话术&lt;/p&gt;","link":"/2020/01/19/coding/web_z_vue%E6%A0%87%E7%AD%BE%E9%9A%90%E8%97%8F/"},{"title":"数据可视化工具了解","text":"能憋死你不能憋疯 想找一个js可视化的库，结果感觉有点乱，所以打算从库来源，下载数量等地方统计一下，来决定用哪个，虽然大不了再换，再大不了就去手撸js，不过还是先了解一下当下也是不错。 Three.js该项目的目的是创建一个易于使用、轻量级的 3D 库，并带有默认 WebGL 渲染器。该库还提供了示例中的 Canvas 2D、SVG 和 CSS3D 渲染器。 在这提一下three.js，虽然该库也可以做数据展示，但是这个更偏向于引擎一类的东西。这个库里面还有一些摄像机之类的概念，其实和数据可视化不是很贴切，跳过。 npm-three D3D3（或D3.js）是一个JavaScript库，用于使用Web标准可视化数据。D3 可帮助您使用 SVG、画布和 HTML 使数据栩栩如生。D3 将强大的可视化和交互技术与数据驱动的 DOM 操作方法相结合，为您提供现代浏览器的全部功能，并可以自由地为您的数据设计正确的可视化界面。 npm-D3 这个库在github排名较高，可做参考 Chart提供简单的一些数据可视化方式，多是折线图之类 npm-chart.js echarts憋死人的就在这了，我当时看着 chart.js 和 echart 一脸懵逼，为什么有两个名字这么像，但是呢文档不一样。结果发现是周杰和周杰伦的关系，这个出自百度。 npm-echarts Highcharts这是一个商业库（就是你想交银子不） 钦此","link":"/2020/02/08/coding/web_%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E4%BA%86%E8%A7%A3/"},{"title":"关于用go写接口调试代码的一次记录","text":"开发服务端接口的时候会使用postman进行调试\\测试，但是postman毕竟是一个功能比较固定的窗口软件，虽然postman也支持before after的一些操作，但是在参数复杂，或者批量调用的时候会存在操作繁琐，性能不高的情况，所以早先的时候有一些接口的调试我使用laravel-console+GuzzleHttp\\Client 进行接口调试 ，postman用来辅助编写。相比于postman这类的窗口软件，用语言直接编写接口调试的功能更加强大，并且在批量调用的时候响应上比postman快很多（postman 如果按照组进行调用，如果量大了会卡住）。后来就我就换成了go+resty。其中得益于换成了go，今天在测试环境寻找合适的测试数据，效率也比较快的完成。 我一般喜欢把同一个域名或同一个服务封装为一个client类。然后在这个client里去实现需要调试的接口调用。如下 123456789101112131415161718192021222324252627282930313233var dktForgeLoginClientIns DktForgeLoginClientvar dktForgeLoginClientInsOnce sync.Oncefunc DktForgeLoginClientConnection(host string) DktForgeLoginClient { dktForgeLoginClientInsOnce.Do(func() { if len(host) == 0 { host = &quot;http://localhost:3080&quot; } dktForgeLoginClientIns = DktForgeLoginClient{ httpClient: resty.New(). SetHostURL(host). SetHeader(&quot;Accept&quot;, &quot;application/json&quot;). SetTimeout(time.Second * 30), } }) return dktForgeLoginClientIns}func (receiver *DktForgeLoginClient) GetTempToken(userId string) (resp *resty.Response, err error) { return receiver.httpClient.R(). SetQueryParams(map[string]string{ &quot;userId&quot;: userId, }). Get(&quot;/forgelogin/api/getDktAccessToken&quot;)}func (receiver *DktForgeLoginClient) template() (resp *resty.Response, err error) { return receiver.httpClient.R().Get(&quot;/daiketong/v1/job-position/list&quot;)} 然后在 console.go 中编写展示\\测试\\数据提取逻辑 12345678910111213141516171819fmt.Println(&quot;岗位列表:&quot;)r, _ = dktClient.JobList()showResponseJson(r, userId)fmt.Println(&quot;创建岗位:&quot;)for _, name := range []string{&quot;萌德守卫&quot;} { r, _ = dktClient.JobCreate(name) showResponseJson(r, userId)}jobId := util.ToInt(gjson.Get(r.String(), &quot;data.jobId&quot;).Int())fmt.Println(&quot;编辑岗位:&quot;)r, _ = dktClient.JobEdit(jobId)showResponseJson(r, userId)fmt.Println(&quot;岗位详情:&quot;)r, _ = dktClient.JobDetail(jobId)showResponseJson(r, userId) 得益于编码的灵活性，可以随意调控请求顺序，变量存取，（postman也可以存取变量，但是相对编程来说较为繁琐,尤其是接口的调用顺序，控制起来成本比较高）。 接着是今天调试一个老接口的。背景是将底层的数据源从db换成了scf，单元测试已经可以跑起来，但是还未用接口进行请求。因为业务是刚刚接触不久，所以并不知道测试环境用什么数据可以请求这个接口。虽然可以看到这个接口的参数，但是不同的用户权限不一样。而且本次底层改动数量非少量，如果每个改动至少模拟在开发阶段至少查看一个外部接口，那么查看逻辑，再去数据库查数据寻找合适的用户数据用来进行http的参数构造那么是非常的繁琐的。由于数量较多，时间成本就变得比较大了。所以这里用了一个较为偷懒的方式，从数据库查询出一批可用的用户，从登陆开始调用，保存token，然后调用目标接口，check返回数据，可以很快search出合适的用户用于接下来针对接口的自测。 这边业务程序的逻辑是 1234567// 伪登陆client// 获取伪登陆令牌// authclient// 获取真正的业务令牌// 业务client set令牌// 请求对应业务接口// checkResponse 其中业务client由于存在登陆态，所以 业务client 我没有使用单例。 接下来就是主程序里的协程开发了，这里启动了20个协程，用redis队列进行userId的分发。其中token在获取成功后会保存到本地的redis里。 12345678910111213141516171819202122232425262728293031func ajkAction() { userIdList := strings.Split(getAjkUserIdCanManageEmployee(), `,`) var ctx = context.Background() lPushKey := &quot;workDktUserList&quot; db.RedisIns().Del(ctx, lPushKey) db.RedisIns().LPush(ctx, lPushKey) db.RedisIns().LPush(ctx, lPushKey, userIdList) var wg sync.WaitGroup workNum := 20 // 之前由于把i设置为0开始，并且设置了add20导致可能会减到负一导致报错 for i := 1; i &lt;= workNum; i++ { // 严谨点这样就不会受计算影响 wg.Add(1) go func() { defer wg.Done() for { userId, err := db.RedisIns().LPop(ctx, lPushKey).Result() if err != nil { fmt.Println(err) return } fmt.Println(len(userId)) ajkClientRunner(userId) } }() } wg.Wait()} 事实证明，不到1分钟就在2000个userid中筛选出可以使用的userId。只需要在日志中把check成功的userId留下来。就可以用来接下来的自测了。由于开发过程中，每完成一个接口就实现一个对应的client-method。并且维护好主要调试可以提高调试和接口自测的效率。以及快速定位问题 123456789101112131415UserAllocatedList:读取本地token成功本地token尚未过期，可继续使用eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6ImF1dGhfdG9rZW5fcGFpcl82MTAzYTJkYzQ1MmY2MC41ODMxMzU0MCJ9.eyJpc3MiOiJodHRwczpcL1wvZGFpa2V0b25nLjU4LmNvbSIsImF1ZCI6Imh0dHBzOlwvXC9kYWlrZXRvbmcuNTguY29tIiwianRpIjoiYXV0aF90b2tlbl9wYWlyXzYxMDNhMmRjNDUyZjYwLjU4MzEzNTQwIiwiaWF0IjoxNjI4OTI0MjUyLCJleHAiOjE2Mjg5MjQyNTIsInVzZXJfaWQiOjU4NjI1fQ.rhR2YlTTcT93PFbFp3c0bqIP9kJxDU-67KnysHccgaJ8vnf7Du7Xgy3hiZ0MNZyTup9E1M7vzo5MwNVjI0V2xYh5RTu8aFjiQ6nfVab80vvIRJ3yA7l-nXQ23FqLCktHGyTjvxEm046bS4Zmt8Kldmh_lX0SritdGzqN-YiP9LTi1DCflWTAvMSnjAqRt5djFObGz0RCnCoLS93u7mVluEAML6o-zO2_-XtY1HD8_EWsHXW03NVbvu9b2mLwEA2HgFxf5jBbCP1n7V7-qyp9VHsajGDq5dWuIXz8XTa4_deVNyOLWDxRCypFOHhypAuIm2yBh0quJb4HGgkAvtUW5gUserAllocatedList:读取本地token成功本地token尚未过期，可继续使用eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsImp0aSI6ImF1dGhfdG9rZW5fcGFpcl82MTAzYTJkYzI0MDhkMC43ODE4ODg4NyJ9.eyJpc3MiOiJodHRwczpcL1wvZGFpa2V0b25nLjU4LmNvbSIsImF1ZCI6Imh0dHBzOlwvXC9kYWlrZXRvbmcuNTguY29tIiwianRpIjoiYXV0aF90b2tlbl9wYWlyXzYxMDNhMmRjMjQwOGQwLjc4MTg4ODg3IiwiaWF0IjoxNjI4OTI0MjUyLCJleHAiOjE2Mjg5MjQyNTIsInVzZXJfaWQiOjU4NjI2fQ.SGve5sph9pfpF7bclNRSqXTLNHkIubJiShzSTt4TU3UfHm4vD3tYKBHc3AIAxLq92WPQOfNqJznsyQo3CZoawzejAKKolC4ym28peJV-GFdV04T7HsIMlIgpmvjpiyRhnvCoAvVCOy15-15U04U2CJtsI7xcglk6iF4BdnZZA8776oFqd7BVfgJ5gKbU45Q18RxVGUyUCvkOE33TgpCwE6uzbHwDkrs0zWZWZgavBqLhk-C5lJlrqBucs9H6vPU4NR6KqVmY_qhNV_7byL5739lladXZ5GNE3WIdbO6mYL-c_BtHUvfawgB70SdyvO2AZ1GedJ-qwWg6K9x_1rJFaQUserAllocatedList:[18221] {&quot;data&quot;:{},&quot;errcode&quot;:&quot;系统错误&quot;,&quot;message&quot;:&quot;非法的管辖城市&quot;,&quot;status&quot;:&quot;error&quot;}redis: nil[18149] {&quot;data&quot;:{&quot;list&quot;:[{&quot;avatar&quot;:&quot;&quot;,&quot;cellphone&quot;:&quot;15521577326&quot;,&quot;city_name&quot;:&quot;上海&quot;,&quot;forward&quot;:1,&quot;job_id&quot;:10,&quot;job_name&quot;:&quot;项目运营专员&quot;,&quot;job_number&quot;:null,&quot;user_id&quot;:13585,&quot;username&quot;:null}]},&quot;errcode&quot;:&quot;&quot;,&quot;message&quot;:&quot;&quot;,&quot;status&quot;:&quot;ok&quot;}redis: nil[18163] {&quot;data&quot;:{},&quot;errcode&quot;:&quot;系统错误&quot;,&quot;message&quot;:&quot;非法的管辖城市&quot;,&quot;status&quot;:&quot;error&quot;}redis: nil","link":"/2021/08/02/diary_blog/2021_08_02%E7%94%A8go%E5%86%99%E6%8E%A5%E5%8F%A3%E8%B0%83%E8%AF%95/"},{"title":"猴子荡秋千","text":"猴子荡秋千，一个关于信号相关的问题的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158func cmdMonkey() { fmt.Println(&quot;this is a cmdMonkey&quot;) monkeyInit() go pM1Run() go pM2Run() for { time.Sleep(time.Second) }}func pM1Run() { i := 0 for { i += 1 go m1Run(i) time.Sleep(time.Second) }}func pM2Run() { i := 0 for { i += 1 go m2Run(i) time.Sleep(time.Second) }}var m1List intvar m2List intvar m1L map[int]intvar m2L map[int]inttype waitMonkey struct { tag int monkeyNumber int}var maybeWaitList map[waitMonkey]intvar canAdd intvar canUse = sync.Mutex{}func monkeyInit() { m1List = 0 m2List = 0 canAdd = 0 m1L = make(map[int]int) m2L = make(map[int]int) maybeWaitList = make(map[waitMonkey]int)}func simpleP(i int) { for i &lt;= 0 { time.Sleep(time.Second) }}func m1Run(monkeyNumber int) { tag := &quot;1:北遍第&quot; wm := waitMonkey{1, monkeyNumber} if m1List == 0 &amp;&amp; m2List == 0 { fmt.Println(tag, monkeyNumber, &quot;队伍没人，猴子上树&quot;) maybeWaitList[wm] = 1 fmt.Println(&quot;当前被阻塞的monkey&quot;, maybeWaitList) canUse.Lock() delete(maybeWaitList, wm) m1List += 1 m1L[monkeyNumber] = 1 } else { if canAdd == 1 &amp;&amp; m1List != 0 { fmt.Println(tag, monkeyNumber, &quot;本队有人，直接上树&quot;) m1List += 1 m1L[monkeyNumber] = 1 } else { fmt.Println(tag, monkeyNumber, &quot;已经发车&quot;) maybeWaitList[wm] = 1 fmt.Println(&quot;当前被阻塞的monkey&quot;, maybeWaitList) canUse.Lock() delete(maybeWaitList, wm) fmt.Println(tag, monkeyNumber, &quot;本队无人申请上树&quot;) m1List += 1 m1L[monkeyNumber] = 1 } } fmt.Println(tag, monkeyNumber, &quot;准备发车&quot;) time.Sleep(time.Second * 3) fmt.Println(tag, monkeyNumber, &quot;#################################&quot;) fmt.Println(tag, monkeyNumber, m1L) fmt.Println(tag, monkeyNumber, &quot;开始下车&quot;) fmt.Println(tag, monkeyNumber, &quot;#################################&quot;) canAdd = 0 m1List -= 1 delete(m1L, monkeyNumber) if m1List == 0 { canAdd = 1 canUse.Unlock() } else { fmt.Println(tag, monkeyNumber, m1List, &quot;车上尚有人&quot;) }}func m2Run(monkeyNumber int) { tag := &quot;2:南遍第&quot; wm := waitMonkey{2, monkeyNumber} if m1List == 0 &amp;&amp; m2List == 0 { fmt.Println(tag, monkeyNumber, &quot;队伍没人，猴子上树&quot;) maybeWaitList[wm] = 1 fmt.Println(&quot;当前被阻塞的monkey&quot;, maybeWaitList) canUse.Lock() delete(maybeWaitList, wm) m2List += 1 m2L[monkeyNumber] = 1 } else { if canAdd == 1 &amp;&amp; m2List != 0 { fmt.Println(tag, monkeyNumber, &quot;本队有人，直接上树&quot;) m2List += 1 m2L[monkeyNumber] = 1 } else { fmt.Println(tag, monkeyNumber, &quot;已经发车&quot;) maybeWaitList[wm] = 1 fmt.Println(&quot;当前被阻塞的monkey&quot;, maybeWaitList) canUse.Lock() delete(maybeWaitList, wm) fmt.Println(tag, monkeyNumber, &quot;开始上树&quot;) m2List += 1 m2L[monkeyNumber] = 1 } } fmt.Println(tag, monkeyNumber, &quot;准备发车&quot;) time.Sleep(time.Second * 3) canAdd = 0 fmt.Println(tag, monkeyNumber, &quot;#################################&quot;) fmt.Println(tag, monkeyNumber, m2L) fmt.Println(tag, monkeyNumber, &quot;开始下车&quot;) fmt.Println(tag, monkeyNumber, &quot;#################################&quot;) m2List -= 1 delete(m2L, monkeyNumber) if m2List == 0 { canAdd = 1 canUse.Unlock() } else { fmt.Println(tag, monkeyNumber, m2List, &quot;车上尚有人&quot;) }}","link":"/2021/10/04/diary_blog/2021_10_04%E7%8C%B4%E5%AD%90%E8%8D%A1%E7%A7%8B%E5%8D%83/"},{"title":"GB&#x2F;T 7714-2015","text":"","link":"/2021/10/12/diary_blog/2021_10_12GB_T_7714-2015/"},{"title":"local_docker","text":"123456789101112131415FROM ubuntu:21.04LABEL maintainer=&quot;Thh&quot;RUN sed -i &quot;s@http://.*archive.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list &amp;&amp; sed -i &quot;s@http://.*security.ubuntu.com@http://repo.huaweicloud.com@g&quot; /etc/apt/sources.list RUN apt-get update \\ &amp;&amp; apt-get install -y curl zip unzip git supervisor sqlite3 zsh vim net-tools RUN git clone https://gitee.com/mirrors/oh-my-zsh.git ~/.oh-my-zsh \\ &amp;&amp; cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc \\ &amp;&amp; sed -i &quot;s@robbyrussell@af-magic@g&quot; ~/.zshrc \\ &amp;&amp; git config --global --add oh-my-zsh.hide-dirty 1CMD [&quot;/bin/sh&quot;,&quot;-c&quot;,&quot;while true; do date +'%Y-%m-%d %T %z'; sleep 2; done&quot;] 123456789101112131415version: '3.5'networks: local_net: driver: bridgeservices: #表示这是一组服务 ubuntu: build: context: ubuntu working_dir: /var/www volumes: - ${WORKSPACE}:/var/www:cached restart: always #docker服务重启后nginx的docker容器也重启 networks: - local_net","link":"/2021/11/04/diary_blog/2021_11_04local_docker/"},{"title":"math","text":"latex在线 x = p Cos(θ)y = p Sin(θ) 已知函数 $f(x,y)$ 满足 $f_{x,y}’’(x,y) = 2(y+1)e^x$ ， $f_{x}’(x,0)=(x+1)e^x$ , $f(0,y)=y^2+2y$ , 求 $f(x,y)$ 的极值。 思路先求原函数，再求对应的二阶偏导，根据二阶偏导求极值。 解： $f_{xy}’’(x,y)=2(y+1)e^x$ 两边对y积分，得 $f_{x}=2 (1/2y^2+y)e^x+\\varphi(x)=(y^2+y)e^x+\\varphi(x)$","link":"/2021/12/25/diary_blog/2021_11_15math/"},{"title":"汇编","text":"关于查看 c 的等价汇编源码。 编写 main.c 文件 12345#include&lt;stdio.h&gt;int main(){ printf(&quot;hello&quot;); return 0 ;} 执行命令 gcc -S main.c 可以得到 main.s 这个便是汇编的文件，.s 为汇编源文件的后缀。其中文件内的注释为;。 main.s 文件 1234567891011121314151617181920212223242526272829 .section __TEXT,__text,regular,pure_instructions .build_version macos, 11, 3 sdk_version 11, 3 .globl _main ; -- Begin function main .p2align 2_main: ; @main .cfi_startproc; %bb.0: sub sp, sp, #32 ; =32 stp x29, x30, [sp, #16] ; 16-byte Folded Spill add x29, sp, #16 ; =16 .cfi_def_cfa w29, 16 .cfi_offset w30, -8 .cfi_offset w29, -16 stur wzr, [x29, #-4] adrp x0, l_.str@PAGE add x0, x0, l_.str@PAGEOFF bl _printf mov w8, #1 mov x0, x8 ldp x29, x30, [sp, #16] ; 16-byte Folded Reload add sp, sp, #32 ; =32 ret .cfi_endproc ; -- End function .section __TEXT,__cstring,cstring_literalsl_.str: ; @.str .asciz &quot;hello&quot;.subsections_via_symbols 因为用 m1 的本子转换得到的。用电脑自带的 /usr/bin/as。编译成功无法运行。可能平台相关。","link":"/2021/12/03/diary_blog/2021_12_03%E6%B1%87%E7%BC%96/"},{"title":"1652162905832","text":"对于可控的事情要保持谨慎，对于不可控的事情要保持乐观，人只能做自己能力范围之内的事情，你要接受这个事实，并且以乐观的心去应对这一切","link":"/2022/05/10/diary_blog/2022_05_101652162905832/"},{"title":"go 1.18","text":"go.mod 文件 go 1.17 替换为 go 1.18interface{} 替换为 any 因为 go 当中不存在全局变量这一概念，在低版本颗要用这个方法的话，就需要每个包内都实现一个。","link":"/2022/03/19/diary_blog/2022_03_19_go1.18/"},{"title":"Foreign language diary","text":"Why i write diary in my blog? Today I see some suggestion in Quora where is a web-station about Question-Answer. Among answer say “Learn it yourself by using English every day”. So I think I should try write diary by using English every day. Today is September 22, 2021 , 90 days before Postgraduate entrance examination. I hope I can success. If you find any grammatical errors in my diary , you can tell me . Thanks for you help. 2021/10/07 Thursday 2021/10/06 Wednesday 2021/10/05 Tuesday 2021/10/04 Monday 2021/10/04 Monday 2021/10/03 Sunday 2021/10/02 Saturday 2021/10/01 Friday 2021/09/30 Thursday 2021/09/29 Wednesday 2021/09/28 Tuesday 2021/09/27 Monday 2021/09/26 Sunday 2021/09/25 Saturday 2021/09/24 Friday 2021/09/23 Thursday 2021/09/22 Wednesday The article is flashback 2021/09/26 Sunday2008 :As is symbolically illustrated in the cartoon, two handicapped adolescents ,supporting each other with their firm hands , are continuing their new journey across the ground .Crutches left behind,they heave successfully cracked the hard nut of lameness, which might have stumped the majority of th disabled. The caption indicates,”You have merely one leg and so do I. Helping each other ,we can travel all around.”Undoubtedly , we can deduce from the portrayal that the cartoonist is trying to attract our attention to issue of cooperation .According to survey conducted among a group of people who wre in the same college class 10 years ago, those who are ready to give their cooperation to others all became rich or attained managerial status in various fields, while not a single young man who had difficulty in getting along with his classmates became an executive or a boss . Why do those who are excellent in team work tend to be managers or run their own enterprise later in life? The answer seems self-evident. On the one hand, if you are competent in a profession , but have difficulty in getting along with your colleagues and even with you boss ,you can hardy survive corporate life . On the other hand, your chances if success are much higher with a wide circle of friends who are willing to cooperate with you to provide information and resources.It is my view that ,first and foremost , we can use the drawing to aid juveniles in learning to cooperate successfully with each other. Furthermore , whatever difficulties or situations we are confronted with ,we can remind ourselves that those who have the spirit of cooperation and theme work are nearer to success. Just as John Adams, the second U.S. president, quoted from the ancient Greek Aesop’s Fables, “united we stand, divided we fall.” 2010 :As is symbolically illustrated in the portrayal,there is a boiling hot pot containing various ingredients of disparate cultures. These various cultures can be categorized as cultural celebrities home and abroad ,such as Bi Sheng, Lao She,Shakespeare and Einstein; philosophical concepts, such as Buddhism , Taoism, Confucianism ,benevolence ,ritual, humanism, enlightenment,post-modernism and deconstructionism,as well as performing arts or works such as Peking Opera, Kung fu and Swan Lake. We afe informed that the cultural “ hot pot” is both delicious and nutritious. The above article comes from page 160. 2021/09/25 Saturday today no writing. 2021/09/24 Friday In my opinion, life is difficult in Japan if you do not like studying.Which is correct, “who/whom do you want to see”?I hope this was helpful!To me, both are acceptable and grammatical. Which country is the most digitalized between South Korea and Japan? 2021/09/23 Thursday2008 : As is symbolically illustrated in the cartoon, two handicapped adolescents, supporting each other with their firm hands, are continuing their new journey across the ground. firm 公司,坚固 2021/09/22 WednesdayThe first day after the Mid-Autumn Festival.","link":"/2021/12/25/important/2022Foreign_language_diary/"},{"title":"操作系统","text":"引论 1 引论 二 进程管理 2 进程管理 2.1.4程序的三态 2.1.5 2.3.1.4 同步机制应遵循的规则 2.3.2 信号量机制 2.3.3 信号量的应用 2.6.4 线程的实现 三 处理机调度与死锁 3.3 调 度 算 法 3.2.1 先来先服务和短作业(进程)优先调度算法 3.3.2 高优先权优先调度算法 3.5.2 产生死锁的必要条件 3.5.3 处理死锁的基本方法 第四章 存 储 器 管 理 。。。 4.3.3 动态分区分配 4.4 基本分页存储管理方式 4.4.1 页面与页表 4.4.2 地址变换机构 4.5 基本分段存储管理方式 4.5.2 分段系统的基本原理 引论1 引论 二 进程管理2 进程管理2.1.4程序的三态 就绪态 执行状态 阻塞状态 2.1.5 PCB (PROCESS CONTROL BLOCK) 2.3.1.4 同步机制应遵循的规则 空闲让进。当无进程处于临界区时，表明临界资源处于空闲状态，应允许一个请求进入临界区的进程立即进入自己的临界区，以有效地利用临界资源 忙则等待。当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待，以保证对临界资源的互斥访问。 有限等待。对要求访问临界资源的进程，应保证在有限时间内能进入自己的临界区，以免陷入“死等”状态 让权等待。当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入“忙等”状态。 让权等待可以对比循环查询，和队列触发这两者比较。前者永远在不停的检测是否可以使用，后者则是通过事件，当任务执行完毕后自动调用阻塞的任务。 2.3.2 信号量机制 P 通过 V 释放 wait() signl() 2.3.3 信号量的应用 1．利用信号量实现进程互 2．利用信号量实现前趋关系 2.6.4 线程的实现用户级线程与内核控制线程的连接 1v1 nv1 nvn 三 处理机调度与死锁3.3 调 度 算 法3.2.1 先来先服务和短作业(进程)优先调度算法 先来先服务 短作业优先 饥饿 3.3.2 高优先权优先调度算法3.5.2 产生死锁的必要条件 互斥条件 请求和保持条件 不剥夺条件 环路等待条件3.5.3 处理死锁的基本方法 预防死锁 避免死锁 检测死锁 解除死锁 第四章 存 储 器 管 理。。。4.3.3 动态分区分配 分区分配中的数据结构 空闲分区表 空闲分区链 分区分配算法 首次适应算法(first fit) 求空闲分区链以地址递增的次序链接，分配内存时，从链首开始顺序查找，直至找到一个大小能满足要求的空闲分区为止。 循环首次适应算法(next fit) 不再是每次都从链首开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找，直至找到一个能满足要求的空闲分区。 最佳适应算法(best fit) 把能满足要求、又是最小的空闲分区分配给作业 最坏适应算法(worst fit) 最坏适应分配算法要扫描整个空闲分区表或链表，总是挑选一个最大的空闲区分割给作业使用 快速适应算法(quick fit) 碎片 内/外碎片 整体无法使用的的块儿（外部），和分配块儿后，块儿内无法使用的部分（内部）。 4.4 基本分页存储管理方式4.4.1 页面与页表 逻辑分块成为页或者页面，对应内存分的(物理)块或页框(frame)，两者大小相同由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。 分页存储管理是将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页，并为各页加以编号，从 0 开始，如第 0 页、第 1 页等。相应地，也把内存空间分成与页面相同大小的若干个存储块，称为(物理)块或页框(frame)，也同样为它们加以编号，如 0#块、1#块等等。 页面若太小，一方面虽然可使内存碎片减小，从而减少了内存碎片的总空间，有利于提高内存利用率，但另一方面也会使每个进程占用较多的页面，从而导致进程的页表过长，占用大量内存如果选择的页面较大，虽然可以减少页表的长度，提高页面换进换出的速度，但却又会使页内碎片增大 地址结构:｜页号 P ｜位移量 W ｜31～12，11～0 页号 P 和页内地址 dP=int(A/L)d=[A] MOD L 页表: 逻辑地址到物理地址的映射表页号｜块号 4.4.2 地址变换机构 页表位于内存联想寄存器-快表-TLB reread 两级页表 144 页 4.5 基本分段存储管理方式4.5.2 分段系统的基本原理段号｜段内地址 段表 LOAD 1，[A] |〈D〉;STORE 1，[B] |〈C〉;","link":"/2021/12/24/important/2022%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"title":"数据结构","text":"BR 1.结点是红色或黑色。2.根结点是黑色。3.每个叶子结点都是黑色的空结点（NIL结点）。4 每个红色结点的两个子结点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色结点)5.从任一结点到其每个叶子的所有路径都包含相同数目的黑色结点。 AVLBRBB+","link":"/2021/12/24/important/2022%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"计算机组成原理","text":"6 6.1 6.2 7 7.1 7.1.1 7.1.1.2 地址码 7.3 寻指方式 7.3.1 指令寻址 7.3.2 数据寻址 8 CPU 8.1 8.1.1 8.1.3 CPU寄存器 8.2 指令周期 8.2.2 ****** 指令周期的数据流 8.4.1 中断系统 8.4.4 中断相应 8.4.5 保护现场和恢复现场 8.4.6 中断屏蔽技术 9 9.1 10 CU 66.1机器数是符号化的数字 如 1 0001 表示 -1真值是带有加减的数字 如 - 0001 表示 -1原码为可以视为机器数布码 正数不变 负数取反+1反码 6.2定点表示 符号 正数部分 小数部分浮点表示 阶号 阶码部分 数符 尾数值数符 尾数 * 阶号 阶码部分32 8（1+7） 24（1+23）64 11（1+10） 53（1+52）80 15（1+14） 65（1+64）规格化尾码为0视为0IEEE754:32 8（1+7） 24（1+23）64 11（1+10） 53（1+52）80 15（1+14） 65（1+64） 77.1instruction操作码+地址码op+address操作码 地址码 地址码 地址码1111 xxxx1111 1111 xxxx1111 1111 1111 xxxx用地址码扩展操作码 15+15+15+16 = 61 7.1.17.1.1.2 地址码四地址 op a1 a2 a3 a4操作 操作数1 操作数2 结果3 下一指令地址三地址 op a1 a2 a3 (相比于四地址，三地址省略了下一指令地址，吓一指令地址可以通过pc 程序计数器获取)二地址 op a1 a2 （相比于三地址，二地址省略了结果地址，其结果可以重新写入a1 也就是 a1 = a1 + a2 ）二地址 (a1)op(a2)-&gt;a1 (a1)op(a2)-&gt;acc 前者存入操作数a1地址中，后者存入acc中，都可以把结果地址省略一地址 op a1 (相比于二地址，一地址又减少了一个操作数的取值地址)一地址 (acc)op(a1)-&gt;acc 如 从 acc 和 a1地址取值 得出结果后存入 acc (或者存入 a1)零地址 例如 进栈出栈 可以利用sp指针Trap（陷入）/访管 指令 7.3 寻指方式7.3.1 指令寻址顺序寻址 pc跳跃寻址 jup-&gt;pc 7.3.2 数据寻址操作码 寻址特征 形式地址*立即寻址：op 立即寻址特征 立即数 （这里的立即数就是操作数本身而非操作数地址 ，可以直接使用无需再去取地址 ）*直接寻址：op 寻址特征 形式地址EA=A (EA 真实地址) A的范围 A的值*隐含寻址：ADD 寻址特征 形式地址ACC中存有另一个*间接寻址EA=(A)—- 操作数为 (EA)所以可以理解为A为指令中内容 (A) A所在地址内容，也就是EA：操作数地址，(EA)为操作数内容可以理解操作数 = ((A))间接寻址可以是一次间接也可以是多次间接*寄存器寻址EA=Ri 因为 Ri 为寄存器地址 所以不需要读内存 操作数为(Ri)写法上 EA=Ri 和 EA=A前者是寄存器寻址后者是直接寻址，不同之处 (Ri) 不是读内存，而是读寄存器，所以虽然写法相同但是读取的地址不同后者 (A) 读取的地址为主存*寄存器间接寻址EA=(Ri)*基址寻址EA=A+(BR)*变指寻址EA=A+(IX)*相对寻址EA=(PC)+A*堆栈寻址SP+X-&gt;SPSP-X-&gt;SP 8 CPU8.18.1.1取指令分析指令执行指令顺序执行：指令控制，控制命令：操作控制，时间控制，数据控制，中断处理 8.1.3 CPU寄存器用户可见寄存器 ： 通用寄存器，数据寄存器，地址寄存器控制和状态寄存器： MAR，MDR，PC，IR 8.2 指令周期取指阶段 执行阶段取指周期 执行周期（取指+分析） (执行指令)取指周期 间址周期 执行周期 （存在间接寻址的指令） 8.2.2 ****** 指令周期的数据流8.4.1 中断系统中断判优 8.4.4 中断相应中断相应的条件条件/时间/隐指令中断隐指令 保护程序断点「保存pc内容也就是保存当前程序运行到底地址」 寻找中断服务的入口地址「要执行程序的地址」 关中断「不再接收其他程序」 8.4.5 保护现场和恢复现场8.4.6 中断屏蔽技术多重中断条件（单重中断/多重中断） 开中断 中断优先级屏蔽技术 屏蔽触发器与屏蔽字 1就屏蔽 1111111 全屏蔽 0111111 又一个没有屏蔽多重中断中断点保护 99.1取间执中取指令间接寻址执行指令中断指令 10 CU","link":"/2021/12/24/important/2022%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"},{"title":"计算机网络","text":"1. 概述 2. 物理层 3. 数据链路层 3.1.2 基本问题 3.2 点对点ppp协议 3.3 使用广播信道的数据链路层 3.3.2 CSMA\\CD 载波监听多点接入碰撞检测。 4. 网络层 5. 传输层 Tcp 三次握手 6. 应用层 1. 概述2. 物理层媒介设备PDU: bit（比特流）协议公式：奈氏准则: 2W *log2(V) v为电平数信噪比（dB） = 10 lg(S/N) (dB)香农定理: C = W log2(1+S/N) b/s， 3. 数据链路层 媒介设备 : 交换机PDU: frame（帧）MTU（最大传输单元）协议公式(7+1),6,6,2,46~1500,4前导码，目的地址，原地址，协议，数据，FCS 3.1.2 基本问题封装成帧、透明传输、差错检测 3.2 点对点ppp协议3.3 使用广播信道的数据链路层3.3.2 CSMA\\CD 载波监听多点接入碰撞检测。边发送边监听 4. 网络层媒介设备 : 路由器PDU: packet协议公式 (20+x),data 5. 传输层Tcp 三次握手123456client -&gt; service[syn:1,seq=x]client &lt;- service[syn:1,ack=x+1,seq=y]client -&gt; service[syn:0,ack=y+1,seq=z] 媒介设备PDU: segment（TCP 报文段） 或 datagram （UDP 用户数据报）协议公式 会话层媒介设备数据报协议公式 表示层媒介设备数据报协议公式 6. 应用层媒介设备PDU: message协议公式 A类IP地址 地址范围1.0.0.1-126.255.255.254（二进制表示为：00000001 00000000 00000000 00000001 - 01111110 11111111 11111111 11111110）。B类IP地址地址范围128.1.0.1-191.254.255.254（二进制表示为：10000000 00000001 00000000 00000001 - 10111111 11111110 11111111 11111110）。C类IP地址范围192.0.1.1-223.255.254.254（二进制表示为: 11000000 00000000 00000001 00000001 - 11011111 11111111 11111110 11111110）。D类IP地址范围224.0.0.1-239.255.255.254。E类IP地址范围240.0.0.0—255.255.255.254。 A级：10.0.0.1 - 10.255.255.254B级：172.16.0.1 - 172.31.255.254C级：192.168.0.1 - 192.168.255.254","link":"/2021/12/24/important/2022%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"title":"Foreign language diary","text":"大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。","link":"/2021/11/08/important/other/"},{"title":"IdMaker","text":"1234567create table `id_maker`( `business` varchar(255) NOT NULL COMMENT '业务', `next_id` decimal(64, 0) unsigned NOT NULL default 1 COMMENT '下一次id', PRIMARY KEY (`business`) USING BTREE) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COMMENT ='idMaker'; 123456insert into id_maker values ('default',1);insert into id_maker values ('eat_food_00',1);insert into id_maker values ('eat_food_01',101);insert into id_maker values ('eat_food_02',201);insert into id_maker values ('eat_food_03',301);insert into id_maker values ('eat_food_04',401); 1234begin;select next_id from id_maker where business = 'default';update id_maker set next_id = next_id+100 where business = 'default';commit; 1234begin;select next_id from id_maker where business = 'default';update id_maker set next_id = next_id+500 where eat_food_01 = 'default';commit; 1234567891011121314151617181920212223242526class IdMaker{ public $idMaker = 'default'; public $maxId = '0'; public $nextId = '0'; public function __construct() { $this-&gt;idMaker = 'eat_food_'.rand_mt(0,4); $this-&gt;updateIdMaker(); } public function getNextId() { if($nextId&gt;$maxId){ $this-&gt;updateIdMaker(); } return $this-&gt;nextId++; } protected function updateIdMaker() { // 通过 idMaker 获取最新的 $this-&gt;nextId = $maxId; $this-&gt;maxId = $nextId + 100; }}","link":"/2021/09/26/coding/php/IdMaker/"},{"title":"laravel-auth","text":"laravel 的 auth 生效流程 laravel bootstrap\\app 中分别注册了 http 的中间件，和 ServiceProvider (服务提供者) 这两个东西。但是在实际的生命周期中， 服务提供者 ServiceProvider 会先于 http 中间件先执行。 而 AuthServiceProvider 从结果上来说，可以认为他默认的行为是通过约定的方式，从 request 中获取 api_token 的值，然后在数据库中查询此 api_token 是否存在对应的 user 并设置在 auth 的一个属性。当你在 Authenticate 这个 http 中间件中调用 $this-&gt;auth-&gt;guard($guard)-&gt;guest() 实际上就是判断当前 auth 的 user 属性是否存在。不存在说明之前用 api_token 并没有查到 user 。所以如果需要定制化这一块，比如更换 token 的传输方式，或者 user 的获取方式， 需要更改服务提供者就可以。一般情况下不需要更改中间件。如果你需要给某些账户可以跳过中间件也可以在 http 中间件的代码的修改。不过一般来说是不需要修改中间件的。","link":"/2021/03/23/coding/php/laravel-auth/"},{"title":"password","text":"两段示例，以作使用php自带加密方法的迁移之备 123456789101112131415&lt;?php$password = '123456';$i = 10;while($i--){ $hash = password_hash($password, PASSWORD_BCRYPT); echo $hash.PHP_EOL;}$hash = '$2a$10$PLRjN06j9QTztJ24evbLvOKcPOw6mBR5ARgcwQECkfN4p.Co.i/te';var_dump(password_verify($password, $hash)); 123456789101112131415161718192021222324252627package main import ( &quot;fmt&quot; &quot;golang.org/x/crypto/bcrypt&quot;) func PasswordHash(password string) (string, error) { bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost) return string(bytes), err} func PasswordVerify(password, hash string) bool { err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password)) return err == nil} func main() { password := &quot;123456&quot; hash, _ := PasswordHash(password) fmt.Println(&quot;密码:&quot;, password) fmt.Println(&quot;hash:&quot;, hash) match := PasswordVerify(password, hash) fmt.Println(&quot;验证:&quot;, match)}","link":"/2020/02/25/coding/php/password/"},{"title":"PHP[000]:书本杂志","text":"x url PHP Code Quality Tools to Check and Improve your Code https://web-techno.net/code-quality-check-tools-php/ Github星聚弃疗榜(Github星爆沙雕榜) https://github.com/zhaoolee/StarsAndClown php版本兼容 https://github.com/wapmorgan/PhpCodeFixer 静态检测 https://github.com/phpstan/phpstan 代码复杂的检测 https://github.com/bmitch/churn-php 静态检测 https://github.com/JakubOnderka/PHP-Parallel-Lint","link":"/2019/07/01/coding/php/php_000_link/"},{"title":"PHP[001]:Composer","text":"https://github.com/slince/composer-registry-manager 12345$ composer repo:ls composer https://packagist.org phpcomposer https://packagist.phpcomposer.com* composer-proxy https://packagist.composer-proxy.org laravel-china https://packagist.laravel-china.org 1234567$ composer repo:usePlease select your favorite registry (defaults to composer) [0] composer [1] phpcomposer [2] composer-proxy [3] laravel-china &gt; 1$ composer repo:use phpcomposer","link":"/2018/10/27/coding/php/php_001_composer/"},{"title":"PHP[001]:INSTALL","text":"ubuntu ubuntu 中软件的卸载方法： 1.apt方式安装：(相应的文件夹有相关的软件，先进入到软件的文件夹) 普通安装： sudo apt-get install 软件名 修复安装： sudo apt-get -f install 软件名 重新安装： sudo apt-get –rreinstall install 软件名 (一般是 .deb 格式)2.dpkg 方式： 1.普通安装：sudo dpkg -i package_name.deb=====================================如果软件的格式为 .rpm 格式包时，则1.先安装 alien 和 fakeroot 这两个工具， sudo apt-get install alien fakerootalien 把 .rpm 为 .deb 格式的文件 将 .rpm 格式的文件转为 同文件名的 .debfakeroot alien xx.rpm这样就可以按上面的方法安装了 apt 方式：a. 移除式卸载： apt-get remove 软件名b. 清除式卸载： apt-get –purge remove 软件名 (同时清除配置)c. 清除式卸载： apt-get –purge 软件名 (同时清除配置) dpkg 方式：a. 移除式卸载：sudo dpkg dpkg_nameb. 清除式卸载：sudo -P dpkg_name 查看已经安装的软件名称： dpkg -l 查找软件库中的软件apt-cache search 正则表达式或者aptitude search 软件包（部分）可以查看相关软件的名称 标志 i 表示已经安装 apt-cache search php7 12345678910111213141516./configure \\--prefix=/usr/local/php73 \\--exec-prefix=/usr/local/php73 \\--bindir=/usr/local/php73/bin \\--sbindir=/usr/local/php73/sbin \\--includedir=/usr/local/php73/include \\--libdir=/usr/local/php73/lib/php \\--mandir=/usr/local/php73/php/man \\--with-config-file-path=/usr/local/php73/etc \\--with-openssl \\--enable-mbstring \\--enable-fpmsudo make &amp;&amp; sudo make install 编译12345678# php7.1./configure --prefix=/usr/local/php71 --with-config-file-path=/usr/local/php71/etc --with-config-file-scan-dir=/usr/local/php71/conf.d --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-iconv-dir --with-freetype-dir=/usr/local/freetype --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-mbstring --with-mcrypt --enable-ftp --with-gd --enable-gd-native-ttf --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --with-gettext --disable-fileinfo --enable-intl --with-xsl --enable-maintainer-zts ./configure --with-php-config=/usr/local/php71/bin/php-config --with-readline# php7废弃的扩展# --with-mysql=mysqlndsudo make &amp;&amp; sudo make install 123456Warning! a PEAR user config file already exists from a previous PEAR installation at '/home/hanzhijie/.pearrc'. You may probably want to remove it.Wrote PEAR system config file at: /usr/local/php71/etc/pear.confYou may want to add: /usr/local/php71/lib/php to your php.ini include_path/mnt/c/Users/hzj/Desktop/boom/tmp/php-7.1.26/build/shtool install -c ext/phar/phar.phar /usr/local/php71/binln -s -f phar.phar /usr/local/php71/bin/pharInstalling PDO headers: /usr/local/php71/include/php/ext/pdo/ php7.31234567./configure --prefix=/usr/local/php73 --with-config-file-path=/usr/local/php73/etc --with-config-file-scan-dir=/usr/local/php73/conf.d --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-iconv-dir --with-freetype-dir=/usr/local/freetype --with-jpeg-dir --with-png-dir --with-zlib --with-libxml-dir=/usr --enable-xml --disable-rpath --enable-bcmath --enable-shmop --enable-sysvsem --enable-inline-optimization --with-curl --enable-mbregex --enable-mbstring --enable-ftp --with-gd --with-openssl --with-mhash --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --with-gettext --disable-fileinfo --enable-intl --with-xsl --with-kerberos --enable-sysvshm --enable-opcache --enable-libxml --with-bz2 --with-pear --with-pdo-sqlite --with-pcre-regex --with-libdir=lib64 --with-kerberos --enable-maintainer-zts ./configure --with-php-config=/usr/local/php73/bin/php-config --with-readline# php7.2废弃的扩展# --with-mcrypt --enable-gd-native-ttf 123456Warning! a PEAR user config file already exists from a previous PEAR installation at '/home/hanzhijie/.pearrc'. You may probably want to remove it.Wrote PEAR system config file at: /usr/local/php73/etc/pear.confYou may want to add: /usr/local/php73/lib/php to your php.ini include_path/mnt/c/Users/hzj/Desktop/boom/tmp/php-7.3.2/build/shtool install -c ext/phar/phar.phar /usr/local/php73/binln -s -f phar.phar /usr/local/php73/bin/pharInstalling PDO headers: /usr/local/php73/include/php/ext/pdo/ pthreads 安装1234567891011121314151617181920212223----------------------------------------------------------------------Libraries have been installed in: /mnt/c/Users/hzj/Desktop/boom/tmp/pthreads-master/modulesIf you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the `-LLIBDIR'flag during linking and do at least one of the following: - add LIBDIR to the `LD_LIBRARY_PATH' environment variable during execution - add LIBDIR to the `LD_RUN_PATH' environment variable during linking - use the `-Wl,--rpath -Wl,LIBDIR' linker flag - have your system administrator add LIBDIR to `/etc/ld.so.conf'See any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.----------------------------------------------------------------------Build complete.Don't forget to run 'make test'.Installing shared extensions: /usr/local/php73/lib/php/extensions/no-debug-zts-20180731/","link":"/2018/10/27/coding/php/php_001_%E5%AE%89%E8%A3%85/"},{"title":"PHP[002]:Standard","text":"psr","link":"/2018/10/27/coding/php/php_002_Standard/"},{"title":"PHP[002]:More PHP","text":"more php 虽然 wsl 可以模拟 linux 环境，但是请不要用 wsl 作为一种开发环境进行使用，而是作为一个工具系统 一致的环境 linux 版本 &amp; 配置 nginx 版本 &amp; 配置 mysql 版本 &amp; 配置 php 版本 &amp; 配置 composer 版本（这个也很重要） 一致的环境体现在三个方面，系统（linux/win)是否一直，依赖软件(nginx/mysql/other)是否一致，解析器（php）版本及该使用该解析器所做的软件（composer）版本是否一致。 123composer updatecomposer installcomposer update --no-dev Deployer 一个环境部署工具 about use1234567if ($needBacktrace != 0) { ob_start(); debug_print_backtrace($needBacktrace === 2 ? 1 : 0); $trace = ob_get_contents(); ob_end_clean(); $msg = $msg . '## trace:' . $trace;}","link":"/2018/10/27/coding/php/php_002_%E7%8E%AF%E5%A2%83%E6%80%AA%E8%B0%88/"},{"title":"PHP[004]:laravel 5.5","text":"123456789101112131415运行 Laravel MixLaravel Mix 一款前端任务自动化管理工具，使用了工作流的模式对制定好的任务依次执行。Mix 提供了简洁流畅的 API，让你能够为你的 Laravel 应用定义 Webpack 编译任务。Mix 支持许多常见的 CSS 与 JavaScript 预处理器，通过简单的调用，你可以轻松地管理前端资源。使用 Mix 很简单，首先你需要使用以下命令安装 npm 依赖即可。我们将使用 Yarn 来安装依赖，在这之前，因为国内的网络原因，我们还需为 Yarn 配置安装加速：$ yarn config set registry https://registry.npm.taobao.org使用 Yarn 安装依赖：$ yarn install安装成功后，运行以下命令即可：$ npm run watch-pollwatch-poll 会在你的终端里持续运行，监控 resources 文件夹下的资源文件是否有发生改变。在 watch-poll 命令运行的情况下，一旦资源文件发生变化，Webpack 会自动重新编译。注意：在后面的课程中，我们需要保证 npm run watch-poll 一直处在执行状态中。 12345677. 线上部署须知在开发环境中，我们为了测试方便，直接在命令行里调用 artisan horizon 进行队列监控。然而在生产环境中，我们需要配置一个进程管理工具来监控 artisan horizon 命令的执行，以便在其意外退出时自动重启。当服务器部署新代码时，需要终止当前 Horizon 主进程，然后通过进程管理工具来重启，从而使用最新的代码。简而言之，生产环境下使用队列需要注意以下两个问题：使用 Supervisor 进程工具进行管理，配置和使用请参照 文档 进行配置；每一次部署代码时，需 artisan horizon:terminate 然后再 artisan horizon 重新加载代码。","link":"/2018/10/27/coding/php/php_004_laravel/"},{"title":"PHP[006]:单进程多任务并行处理实现","text":"12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php$i = 1;$str = &lt;&lt;&lt;EOF&lt;?php\\$logName = basename(__FILE__);\\$i =1;\\$result = '';\\$result .= &quot;初始: &quot; . memory_get_usage() . &quot;B\\n&quot;;\\$result .= &quot;使用: &quot; . memory_get_usage() . &quot;B\\n&quot;;while(\\$i--){ sleep(10); \\$result .= &quot;释放: &quot; . memory_get_usage() . &quot;B\\n&quot;; \\$result .= &quot;峰值: &quot; . memory_get_peak_usage() . &quot;B\\n&quot;; file_put_contents(__DIR__.'/'.\\$logName.'.log',time().PHP_EOL.\\$result,FILE_APPEND);}EOF;$file_name = [];while ($i &lt; 10) { $file_name[] = 'timeEvent' . $i . '.php'; file_put_contents(__DIR__ . '/' . 'timeEvent' . $i . '.php', $str); $i++;}var_dump($file_name);foreach ($file_name as $name) { $strRun = 'php ' . __DIR__ . '/' . $name . ' &amp;'; $waitClose = pclose(popen($strRun, 'r')); echo time() . PHP_EOL;}$result = '';$result .= &quot;初始: &quot; . memory_get_usage() . &quot;B\\n&quot;;$result .= &quot;使用: &quot; . memory_get_usage() . &quot;B\\n&quot;;$result .= &quot;释放: &quot; . memory_get_usage() . &quot;B\\n&quot;;$result .= &quot;峰值: &quot; . memory_get_peak_usage() . &quot;B\\n&quot;;","link":"/2018/10/27/coding/php/php_006_%E5%8D%95%E8%BF%9B%E7%A8%8B%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C%E5%AE%9E%E7%8E%B0/"},{"title":"PHP[005]:function","text":"12345&lt;?phpob_start();debug_print_backtrace($needBacktrace === 2 ? 1 : 0);$trace = ob_get_contents();ob_end_clean(); 1234567&lt;?phpdefine('PROJECT_START', microtime(true));$message = [ 'memory_used' =&gt; memory_get_usage(), 'running_time' =&gt; (microtime(true) - PROJECT_START), 'action_name' =&gt; $actionName];","link":"/2018/10/27/coding/php/php_005_function/"},{"title":"PHP[003]:symfony","text":"1234567891011composer create-project symfony/skeleton my-projectcd my-projectcomposer require symfony/web-server-bundle --devcomposer require annotations # 注释分析composer require symfony/orm-packcomposer require symfony/maker-bundle --devcomposer require --dev symfony/profiler-pack # 开发调试工具composer require sensio/framework-extra-bundle # 自动查询composer require doctrine/doctrine-fixtures-bundle --dev # 测试数据composer require symfony/messengercomposer require symfony/serializer-pack #待定 起步123456#symfony 提供两种项目 symfony/skeleton 是轻量的， symfony/website-skeleton 是比较重的，具有较全的web功能#选择轻量的面向 api 和 console 的 symfony/skeleton 起步#使用 composer 安装symfonycomposer create-project symfony/skeleton my-project#使用 symfony-cli 安装symfonysymfony new xz_symfony symfonyConfiguring a Web ServersymfonyRequirements for Running Symfony进入项目安装开发时使用的 web server 组件 12cd xz_symfonycomposer require symfony/web-server-bundle --dev 12345composer require annotations # 注释分析php bin/console debug:router # 查看所有的路由composer require symfony/twig-bundle # symfony 的模板引擎php bin/console debug:autowiring # 查看所有可以注入的服务 The Symfony MakerBundle 12composer require symfony/maker-bundle --dev # 引入 maker-bundlephp bin/console make:controller BrandNewController # 创建一个新的控制器 1php bin/console config:dump-reference framework 123456composer require symfony/orm-packcomposer require symfony/maker-bundle --devphp bin/console doctrine:database:createphp bin/console list doctrinephp bin/console make:entityphp bin/console make:migration 1234php bin/console doctrine:query:sql 'SELECT * FROM product'composer require sensio/framework-extra-bundle # 自动查询composer require doctrine/doctrine-fixtures-bundle --dev # 测试数据php bin/console doctrine:fixtures:load next 1234# 全局唯一id# fixtures 文件的生成位置php bin/console make:fixtures","link":"/2018/10/27/coding/php/php_003_symfony/"},{"title":"PHP[007]:ReflectionClass","text":"调用类私用方法123456789101112131415&lt;?phpclass Cat{ private function want($see) { echo $see.$see.$see.PHP_EOL; }}$reflector = new ReflectionClass(Cat::class);$instance = $reflector-&gt;newInstance();$method = $reflector-&gt;getmethod('want');$method-&gt;setAccessible(true);$result = $method-&gt;invoke($instance, 'eat food '); 实例化不可实例的类使用这个的原因是因为拆分老的业务代码中，有个一个 Aentity 依赖另一个 Bentity （在orm层中调用get_class），如果查询或者Bentity提供的创建方法会导致将其注册到 UnitOfWork 中，会导致最后的入库（虽然也有可能不入库），所以采用 ReflectionClass::newInstanceWithoutConstructor 实例化一个在 get_class 范围内等价的 entity ,并将其作为一个临时的参数对象代替 Bentity 维持代码的运作 1234567891011121314151617181920212223242526272829303132&lt;?phpfunction println(String $str){ echo($str.PHP_EOL);}class Dog{ protected $name; private function __construct($name = 'WangCai') { $this-&gt;name = $name; } public function setName($name) { $this-&gt;name = $name; } public function getName() { return $this-&gt;name; }}$reflector = new ReflectionClass(Dog::class);$dog = $reflector-&gt;newInstanceWithoutConstructor();$dog-&gt;setName('DeFu');$class = get_class($dog);println($class);println($dog-&gt;getName());","link":"/2018/10/27/coding/php/php_007_ReflectionClass/"},{"title":"PHP[008]:实现延迟触发器","text":"12345678910111213141516171819202122232425&lt;?php$timeManager = [];$timeMark = 0;$i = 1000;while ($i--) { $jobTime = (time() + mt_rand(0, 1000)); echo (1000 - $i) . '个任务 将于' . date('Y-m-d H:i:s', $jobTime) . '执行' . PHP_EOL; $timeManager[$jobTime][] = '$i 任务 ' . $i;}while (true) { ksort($timeManager); $timeMark = key($timeManager); if (count($timeManager) &gt; 0 &amp;&amp; $timeMark &lt; time()) { var_dump($timeMark); var_dump(date('Y-m-d H:i:s', $timeMark)); $job = $timeManager[$timeMark]; unset($timeManager[$timeMark]); #$job = array_shift($timeManager); } else { sleep(1); }}","link":"/2018/10/27/coding/php/php_008_%E5%BB%B6%E8%BF%9F%E8%A7%A6%E5%8F%91%E5%99%A8/"},{"title":"PHP[009]:爬虫","text":"php爬虫 12345678910# 异步 HTTP 客户端composer require clue/buzz-react# DomCrawler 的适配组件 CSS-selector composer require symfony/dom-crawlercomposer require symfony/css-selector# 异步处理文件composer require react/filesystem","link":"/2018/10/27/coding/php/php_009_%E7%88%AC%E8%99%AB/"},{"title":"PHP[010]:codeception","text":"codeception创建单元测试 12$.\\vendor\\bin\\codecept run g:test unit src/CouponAccountClient# Test was created in C:\\Users\\hzj\\Desktop\\xz\\xz_stub-client\\tests\\unit\\src\\CouponAccountClientTest.php 运行单元测试 123456789101112131415$ .\\vendor\\bin\\codecept run tests\\unit\\src\\CouponAccountClientTest.phpCodeception PHP Testing Framework v2.5.1Powered by PHPUnit 7.3.5 by Sebastian Bergmann and contributors.Running with seed:Unit Tests (1) -------------------------------------------------------------------------------------------------------------------------------------------+ CouponAccountClientTest: Some feature (0.03s)-------------------------------------------------------------------------------------------------------------------------------------------Time: 749 ms, Memory: 10.00MBOK (1 test, 0 assertions)","link":"/2018/10/27/coding/php/php_010_codeception/"},{"title":"PHP[011]:curl","text":"今天在研究了下 php curl cookie的使用 , 本來打算写一篇关于 php curl 的使用，主要是关于 cookie 的，但是 curl 在一定程度上相比于 socket 算是一个经过封装的扩展，所以写的过程中又引入了一个使用 socket 进行 http 请求的文章 PHP 支持 Daniel Stenberg 创建的 libcurl 库，能够连接通讯各种服务器、使用各种协议。libcurl 目前支持的协议有 http、https、ftp、gopher、telnet、dict、file、ldap。 libcurl 同时支持 HTTPS 证书、HTTP POST、HTTP PUT、 FTP 上传(也能通过 PHP 的 FTP 扩展完成)、HTTP 基于表单的上传、代理、cookies、用户名+密码的认证 curl 基础用法 12345$ch = curl_init();curl_setopt($ch,xxx,xxx);curl_setopt_array($ch,[]);curl_exec($ch);curl_close($ch); 使用socket进行http访问 （这一部分可以跳过，之后再看）这是一段使用 php socket 模拟 http get 请求的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?php/** * super socket client */define('GET', 'GET');define('POST', 'POST');define('sp', &quot;\\r\\n&quot;);$url = 'http://localhost:8080/';$url = 'https://www.xiaozhu.com/';$body = '';$protocol = 'HTTP/1.1';$urlInfo = parse_url($url);$host = $urlInfo['host'];$port = $urlInfo['port'] ?? '80';$headerArr = [ 'Host' =&gt; $host];$headerArr['User-Agent'] = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36';if (stristr($url, 'xiaozhu')) { $headerArr['connection'] = 'close';}$method = GET;$requestLine = $method . ' ' . $urlInfo['path'] . '' . '?' . ($urlInfo['query'] ?? '') . ' ' . $protocol;$header = '';foreach ($headerArr as $key =&gt; $value) { $header .= $header == '' ? ($key . ':' . $value) : (sp . $key . ':' . $value);}$requestHeader = $header . sp . sp;$requestInfo = $requestLine . sp . $requestHeader;$requestInfo .= $body;$fp = fsockopen($host, $port, $errno, $errStr);if (!$fp) { echo $errStr . '(' . $errno . ')'; return;}function readByFEof($fp){ $str = ''; while (!feof($fp)) { $result = fread($fp, 1024); $str .= $result; } return $str;}if (fwrite($fp, $requestInfo)) { $responseInfo = readByFEof($fp);}fclose($fp);echo $responseInfo; 这是一段使用 php socket 模拟 http get 请求的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** * super socket client */define('GET', 'GET');define('POST', 'POST');define('sp', &quot;\\r\\n&quot;);//$url = 'http://localhost:8080/';$url = 'http://www.xiaozhu.com/';$body = '';$protocol = 'HTTP/1.1';$urlInfo = parse_url($url);$host = $urlInfo['host'];$port = $urlInfo['port'] ?? '80';$headerArr = [ 'Host' =&gt; $host];$postData = ['username' =&gt; '发一个中文', 'age' =&gt; 22];$body = http_build_query($postData);$headerArr['User-Agent'] = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36';$headerArr['Content-Type'] = 'application/x-www-form-urlencoded';$headerArr['Content-Length'] = strlen($body);$headerArr['cookie'] = 'name=1417760419;';if (stristr($url, 'xiaozhu')) { $headerArr['connection'] = 'close';}$method = POST;$requestLine = $method . ' ' . $urlInfo['path'] . '' . '?' . ($urlInfo['query'] ?? '') . ' ' . $protocol;$header = '';foreach ($headerArr as $key =&gt; $value) { $header .= $header == '' ? ($key . ':' . $value) : (sp . $key . ':' . $value);}$requestHeader = $header . sp . sp;$requestInfo = $requestLine . sp . $requestHeader;$requestInfo .= $body;$fp = fsockopen($host, $port, $errno, $errStr);if (!$fp) { echo $errStr . '(' . $errno . ')'; return;}/** * PHP 的 feof() 函数用于检测是否已到达文件末尾 (eof)。如果文件指针到了 EOF 或者出错时则返回 TRUE，否则返回一个错误（包括 socket 超时），其它情况则返回 FALSE。 * while (!feof($fp)) 即当文件指针没有达到 End Of File，就循环读入数据直至读完。这是一个常见用法，我们使用fsockopen打开一个$fp来发送http头，请求后用feof判断是否读完来获取服务器响应的内容。 * 但是这使用feof时要特别注意一点，php手册上关于feof有这样一个说明： * Warning：如果服务器没有关闭由 fsockopen() 所打开的连接，feof() 会一直等待直到超时而返回 TRUE。默认的超时限制是 60 秒，可以使用 stream_set_timeout() 来改变这个值。 * 也就是一个打开的socket连接，没有在读完后关闭，feof会一直返回true直到超时。 */function readByFEof($fp){ $str = ''; while (!feof($fp)) { $result = fread($fp, 1024); $str .= $result; } return $str;}if (fwrite($fp, $requestInfo)) { $responseInfo = readByFEof($fp);}echo $responseInfo; curl 进行请求1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?php$url = 'http://localhost:8080/';$path = __DIR__ . '/tmp';$cookie_file = $path . '/cookie.txt';if (!file_exists($cookie_file)) { file_put_contents($cookie_file, '');}// init$ch = curl_init();// setcurl_setopt($ch, CURLOPT_URL, $url);curl_setopt($ch, CURLOPT_HEADER, 0);curl_setopt_array($ch, [ CURLOPT_URL =&gt; $url, CURLOPT_RETURNTRANSFER =&gt; true, CURLOPT_ENCODING =&gt; '', CURLOPT_MAXREDIRS =&gt; 10, CURLOPT_TIMEOUT =&gt; 60, CURLOPT_HTTP_VERSION =&gt; CURL_HTTP_VERSION_1_1, CURLOPT_CUSTOMREQUEST =&gt; 'POST', CURLOPT_COOKIEFILE =&gt; $cookie_file, CURLOPT_COOKIEJAR =&gt; $cookie_file,]);// $cookie = 'a=b;c=d;name=方世玉';// curl_setopt($ch, CURLOPT_COOKIE, $cookie);// exec$output = curl_exec($ch);if ($output === FALSE) { echo 'CURL Error:' . curl_error($ch);}// closecurl_close($ch);echo $output; 上面就是一个带有 cookie 的 http 请求，cookie 在 php-curl 的设置中有4种 （ 我才发现我用的这个主题不支持表格md mmp) CURLOPT_COOKIE 包含 cookie 数据的文件名，cookie 文件的格式可以是 Netscape 格式，或者只是纯 HTTP 头部风格，存入文件。如果文件名是空的，不会加载 cookie，但 cookie 的处理仍旧启用。 CURLOPT_COOKIEFILE 包含 cookie 数据的文件名，cookie 文件的格式可以是 Netscape 格式，或者只是纯 HTTP 头部风格，存入文件。如果文件名是空的，不会加载 cookie，但 cookie 的处理仍旧启用。 CURLOPT_COOKIEJAR 连接结束后，比如，调用 curl_close 后，保存 cookie 信息的文件。 | 还有一种方法就是在header中直接设置 正常使用的话 CURLOPT_COOKIEFILE , CURLOPT_COOKIEJAR 这两个设置使用起来很方便如果使用其他的方式的话，那么需要自行处理 cookie 的存储 在使用 CURLOPT_COOKIEJAR 发现了一个有趣的事，相比与日常使用的浏览器（谷歌，edge等），我们使用脚本进行请求cookie请求会将cookie保存起来并不会过期这就会导致尽管cookie已经过期了但是仍然传送了过去，其实从某些方面来说也可以把这个作为一个辨别是否是爬虫的手段（手动滑稽） 在使用 socket 进行 http 模拟的时候很明显就能感觉到是字符串在通信，传过去的和传回来的都是按格式规整好的字符串 发送 12345678POST /? HTTP/1.1Host:localhostUser-Agent:Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/35.0.1916.153 Safari/537.36Content-Type:application/x-www-form-urlencodedContent-Length:61cookie:name=1417760419;username=%E5%8F%91%E4%B8%80%E4%B8%AA%E4%B8%AD%E6%96%87&amp;age=22 返回 123456789101112HTTP/1.1 200 OKHost: localhostDate: Sun, 10 Feb 2019 23:15:08 +0800Connection: closeX-Powered-By: PHP/7.2.10-0ubuntu0.18.04.1Set-Cookie: mc1549811708=my+cookie+valueSet-Cookie: mc=my+cookie+value; expires=Sun, 10-Feb-2019 15:15:07 GMT; Max-Age=0Content-type: text/html; charset=UTF-8array ( ....//太多了省略其实也就是一堆字符串) 很容易看到一些关于 http 协议的参数，其中我在测试我们公司的主站时由于公司的服务器并没有主动断开 socket ，而我是用的 feof 读取返回值就导致程序一直等啊等，这一点我没有细做调试，所以也不太清楚是出在 nginx 上还是 php， 但是确实是可以让客户端和服务端建立长久的无用链接如果在客户端设置 Connection: close，也可以解决这种问题，而这种问题出现的源头是http1.1支持相关网络请求相关的实现，有兴趣的同学可以自行研究一下（手动狗头）","link":"/2018/10/27/coding/php/php_011_curl/"},{"title":"PHP[012]:TypeCode","text":"如何利用php严格模式写出理想的代码 php限定类型 123456789function returnIntByBool(bool $param):int{ if($param){ $result = 1; } else { $result = 2; } return $result;} php严格模式开启 1declare (strict_types = 1); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?phpdeclare (strict_types = 1);function returnArr($param) : array{ if ($param) { return []; }}try { var_dump(returnArr(1));} catch (\\Throwable $e) { echo ($e-&gt;getMessage());}try { var_dump(returnArr(0));} catch (\\Throwable $e) { echo ($e-&gt;getMessage() . PHP_EOL);}function returnArrByBoolean(bool $param) : array{ if ($param) { return []; }}try { var_dump(returnArrByBoolean(1));} catch (\\Throwable $e) { echo ($e-&gt;getMessage() . PHP_EOL);}try { var_dump(returnArrByBoolean(true));} catch (\\Throwable $e) { echo ($e-&gt;getMessage() . PHP_EOL);}function returnArrayByBooleanUseFormat(bool $param) : array{ $result = []; if ($param) { $result = ['param' =&gt; true]; } return $result;}try { var_dump(returnArrayByBooleanUseFormat(true));} catch (\\Throwable $e) { echo ($e-&gt;getMessage() . PHP_EOL);}try { var_dump(returnArrayByBooleanUseFormat(false));} catch (\\Throwable $e) { echo ($e-&gt;getMessage() . PHP_EOL);}","link":"/2018/10/27/coding/php/php_012_typeCode/"},{"title":"PHP[013]:fp","text":"12345678910111213141516&lt;?phpfunction add(...$ints){ return $func = function (...$int) use (&amp;$func, &amp;$ints) { if (count($int) === 0) { return array_sum($ints); } else { $ints = array_merge($int, $ints); return $func; } };}$r = add(1, 2, 3)(4)(5)(1, 2, 3, 4, 5)();echo '结果:' . $r;","link":"/2019/03/18/coding/php/php_013_fp/"},{"title":"PHP[014]:IOC(依赖反转控制容器)","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;?php/** * @author * ioc */class Container{ protected $binds; protected $instances; public function bind($abstract, $concrete) { if ($concrete instanceof Closure) { $this-&gt;binds[$abstract] = $concrete; } else { $this-&gt;instances[$abstract] = $concrete; } } public function make($abstract, $parameters = []) { if (isset($this-&gt;instances[$abstract])) { return $this-&gt;instances[$abstract]; } array_unshift($parameters, $this); return call_user_func_array($this-&gt;binds[$abstract], $parameters); }}class Superman{ protected $module; public function __construct(SuperModuleInterface $module) { $this-&gt;module = $module; }}class man{ public $age; public function __construct() { $this-&gt;age = 10; }}interface SuperModuleInterface{ /** * 超能力激活方法 * * 任何一个超能力都得有该方法，并拥有一个参数 *@param array $target 针对目标，可以是一个或多个，自己或他人 */ public function activate(array $target);}/** * X-超能量 */class XPower implements SuperModuleInterface{ public function activate(array $target) { // 这只是个例子。。具体自行脑补 }}/** * 终极炸弹 （就这么俗） */class UltraBomb implements SuperModuleInterface{ public function activate(array $target) { // 这只是个例子。。具体自行脑补 }}// 创建一个容器（后面称作超级工厂）$container = new Container();// 向该 超级工厂 添加 超人 的生产脚本$container-&gt;bind('superman', function ($container, $moduleName) { return new Superman($container-&gt;make($moduleName));});// 向该 超级工厂 添加 超能力模组 的生产脚本$container-&gt;bind('xpower', function ($container) { return new XPower;});// 同上$container-&gt;bind('ultrabomb', function ($container) { return new UltraBomb;});$container-&gt;bind('man', null);var_dump($container);// ****************** 华丽丽的分割线 **********************// 开始启动生产$superman_1 = $container-&gt;make('superman', ['xpower']);$superman_2 = $container-&gt;make('superman', ['ultrabomb']);$superman_3 = $container-&gt;make('superman', ['xpower']);$superman_4 = $concrete-&gt;make('man');// ...随意添加var_dump($superman_1, $superman_2, $superman_3);","link":"/2019/03/18/coding/php/php_014_IOC/"},{"title":"PHP[015]:PHP Enum","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586&lt;?phpabstract class Enum{ protected $value; protected static $enumList = []; public function __construct($enum) { $enumClassName = get_called_class(); if (isset(self::$enumList[$enumClassName])) { $enumList = self::$enumList[$enumClassName]; } else { $objClass = new \\ReflectionClass($enumClassName); $enumList = $objClass-&gt;getConstants(); self::$enumList[$enumClassName] = $enumList; } if (!in_array($enum, $enumList, true)) { throw new Exception('Error Type'); } $this-&gt;value = $enum; } public function __set($name, $value) { if ($name === 'value') { $enumClassName = get_called_class(); if (!in_array($value, self::$enumList[$enumClassName], true)) { throw new Exception('Error Value'); } $this-&gt;value = $value; } else { throw new Exception('Error Type'); } } public function __get($name) { if ($name === 'value') { return $this-&gt;value; } else { throw new Exception('Error Type'); } } public function __invoke($enum) { $enumClassName = get_called_class(); if (!in_array($enum, self::$enumList[$enumClassName], true)) { throw new Exception('Error Value'); } $this-&gt;value = $enum; }}class Day extends Enum{ const MON = 'MON'; const TUE = 'TUE'; const WED = 'WED'; const THU = 'THU'; const FRI = 'FRI'; const SAT = 'SAT'; const SUN = 'SUN ';}$day = new Day(Day::FRI);echo $day-&gt;value;try{ $day-&gt;value = Day::MON;} catch(Exception $e){ var_dump($e);}try{ $day-&gt;value = 'nihao';} catch(Exception $e){ var_dump($e-&gt;getMessage());}","link":"/2019/03/18/coding/php/php_015_Enum/"},{"title":"PHP[016]:PHP 对象数组","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phpclass Container implements ArrayAccess{ private $className = ''; private $s = array(); public function __construct($className) { if (!class_exists($className)) { throw new Exception('class is not found'); } $this-&gt;className = $className; } public function offsetExists($key) { echo &quot;you're trying to check if something exist&quot; . PHP_EOL; return array_key_exists($key, $this-&gt;s); } public function offsetGet($key) { echo &quot;you're trying to get something&quot; . PHP_EOL; return isset($this-&gt;s[$key]) ? $this-&gt;s[$key] : ''; } public function offsetSet($key, $value) { echo &quot;you're trying to set something&quot; . PHP_EOL; var_dump($value,$this-&gt;className); if ($value instanceof $this-&gt;className) { $this-&gt;s[$key] = $value; } else { throw new Exception('非法类型'); } } public function offsetUnset($key) { echo &quot;you're trying to unset something&quot; . PHP_EOL; unset($this-&gt;s[$key]); }}class cat{ public $name = 'nihao';}$c = new Container(Cat::class);$nihao = new Cat();try { $c['asda'] = $nihao; $c['name'] = 'ben'; // echo $c['name'] . PHP_EOL; // echo empty($c['age']) . PHP_EOL; // unset($c['name']); // echo empty($c['name']);} catch (Exception $E) { echo $E-&gt;getMessage(); echo $E-&gt;getLine();}var_dump($c);function f(array $peole){}","link":"/2019/03/18/coding/php/php_016_ObjArr/"},{"title":"PHP[018]:BitMap","text":"BitMap算法 12345678910111213141516171819202122232425&lt;?php$redisHost = '127.0.0.1';$redisPassWord = '';$redisPort = 6379;$redis = new \\Redis();$redis-&gt;connect($redisHost, $redisPort);$redis-&gt;setOption(\\Redis::OPT_READ_TIMEOUT, -1);$redisPassWord &amp;&amp; $redis-&gt;auth($redisPassWord);$cacheKey = 'asdhasdhsjahdjahdjkahs';$maxOffSet = 4294967296;$redis-&gt;setBit($cacheKey, 7, 0);// 高危。。。 如果值很小调用get 没有问题，如果值很大，则会出现没有反应的情况$result = $redis-&gt;get($cacheKey);$result = $redis-&gt;getbit($cacheKey, 13000);$start = microtime(true);sleep(1);echo (microtime(true) - $start) . PHP_EOL;$start = microtime(true);$result = $redis-&gt;bitCount($cacheKey);echo (microtime(true) - $start) . PHP_EOL;","link":"/2019/03/19/coding/php/php_018_BitMap/"},{"title":"PHP[017]:事件监听","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109&lt;?phpclass Event{ protected static $listens = array(); public static function listen($event, $callback, $once = false) { if (!is_callable($callback)) return false; self::$listens[$event][] = array('callback' =&gt; $callback, 'once' =&gt; $once); return true; } public static function one($event, $callback) { return self::listen($event, $callback, true); } public static function remove($event, $index = null) { if (is_null($index)) unset(self::$listens[$event]); else unset(self::$listens[$event][$index]); } public static function trigger() { if (!func_num_args()) return; $args = func_get_args(); $event = array_shift($args); if (!isset(self::$listens[$event])) return false; foreach ((array)self::$listens[$event] as $index =&gt; $listen) { $callback = $listen['callback']; $listen['once'] &amp;&amp; self::remove($event, $index); call_user_func_array($callback, $args); } }}// 增加监听walk事件 Event::listen('walk', function () { echo &quot;I am walking...n&quot;;}); // 增加监听walk一次性事件 Event::listen('walk', function () { echo &quot;I am listening...n&quot;;}, true); // 触发walk事件 Event::trigger('walk'); /* I am walking... I am listening... */Event::trigger('walk'); /* I am walking... */Event::one('say', function ($name = '') { echo &quot;I am {$name}n&quot;;});Event::trigger('say', 'deeka'); // 输出 I am deeka Event::trigger('say', 'deeka'); // not run class Foo{ public function bar() { echo &quot;Foo::bar() is calledn&quot;; } public function test() { echo &quot;Foo::foo() is called, agrs:&quot; . json_encode(func_get_args()) . &quot;n&quot;; }}$foo = new Foo;Event::listen('bar', array($foo, 'bar'));Event::trigger('bar');Event::listen('test', array($foo, 'test'));Event::trigger('test', 1, 2, 3);class Bar{ public static function foo() { echo &quot;Bar::foo() is calledn&quot;; }}Event::listen('bar1', array('Bar', 'foo'));Event::trigger('bar1');Event::listen('bar2', 'Bar::foo');Event::trigger('bar2');function bar(){ echo &quot;bar() is calledn&quot;;}Event::listen('bar3', 'bar');Event::trigger('bar3');","link":"/2019/03/18/coding/php/php_017_EventLister/"},{"title":"PHP[018]:RabbitMq","text":"rabbitMqexchange type 作用 fanout 绑定即 接收 direct 绑定并匹配符合时 接收 topic 绑定并模糊匹配符合时接收 headers 绑定并匹配headers规则时接收 exchange 和 exchange 是多对多的关系 exchange 和 queue 也是多对多的关系 树挪死，人挪活 mq 的具体使用还是看场景，从业务严格的程度来说 direct 和 headers 都是比较不错的交换机类型，尽管书本上说 headers 比 topic 慢，但是 headers 的扩展性和可读性在某些业务场景下比 topic 要好很多。 毕竟一天 8000 订单 ，按照一个订单的生命周期可以发送 create,pay,confirm,waitcheckin,checkin 这些事件，且每个单子都可以发出这些事件，一天不过 8000*5 = 40000。是一个比较可控的范围 用 headers 表示一个订单的 bookfrom 和 lodgeUnitType 是比较容易的 12345$headers = [ 'actionType'=&gt;'xxx', 'bookFrom'=&gt;'xxxxx', 'lodgeUnit'=&gt;'xxx',]; 如果用 topic 表示的话，就变得丑陋很多 12&lt;?php$topoc = &quot;actionType:{$actionType};bookFrom:{$bookFrom};lodgeUnitType:{$lodgeUnitType}&quot;; 并且规则的书写也不如 headers 来的直接，明确。","link":"/2019/03/19/coding/php/php_019_RabbitMq/"},{"title":"PHP[020]:--with-php-config","text":"1configure: WARNING: unrecognized options: --with-php-config 原因：不应该在php源码根目录执行编译命令 例如需要安装readline扩展，应执行以下步骤 12345# 进入对应的php扩展源码目录cd ext/readline# 运行phpize，该命令会生成./configurexxx/xxx/xxx/xxx/phpize./configure --with-readline","link":"/2020/01/15/coding/php/php_020_php-config/"},{"title":"php[021]:关于phpini加载相对路径(php源码)","text":"起因：之前曾编译了一份php，在目录xxx.xxx.xx/下，由于文件夹名字冗余信息过度，该改名为xxx.xx/改名后运行执行php发现扩展没有被加载，执行php –ini 发现php.ini的加载路径为原来安装时的绝对路径并且为固定值 php编译安装默认设置php.ini的路径为PREFIX/lib即安装路径下的lib目录，也可以使用--with-config-file-path参数指定一个新的路径，这里测试一个指定的相对路径 1./configure --prefix=/mnt/d/WorkSpace/hzj/php-src-p/php7.4.1output --with-config-file-path=&quot;../&quot; 编译完成后在/mnt/d/WorkSpace/hzj/php-src-p/php7.4.1output 中创建一个php.ini，看是否可以加载 当目录为/mnt/d/WorkSpace/hzj/php-src-p/php7.4.1output/bin/php时，可以加载php.ini,其他目录则不可，所以说明两点，第一点是编写的相对路径生效了，第二点，生效的相对路径是对执行目录而言，而不是对执行文件而言。 12345h@Happy:/mnt/d/WorkSpace/hzj/php-src-p/php7.4.1output/bin$ ./php --iniConfiguration File (php.ini) Path: ../Loaded Configuration File: /mnt/d/WorkSpace/hzj/php-src-p/php7.4.1output/php.iniScan for additional .ini files in: (none)Additional .ini files parsed: (none) 这里开始查询源码文件夹下的的代码,首先搜索关键字符串Configuration File (php.ini) Path查找到sapi\\cli\\php_cli.c文件中 12345zend_printf(&quot;Configuration File (php.ini) Path: %s\\n&quot;, PHP_CONFIG_FILE_PATH);zend_printf(&quot;Loaded Configuration File: %s\\n&quot;, php_ini_opened_path ? php_ini_opened_path : &quot;(none)&quot;);zend_printf(&quot;Scan for additional .ini files in: %s\\n&quot;, php_ini_scanned_path ? php_ini_scanned_path : &quot;(none)&quot;);zend_printf(&quot;Additional .ini files parsed: %s\\n&quot;, php_ini_scanned_files ? php_ini_scanned_files : &quot;(none)&quot;);break; 查找变量PHP_CONFIG_FILE_PATH在main\\build-defs.h 1234#define PHP_SYSCONFDIR &quot;/mnt/d/WorkSpace/hzj/php-src-p/php7.4.1output/etc&quot;#define PHP_LOCALSTATEDIR &quot;/mnt/d/WorkSpace/hzj/php-src-p/php7.4.1output/var&quot;#define PHP_CONFIG_FILE_PATH &quot;../&quot;#define PHP_CONFIG_FILE_SCAN_DIR &quot;&quot; 可见该文件为./configure生成的的相关宏，由于实及加载为php.ini，所以查询变量php_ini_opened_path php_cli.c中 12345PHPAPI extern char *php_ini_opened_path;PHPAPI extern char *php_ini_scanned_path;PHPAPI extern char *php_ini_scanned_files; php_ini.c 1PHPAPI char *php_ini_opened_path=NULL; php_ini.c 1234567891011121314151617181920if (fp) { zend_file_handle fh; zend_stream_init_fp(&amp;fh, fp, filename); RESET_ACTIVE_INI_HASH(); zend_parse_ini_file(&amp;fh, 1, ZEND_INI_SCANNER_NORMAL, (zend_ini_parser_cb_t) php_ini_parser_cb, &amp;configuration_hash); { zval tmp; ZVAL_NEW_STR(&amp;tmp, zend_string_init(fh.filename, strlen(fh.filename), 1)); zend_hash_str_update(&amp;configuration_hash, &quot;cfg_file_path&quot;, sizeof(&quot;cfg_file_path&quot;)-1, &amp;tmp); if (opened_path) { zend_string_release_ex(opened_path, 0); } else { efree((char *)fh.filename); } php_ini_opened_path = zend_strndup(Z_STRVAL(tmp), Z_STRLEN(tmp)); }} 此时已将追到了赋值所在 网上找了了一份获取文件执行路径的代码 123456789101112131415161718192021#include &lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;unistd.h&gt;int main(){ char szBuf[128]; char szPath[128]; memset(szBuf, 0x00, sizeof( szBuf)); memset( szPath, 0x00, sizeof(szPath)); getcwd(szBuf, sizeof(szBuf)-1); printf(&quot;buf:%s\\n&quot;, szBuf); int ret = readlink(&quot;/proc/self/exe&quot;, szPath, sizeof(szPath)-1 ); printf(&quot;ret:%d\\n&quot;, ret); printf(&quot;path:%s\\n&quot;, szPath); return 0;} 下一步尝试替换此处，使的php可以加载安装目录下相对路径中的php.ini","link":"/2020/01/20/coding/php/php_021_src-phpini/"},{"title":"php[022]re2c","text":"re2c 测试运行示例 123456$ ./integer 1024decimal$ ./integer sdaerror$ ./integer 0b10binary re2c Re2c 是一个免费的开源词典生成器，适用于 C 和C++。其主要目标是生成与仔细优化的手写代码的速度相匹配或超过速度的快速词典。Re2c 使用有限状态机的直接编码，而不是表驱动的方法，并优化生成的代码。re2c 的另一个显著功能是异常灵活的用户界面：re2c 将接口代码的定义留给用户，而不是假设一个固定的程序模板。这为用户提供了为特定环境和输入模型自定义 lexer 的自由。Re2c 支持使用 POSIX 或最左侧贪婪语义的快速和轻量级子匹配提取。Re2c被许多其他项目使用（如php），旨在完全向后兼容。另一方面，它是一个研究项目和一个游乐场，在正式语法和自动机领域开发新的算法 re2c运行来源参考php源码学习d10 词法分析 https://github.com/skvadrik/re2c 安装 123456$git clone https://github.com/skvadrik/re2c.git$cd re2c$./autogen.sh$./configure $ make$ make install re2ctest.l 12345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;enum num_t { ERR, BIN, OCT, DEC, HEX};static num_t lex(const char *YYCURSOR){ const char *YYMARKER; /*!re2c re2c:define:YYCTYPE = char; re2c:yyfill:enable = 0; end = &quot;\\x00&quot;; bin = '0b'[01]+; oct = &quot;0&quot;[0-7]*; dec = [1-9][0-9]*; hex = '0x'[0-9a-fA-F]+; * {return ERR;} bin end {return BIN;} oct end {return OCT;} dec end {return DEC;} hex end {return HEX;} */}int main(int argc ,char **argv){ for(int i = 1; i&lt; argc; ++i) { switch (lex(argv[i])) { case ERR: printf(&quot;error\\n&quot;); break; case BIN: printf(&quot;binary\\n&quot;); break; case OCT: printf(&quot;octal\\n&quot;); break; case DEC: printf(&quot;decimal\\n&quot;); break; case HEX: printf(&quot;hexadecimal\\n&quot;); break; } }} re2c转换+g++编译 1re2c re2ctest.l -o re2ctest.c &amp;&amp; g++ re2ctest.c -o re2ctest re2ctest 123456$ ./integer 1024decimal$ ./integer sdaerror$ ./integer 0b10binary 查看re2ctest.c 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182/* Generated by re2c 1.3 on Mon Jan 20 20:53:54 2020 */#line 1 &quot;integer.l&quot;#include &lt;stdio.h&gt;enum num_t { ERR, BIN, OCT, DEC, HEX};static num_t lex(const char *YYCURSOR){ const char *YYMARKER; #line 10 &quot;integer.c&quot;{ char yych; yych = *YYCURSOR; switch (yych) { case '0': goto yy4; case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': goto yy5; default: goto yy2; }yy2: ++YYCURSOR;yy3:#line 14 &quot;integer.l&quot; {return ERR;}#line 32 &quot;integer.c&quot;yy4: yych = *(YYMARKER = ++YYCURSOR); switch (yych) { case 0x00: goto yy6; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': goto yy8; case 'B': case 'b': goto yy11; case 'X': case 'x': goto yy12; default: goto yy3; }yy5: yych = *(YYMARKER = ++YYCURSOR); switch (yych) { case 0x00: goto yy13; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': goto yy15; default: goto yy3; }yy6: ++YYCURSOR;#line 16 &quot;integer.l&quot; {return OCT;}#line 71 &quot;integer.c&quot;yy8: yych = *++YYCURSOR; switch (yych) { case 0x00: goto yy6; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': goto yy8; default: goto yy10; }yy10: YYCURSOR = YYMARKER; goto yy3;yy11: yych = *++YYCURSOR; if (yych &lt;= 0x00) goto yy10; goto yy18;yy12: yych = *++YYCURSOR; if (yych &lt;= 0x00) goto yy10; goto yy20;yy13: ++YYCURSOR;#line 17 &quot;integer.l&quot; {return DEC;}#line 101 &quot;integer.c&quot;yy15: yych = *++YYCURSOR; switch (yych) { case 0x00: goto yy13; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': goto yy15; default: goto yy10; }yy17: yych = *++YYCURSOR;yy18: switch (yych) { case 0x00: goto yy21; case '0': case '1': goto yy17; default: goto yy10; }yy19: yych = *++YYCURSOR;yy20: switch (yych) { case 0x00: goto yy23; case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': goto yy19; default: goto yy10; }yy21: ++YYCURSOR;#line 15 &quot;integer.l&quot; {return BIN;}#line 160 &quot;integer.c&quot;yy23: ++YYCURSOR;#line 18 &quot;integer.l&quot; {return HEX;}#line 165 &quot;integer.c&quot;}#line 19 &quot;integer.l&quot;}int main(int argc ,char **argv){ for(int i = 1; i&lt; argc; ++i) { switch (lex(argv[i])) { case ERR: printf(&quot;error\\n&quot;); break; case BIN: printf(&quot;binary\\n&quot;); break; case OCT: printf(&quot;octal\\n&quot;); break; case DEC: printf(&quot;decimal\\n&quot;); break; case HEX: printf(&quot;hexadecimal\\n&quot;); break; } }}","link":"/2020/01/20/coding/php/php_022_re2c/"},{"title":"php[023]bison--php使用的的词法分析器","text":"bison Bison 是一个通用解析器生成器，用于将无上下文的带注的语法转换为使用LALR（1） 解析器表的确定性 LR 或广义 LR （GLR） 解析器。作为实验功能，Bison 还可以生成IELR（1） 或规范 LR（1） 解析器表。精通 Bison 后，您可以使用它开发各种语言解析器，从简单的桌面计算器中使用的解析器到复杂的编程语言。 比森与Yacc是向上兼容的：所有正确编写的Yacc语法都应该与比森一起工作，没有变化。任何熟悉 Yacc 的人都应该能够使用比森，但没有什么麻烦。您需要精通 C 或C++编程才能使用 Bison。Java 也作为实验功能得到支持。 wget 下载步骤跳过 （ps:要下就下最新的） 123cd bison-3.5./configure --prefix=/home/h/bison/bison-outputmake &amp;&amp; make install 未完次日补充","link":"/2020/01/20/coding/php/php_023_bison/"},{"title":"php[024]生成器","text":"在 php 中有生成器这个东西。官方的描述是 12生成器提供了一种更容易的方法来实现简单的对象迭代，相比较定义类实现 Iterator 接口的方式，性能开销和复杂性大大降低。生成器允许你在 foreach 代码块中写代码来迭代一组数据而不需要在内存中创建一个数组, 那会使你的内存达到上限，或者会占据可观的处理时间。相反，你可以写一个生成器函数，就像一个普通的自定义函数一样, 和普通函数只返回一次不同的是, 生成器可以根据需要 yield 多次，以便生成需要迭代的值。 以及官方提供的改造range的代码。 1234567891011121314151617181920212223242526272829303132333435&lt;?phpfunction xrange($start, $limit, $step = 1) { if ($start &lt;= $limit) { if ($step &lt;= 0) { throw new LogicException('Step must be positive'); } for ($i = $start; $i &lt;= $limit; $i += $step) { yield $i; } } else { if ($step &gt;= 0) { throw new LogicException('Step must be negative'); } for ($i = $start; $i &gt;= $limit; $i += $step) { yield $i; } }}/* * 注意下面range()和xrange()输出的结果是一样的。 */echo 'Single digit odd numbers from range(): ';foreach (range(1, 9, 2) as $number) { echo &quot;$number &quot;;}echo &quot;\\n&quot;;echo 'Single digit odd numbers from xrange(): ';foreach (xrange(1, 9, 2) as $number) { echo &quot;$number &quot;;} 在我第一次看到的时候并没有思考为什么叫生成器这个东西。所以在一段时间内产生了迷惑。其实用官方编写的函数样本赋值给变量var_dump出来的结果会是一个对象，而其生成器的名字是因为其可以通过foreach在循环的每次成产出结果。所以可以看以下代码，来感受以下yield解决了什么问题。 12345678910111213141516171819202122232425262728293031323334353637&lt;?phpfunction xrange($start, $limit, $step = 1) { if ($start &lt;= $limit) { if ($step &lt;= 0) { throw new LogicException('Step must be positive'); } for ($i = $start; $i &lt;= $limit; $i += $step) { yield $i; } } else { if ($step &gt;= 0) { throw new LogicException('Step must be negative'); } for ($i = $start; $i &gt;= $limit; $i += $step) { yield $i; } }}$xarr = xrange(0,9,1);// 可以理解 $xarr 并不能用 一些数组切割的方式去做一些事情，因为其本身不是数组。foreach($xarr as $v){ echo $v;}// 所以上述整体是做了这个for($i = 0 ;$i&lt;10;$i++){ echo $i;}$arr = range(0,9,1);foreach($arr as $v){ echo $v;} 以及更好看的文件读取编码方式 123456789101112131415161718function readTxt(){ # code... $handle = fopen(&quot;./test.txt&quot;, 'rb'); while (feof($handle)===false) { # code... yield fgets($handle); } fclose($handle);}foreach (readTxt() as $key =&gt; $value) { # code... echo $value.'&lt;br /&gt;';} 所以在某种程度，我更倾向于，这是一个特殊写法的语法糖。可以在某些方式上以优雅的形式去实现代码。","link":"/2021/05/17/coding/php/php_024_%E7%94%9F%E6%88%90%E5%99%A8/"},{"title":"php[025]发布composer","text":"准备工作 拥有自己的github帐号 packagist.org授权github登录 创建包项目mkdir packname &amp;&amp; cd packname 创建composer.json文件手动创建 || composer init 创建git开始写自己的类库提交git12git add -A git commit -m 'first commit' 设置包版本1git tag v0.0.1 设置git仓库地址，然后上传123git branch -M maingit remote add origin 仓库地址git push -u origin main Submit package输入git仓库地址Check，然后Submit，至此发布成功！otherhttps://packagist.org/关联git仓库地址成功后会自动设置Webhooks(钩子)，每次提交代码会自动更新到Packagist上没有自动设置的可以自己手动设置打开git仓库-&gt;settings-&gt;Webhooks-&gt;Add webhook三个参数Payload URL：https://packagist.org/api/github?username=自己的用户名Content type：application/jsonSecret：从packagist-&gt;profile里获取","link":"/2021/05/17/coding/php/php_025_composerforyou/"},{"title":"php[026]性能分析xhprof","text":"php 层次式性能分析器php官网xhprof介绍pecl_xhprof 目前xhprof有着比较新的更新，pecl显示是原来版本fork后的版本。不过一致到8都提供了支持。所以可以在开发测试环境使用来分析代码的运行状况 install 如果不能直接下载或许需要 sudo pecl install xhprof ，或者先进行 pecl 的更新 1pecl install xhprof 之后将extension=xhprof.so 加入对应的 php.ini（注意区分fpm和cli的ini配置是否相同） 接着可以配合已经浅封装的php代码进行分析https://github.com/phacility/xhprof 其中如果是web项目可以进行双入口控制，在另一个入口中引入原来的入口。这样对原有代码污染。 如新的 index.php 123456789101112131415161718&lt;?phpxhprof_enable(XHPROF_FLAGS_CPU + XHPROF_FLAGS_MEMORY);require __DIR__ . '/../ifang_php_forgelogin/phpapps/forgelogin/src/public/index.php';$xhprof_data = xhprof_disable();$XHPROF_ROOT = __DIR__;include_once $XHPROF_ROOT . &quot;/xhprof_lib/utils/xhprof_lib.php&quot;;include_once $XHPROF_ROOT . &quot;/xhprof_lib/utils/xhprof_runs.php&quot;;$xhprof_runs = new XHProfRuns_Default();$run_id = $xhprof_runs-&gt;save_run($xhprof_data, &quot;xhprof_testing&quot;);$str = &quot;http://localhost/xhprof/xhprof_html/index.php?run={$run_id}&amp;source=xhprof_testing\\n&quot;;file_put_contents(__DIR__.'/tmp.log',$str); 图形化显示依赖graphviz安装graphviz 12apt update apt install graphviz","link":"/2021/06/17/coding/php/php_026_xhprof/"},{"title":"php_parser","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?php$code = &lt;&lt;&lt;'CODE'&lt;?phpfunction test($foo){ var_dump($foo);}class Cat{ public int $a = 1; protected float $b = 2; public function __construct($a) { $this-&gt;a = $a; }}$cat = new Cat(1);$f = function () use ($cat){ echo $cat;};CODE;/** * 创建一个php7的语法解析器（Parser），在没有传入词法解析器（Lexer）的时候会创建一个默认的词法分析器 * 同时如果没有指定只使用php7的语法解析器，那么将会同时创建一个php7和一个php5的parser */$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7);try { /* @var $parser Multiple */ $ast = $parser-&gt;parse($code); /** * 解析时先使用[0]解析器，当解析存在报错时，会调用后续的解析器，直至等到一个完全没有解析错误的结果 * * 上面的都不重要 * */} catch (Error $error) { echo &quot;Parse error: {$error-&gt;getMessage()}\\n&quot;; return 1;}$dumper = new NodeDumper;echo $dumper-&gt;dump($ast) . &quot;\\n&quot;; 1$parser = (new ParserFactory)-&gt;create(ParserFactory::PREFER_PHP7); 创建一个php7的语法解析器（Parser），在没有传入词法解析器（Lexer）的时候会创建一个默认的词法分析器同时如果没有指定只使用php7的语法解析器，那么将会同时创建一个php7和一个php5的parser 默认lexer 1234public function create(int $kind, Lexer $lexer = null, array $parserOptions = []) : Parser { if (null === $lexer) { $lexer = new Lexer\\Emulative(); } 默认parser 1234case self::PREFER_PHP7: return new Parser\\Multiple([ new Parser\\Php7($lexer, $parserOptions), new Parser\\Php5($lexer, $parserOptions) ]); 解析时先使用[0]解析器，当解析存在报错时，会调用后续的解析器，直至等到一个完全没有解析错误的结果 12345678910111213141516171819public function parse(string $code, ErrorHandler $errorHandler = null) { if (null === $errorHandler) { $errorHandler = new ErrorHandler\\Throwing; } list($firstStmts, $firstError) = $this-&gt;tryParse($this-&gt;parsers[0], $errorHandler, $code); if ($firstError === null) { return $firstStmts; } for ($i = 1, $c = count($this-&gt;parsers); $i &lt; $c; ++$i) { list($stmts, $error) = $this-&gt;tryParse($this-&gt;parsers[$i], $errorHandler, $code); if ($error === null) { return $stmts; } } throw $firstError;} 上述都不重要 自己传入异常，当有错的时候抛出这个写法有点意思呀 这个项目用的是get_token_all研究卒","link":"/2021/06/11/coding/php/php_parser/"},{"title":"vscode_and_php","text":"最近一直用vscode 没怎么用phpstorm ，vscode 用的是PHP Intelephense，但是好多非核心得扩展都没有提示，所以用着并不是很舒服，打开phpstorm点击redis得提示能看到，这些提示是一个jar包里的php文件，https://github.com/JetBrains/phpstorm-stubs把需要的文件放在项目中即刻获得代码提示。（原理和laravel的ide_helper一样）","link":"/2020/04/01/coding/php/vscode_and_php/"},{"title":"2019_12_09_隐藏X-Powered-By:xxx","text":"php.ini 1expose_php = Off","link":"/2019/12/10/coding/php/z_2019_12_09%E6%9D%82%E8%B0%88/"},{"title":"PHP[OOP入门]PH01-面向对象基本语法","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day01-面向对象基本语法 为什么学习面向对象对象：此对非彼对象 对象就是普通的对象 学完面向对象之后我们的代码非常的紧凑和高雅 现在很多语言都是面向对象的 java c++ c# 面向过程和面向对象以前我们写的代码：是面向过程的 举例子： 谈个对象====结婚 盖房子 面向过程 打地基 买砖 盖房子 装修 娶媳妇 面向对象 创建打地基的对象 创建买砖对象买砖 包工头 装修工 自己来吧 万物皆对象，多个对象协同工作共同完成一个功能 如果面向过程是数学逻辑的映射，那么面向对象就是生活逻辑的映射 语法层面：封装、继承、多态 思想方面：学习面向对象语言最重要的就是思想的转变，语法其实没什么，人家规定怎么写我们就怎么写 类和对象生活角度 什么是类：人类（统称），都具有共同的属性和行为，是一个抽象的概念 人类 对象（刘翔） 汽车 你的奔驰 电脑 你桌子上面的电脑 官方解释： 类：对象的抽象 对象：类的具象 编码角度 （int） 在代码中，类就是一种数据类型，int没有占用空间类型，具体到某个变量才有空间类型，类比，我们的对象也是如此，类并没有空间，对象才有空间 类的简单使用属性和行为 类名命名规范 成员属性和成员方法 1、要以class关键字开始，问 class就是类的意思 2、类名 3、大括号里面定义这个类 4、成员变量定义都要以public开始，以分号结尾 5、成员方法就是以前的函数，以前函数怎么定义，现在还怎么定义 6、成员方法前面也可以加public，也可以不加，如果不加的话，默认就是public 7、类名：命名规范，大驼峰原则 happybirthday happyBirthday 小驼峰 HappyBirthday 大驼峰 创建对象三种方法 //创建对象第一种 //Person后面的小括号可加可不加 $xiang = new Person(); //echo $xiang; //不能使用这种方式打印 //var_dump($xiang); //创建对象第二种方法 通过对象创建另外一个对象 基本不用 $liu = new $xiang; //var_dump($liu); //创建对象第三种方法 后续经常使用的一种方式 $className = 'Person'; $liuXiang = new $className(); var_dump($liuXiang); 对象访问属性和方法 $fang-&gt;age; $fang-&gt;cook(); 构造方法和this关键字this:代表的是当前对象，在类里面访问自己的成员属性和成员方法的时候我们就要使用this 引入构造方法 __construct() 不传递参数构造方法 传递参数构造方法 在类里面要访问自己的成员属性和成员方法 访问控制修饰符public：公共的 在类的外部，可以通过对象直接访问这些成员属性 private：私有的 在类的外部，不可以通过对象直接访问这些成员属性 在类的内部，都可以通过this关键字来直接访问所有成员属性 间接访问私有成员变量 因为私有的成员属性，在类的外部不能直接访问，但是在类的内部可以直接访问，所以我们可以在类里面增加一个函数，通过该函数来间接访问这些私有的成员属性（封装性） 几个魔术方法魔术方法：在php中以 __开头的都是魔术方法 特点：系统在特定的时机自动调用的方法 __get(获取值) 触发时机：当外部访问私有的成员属性的时候自动调用这个方法 参数：属性名 __set(设置值) 触发时机：当外部设置私有的成员属性的时候自动调用这个方法 参数：属性名，值 __unset __isset __construct __destruct","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH01-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"title":"PHP[OOP入门]PH02-魔术方法、继承、类常量、静态属性和方法、自动加载","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day02-魔术方法、继承、类常量、静态属性和方法、自动加载 1、魔术方法 __get __set __construct：构造方法 __destruct：析构方法 触发时机：在这个对象被销毁的时候自动调用 在php中，不用内存管理，当脚本运行结束的时候，所有的空间全部销毁 弱类型 强类型 参数：没有参数 __unset:销毁一个变量 触发时机：当销毁私有成员属性的时候自动调用 参数：属性名 __isset：判断这个变量是否被设置过 触发时机：当在外部判断私有的成员属性是否被设置过时自动调用 参数：属性名 __invoke（了解） 触发时机：当将一个对象当作函数使用的时候自动调用 参数：当做函数的时候传递几个参数，这里就写几个参数 __toString（了解） 触发时机：当echo一个对象的时候自动调用 参数：没有参数 返回值：必须return一个字符串，这个字符串自己定制 __debugInfo（了解） 发现bug需要3秒钟，调试bug需要3个小时，dubug却需要一辈子 触发时机：通过var_dump来打印对象的时候自动调用 参数：没有参数 返回值：必须返回一个数组，该数组自己定制 __call 触发时机：当调用一个不存在的成员方法的时候自动调用 参数：函数名 由实参组成的一个数组 __callStatic（讲完静态方法时候再讲） 连贯操作 成员方法要返回$this 通过__call实现单字段查询 去处理特定的函数名，通过函数名得到字段名，根据参数得到字段值，然后拼接sql语句即可 2、继承 认识继承 生活上 体现在生物学中的继承 父类 子类 父类 子类 父类 子类 父类 子类 生物 动物 哺乳动物 人类 男人累 女人泪 从概念上来理解，生物是最大的 动物从生物衍生过来的，动物具有生物的特性，动物还有自己独有的特性，所以叫做动物 哺乳动物从动物衍生过来的，他不仅有动物的特性，其还有自己独有的特性，所以叫做哺乳动物 代码上 上面的特性就代表属性，属性最多的是男人累和女人泪，从属性方面来理解，是男人累大于人类，从属性方面来理解就是我们代码中的继承 基本概念 继承、派生 从代码上来理解，男人累继承自人类，人类继承自哺乳动物，继承的概念关注的是相同的属性 派生，其实继承和派生说的是同一个东西，只不过是从不同的角度来理解 父子类叫法 父类-》子类 基类-》派生类 单继承 单继承就是一个子类只能由一个父类，这种叫做单继承 php面向对象的语法是单继承，c++里面就是多继承 继承语法 基本语法 子类继承了父类，就拥有了父类的成员属性和成员方法 访问权限 类外 继承 public 公共的 可以 可以 private 私有的 不可以 不可以 protected 受保护的 不可以 可以 重写方法（重载） 重写作用 重写意思：当父类的方法子类继承过来之后，有时候这个方法并不太适合子类，这个时候我们就要在子类中重写这个方法 重写分两种： 完全重写 子类对象调用该方法调用的是重写后的方法，父类执行的还是之前的方法。 在父类的基础上增加一定的功能 通过parent关键字首先执行父类的方法，然后再增加自己的功能 parent关键字（普通方法、构造方法） 见代码8overwrite.php final关键字（最后的，最终的） final用来修饰class，代表这个类不能被继承 final用来修饰成员方法的时候代表这个方法不能被重写 重写中的方法权限修改 public 子类重写的时候权限还必须是public protected 子类重写的时候权限必须是public或者protected private protected public 后面的权限最大 重写的时候权限只能放大不能缩小 3、类常量 定义方式： 一般使用define在类外定义常量，使用const在类内定义常量 定义常量，前面不能加属性修饰符 调用方法 类外 类名::常量名 （$obj::常量名） 类内 self::常量名 self就是当前类名 ($this::常量名) 4、静态属性和静态方法 什么是静态属性和方法（static） 如果在成员属性或者成员方法前面加了static进行修饰，那么这个成员属性或者成员方法就不在属于某一个对象，而是属于整个类的 静态属性调用方法： 类外 类名::静态属性名 ($obj::静态属性名) 类内 self::静态属性名 ($this::静态属性名) 静态方法调用方法 类外 类名::静态方法名 ($obj::静态方法名，$obj-&gt;静态方法名) 类内 self::静态方法名 ($this::静态方法名，$this-&gt;静态方法名) 静态方法注意项 1、静态属性和静态方法前面可以加属性修饰符 2、静态属性和静态方法调用效率高 3、静态方法可以实现单例 4、静态方法中不能出现$this 5、自动加载(重点) 规则 在我们以后的工作中，一个类就是一个文件，文件名要和类名相同 __autoload 魔术方法：这个方法是唯一写在类外的方法 触发时机：当文件加载一个类的时候，并没有找到这个类，那么就会自动触发这个方法 参数：类名 目录（文件夹）结构 MVC:一种设计模式 model 数据模型 view 视图 controller 控制器 vendor 第三方库文件","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH02-%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E7%B1%BB%E5%B8%B8%E9%87%8F%E3%80%81%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E3%80%81%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD/"},{"title":"PHP[OOP入门]PH03-魔术方法、抽象类、接口、命名空间","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day03-魔术方法、抽象类、接口、命名空间 目录（文件夹）结构 文件夹名字小写，类名和文件名相同 单一入口 index.php?m=index&amp;a=test 通过url告诉我到底应该执行哪个控制器下面的哪个方法 IndexController类中 test方法 MVC:一种设计模式 model 数据模型 view 视图 controller 控制器 vendor 第三方库文件 1、魔术方法 __callStatic 触发时机：当调用不存在的静态方法的时候自动执行这个方法 参数：函数名 数组 【注】该方法必须是static的 serialize:序列化 将程序中的一个对象进行序列化，然后保存起来 unserialize:反序列化 __sleep（了解） 触发时机：当序列化一个对象的时候调用这个方法 没有参数，有返回值，返回你要序列化的属性，组成一个数组 __wakeup（了解） 触发时机：当反序列一个对象的时候调用 在这里可以做一些自己初始化的一些工作 __clone（了解） 触发时机：当clone一个对象的时候会自动调用 在这里你可以修改一些属性 2、函数、对象引用 call_user_func call_user_func([$xiang, 'eat'], 1000); call_user_func_array call_user_func_array([$xiang, 'eat'], [1000, 2000, 3000]); var_export $str = var_export($arr, true); 将一个数组变成生成数组的字符串保存起来 对象引用（了解） 变量引用：加上引用就是同一个变量（一级指针） 对象引用：不管加不加引用，都是同一个对象（二级指针） 3、抽象类 抽象类：就是普通的类在前面加上一个关键字 abstract,代表这个类是一个抽象类 【注】抽象类不能实例化对象 【注】抽象类存在的目的就是让子类继承并且实现其规定的抽象方法 【注】子类中必须实现抽象类中规定的抽象方法，一般情况下，抽象类中都有抽象方法 【注】如果抽象方法中有参数并且参数有默认值，那么子类实现的时候也要有参数和默认值 【注】抽象方法必须是public或者protected 【注】抽象类可以继承抽象类，但是子类必须实现所有的抽象方法 4、接口（抽象的抽象类）interface 接口：usb接口 代码中的接口： 【注】接口中的方法都是抽象方法，而且是public 实现接口使用implements 可以实现多个接口，中间使用逗号隔开 先继承父类再实现接口 接口可以继承接口，但是子类必须将所有的方法都给实现 接口中不能添加成员变量 5、多态（了解） 在php中，多态其实不明显，我们这个重写就是一种多态，相同的接口给不同的对象，得到的响应不同，这就是多态 6、trait(特性) php是一种单继承语言，不能使用多继承，trait就是模拟实现多继承的新特性 trait写法和类写法一模一样，只是将class变成了trait trait中可以添加成员属性，但是一般不加，一般只加成员方法 trait中的方法如果想让子类使用，必须是public trait不能被实例化，就是不能创建对象 trait可以嵌套trait 解决多个trait中方法名冲突问题：（了解） use Dun, Sword{ Dun::blood insteadof Sword; Dun::blood as blood1; Sword::blood as blood2; } 7、遍历对象 8、类型约束 function buy(Girl $girl); 9、匿名类（了解） 10、命名空间（namespace） 命名空间要结合自动加载实现MVC框架 命名空间可以解决同一文件中不能有相同的类名问题 命名空间一般都小写 第一个命名空间的前面不能有任何的代码 命名空间的范围是一直向下，直到下一个命名空间的开始 \\:根空间，没有写命名空间的都在根空间下， use hello\\Person; 使用命名空间下的类 use baby\\Person as SeLang; 给命名空间下的类起别名 子空间","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH03-%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB%E3%80%81%E6%8E%A5%E5%8F%A3%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"},{"title":"PHP[OOP入门]PH04-验证码类和分页类","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day04-验证码类和分页类 遍历对象 对象可以被当成数组来遍历，遍历的时候，键就是属性名，值就是属性值 类外 只能遍历public属性 类内 所有属性都能遍历出来 匿名类 $obj = new class { public $name; public $height; function say() { echo '100'; } }; 1、命名空间结合自动加载实现mvc 规则： 文件夹名都是小写 文件名和类名相同 命名空间名都是小写 文件夹名和命名空间名对应 model namespace model; model\\UserModel =&gt; model/UserModel.php UserModel.php GoodsModel.php view controller IndexController.php UserController.php vendor Tpl.php Model.php Code.php Image.php index.php 2、常量和有关函数(自己测试一下) __NAMESPACE__ 当前命名空间名 __CLASS__ 当前类名 __METHOD__ 当前方法名 instanceof 判断一个对象是否属于当前类 class_alias 给类起别名 class_exists 判断类是否存在 get_class_methods 得到类所有的方法 get_class_vars 得到类所有的属性 get_class 根据对象得到当前类名 interface_exists 判断接口是否存在 trait_exists 判断trait是否存在 method_exists 判断方法是否存在 property_exists 判断属性是否存在 3、验证码类 imagecreatetruecolor imagechar imagesetpixel imagearc imagecolorallocate imagefill imagepng 类如何写： 创建一个对象，调用对象的一个方法，立马显示出来验证码 $obj-&gt;outImage(); 如何设计这个类 //将这些属性设置为成员属性，方便类里面所有的方法使用 //宽 高 个数 类型（0--纯数字，1--纯字母，2--字母和数字混合）验证码字符串 图像资源 { public function outImage(); protected function drawChar(); } 4、分页类 上一页 下一页 首页 尾页 核心：得到page 得到url http://www.baidu.com:80/index.php?username=goudan&amp;password=123&amp;page=3 prev next first end $_SERVER REQUEST_URI 获取文件以及后面的请求字符串 SERVER_PORT 获取端口号 SERVER_NAME 获取主机名 REQUEST_SCHEME 获取协议 parse_url 解析url 重点关注里面的 path query这两个键 parse_str 将请求字符串转化为关联数组 http_build_query 将关联数组转化为请求字符串 分页类： 成员属性 $url $totalCount $totalPage $number $page 成员方法（public） first next prev end allPage limit","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH04-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%B1%BB%E5%92%8C%E5%88%86%E9%A1%B5%E7%B1%BB/"},{"title":"PHP[OOP入门]PH05-文件上传类、水印缩放类","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day05-文件上传类、水印缩放类 1、文件上传类 form表单注意事项： post enctype = 'multipart/form-data' &lt;input type='file' name='f'&gt; $_FILES['f'] 类设计： 成员属性 上传路径 允许的后缀 允许mime 允许的大小 是否启用随机名字 前缀 up_ water_ sf_ 错误号码 错误信息 //将下面的信息保存起来，方便其他的函数使用而已 原文件名 原文件后缀 原文件大小 原文件的mime 文件临时路径 成员方法 uploadFile($key) 上传错误： 官方错误：123467 自定义错误：-1 -2 -3 -4 -5 上传成功：0 错误信息： 2、水印缩放类(图像类) 100*100 50*50 20*80（图片会变形，不变形） 类的设计： 成员属性 保存路径 是否启用随机名字 保存格式 成员方法 水印（水印图片，源图片，位置， 透明度， 前缀） water_ 缩放（源图片， 宽度， 高度， 前缀） sf_ protected function kidOfImage($srcImg, $size, $imgInfo) { //传入新的尺寸，创建一个指定尺寸的图片 $newImg = imagecreatetruecolor($size['old_w'],$size['old_h']); //定义透明色 $otsc = imagecolortransparent($srcImg); if ($otsc &gt;= 0) { //取得透明色 $transparentcolor = imagecolorsforindex($srcImg, $otsc); //创建透明色 $newtransparentcolor = imagecolorallocate( $newImg, $transparentcolor['red'], $transparentcolor['green'], $transparentcolor['blue'] ); } else { //将黑色作为透明色，因为创建图像后在第一次分配颜色时背景默认为黑色 $newtransparentcolor = imagecolorallocate($newImg, 0, 0, 0); } //背景填充透明 imagefill( $newImg, 0, 0, $newtransparentcolor); imagecolortransparent($newImg, $newtransparentcolor); imagecopyresampled( $newImg, $srcImg, $size['x'],$size['y'], 0, 0, $size[&quot;new_w&quot;], $size[&quot;new_h&quot;],$imgInfo[&quot;width&quot;], $imgInfo[&quot;height&quot;] ); return $newImg; } /* $width:最终缩放的宽度 $height:最终缩放的高度 $imgInfo:原始图片的宽度和高度 */ protected function getNewSize($width, $height, $imgInfo) { $size['old_w'] = $width; $size['old_h'] = $height; $scaleWidth = $width / $imgInfo['width']; $scaleHeight = $height / $imgInfo['height']; $scaleFinal = min($scaleWidth, $scaleHeight); $size['new_w'] = round($imgInfo['width'] * $scaleFinal); $size['new_h'] = round($imgInfo['height'] * $scaleFinal); if ($scaleWidth &lt; $scaleHeight) { $size['x'] = 0; $size['y'] = round(abs($size['new_h'] - $height) / 2); } else { $size['y'] = 0; $size['x'] = round(abs($size['new_w'] - $width) / 2); } return $size; }","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH05-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%B1%BB%E3%80%81%E6%B0%B4%E5%8D%B0%E7%BC%A9%E6%94%BE%E7%B1%BB/"},{"title":"PHP[OOP入门]PH07-模板引擎类","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day07-模板引擎类 1、模板引擎 html css 静态页面 php 内嵌到html文件中的服务端脚本语言 1.php &lt;html&gt; &lt;?php echo 123; ?&gt; &lt;?php foreach ($data as $key =&gt; $value) : ?&gt; &lt;div&gt;&lt;?=$value; ?&gt;&lt;/div&gt; &lt;?php endforeach; ?&gt; &lt;/html&gt; 弊端： html代码和php代码交叉的太厉害,非常乱，而且，真正的工作中，前端的代码是有专门的妹子来写的，后端的代码你们这些汉子负责的 模板引擎 就是为了分离html文件和php文件而产生的 1.html(负责显示数据的)《====模板引擎===1.php(用来获取数据的) 简单的逻辑（得到数据显示出来） 使用模板引擎的语法来显示 {$title} =======》 &lt;?=$title; ?&gt; {if $a &gt; 0} =====&gt; &lt;?php if ($a &gt; 0): ?&gt; {/if} =======&gt; &lt;?php endif; ?&gt; 通过模板引擎，将html文件中的模板引擎的语法替换为php的语法,然后将该文件的后缀从html变成php，最终显示这个php文件。这个生成的php文件就是传说中的缓存文件 2、正则替换 preg_replace 正则表达式有 定界符 原子（\\d \\w .） 元字符(+ ? * {n}) () {} . + * ? preg_quote preg_replace_callback 3、include问题（一会讲吧） 4、缺点 面向过程 每次都会生成缓存（过期时间） 分页时候生成都是同一个缓存文件 index.php?page=3 类的设计： 成员属性 模板路径 缓存路径 过期时间 变量数组（用来保存页面需要显示的数据） 成员方法 assign（$name, $value） :分配变量 display(模板文件名， 是否include进来， uri) ：展示模板 &lt;html&gt; {include 'head.html'} =&gt; &lt;?php include 'head.php'; ?&gt; {include 'foot.html'} &lt;/html&gt;","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH07-%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%B1%BB/"},{"title":"PHP[OOP入门]PH06-数据库操作类","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day06-数据库操作类 1、数据库知识回顾 连接数据库 mysqli_connect(主机名，用户名，密码) 判断是否成功 选择数据库 mysqli_select_db($link, 库名) 设置字符集 mysqli_set_charset($link, 字符集) 准备sql 执行 mysqli_query($link, $sql) 解析结果集 mysqli_fetch_assoc($result) mysqli_fetch_rows($result) mysqli_affected_rows($link) mysqli_fetch_array($result) mysqli_insert_id($link) 关闭 mysqli_close($link) 2、连贯操作 $user-&gt;where()-&gt;table()-&gt;field()-&gt;limit()-&gt;order()-&gt;select(); return $this; 3、数据库缓存字段 将表格中的全部字段缓存起来 （1）当查询的时候，如果不传递字段，默认使用全部字段（缓存）进行查询 （2）当在查询的时候，如果有一个字段输入错误了，不影响我的查询 username password createIp createTime 和缓存字段取交集查询 （3）当插入数据的时候，如果有一个字段键值对传递错误，不影响插入数据 4、__call($name, $args)函数 getByUsername getByEmail 5、两种操作 增删改查 增删改（返回的结果都是受影响的行数） exec 查（返回的是结果集） query 6、查询实现字段无顺序替换 $user-&gt;where()-&gt;table()-&gt;field()-&gt;limit()-&gt;order()-&gt;select(); $user-&gt;table()-&gt;limit()-&gt;where()-&gt;field()-&gt;order()-&gt;select(); 7、数组交集 array_intersect 按值取交集，内容为第一个数组的内容 array_intersect_key 按键取交集，内容为第一个数组的内容 8、类的设计 Model类 我们写的是一个父类，基类 以后我们的一张表格就是一个类，而且都要继承自Model类 user==》UserModel goods==&gt;GoodsModel arctical==&gt;AbcModel 成员属性 $host $user $pwd $charset $dbname $link //保存数据库资源 $sql //保存sql语句使用 $options = []; //用来保存其它方法（limit、where）传递过来的参数 $tableName //设置表的名字，从类名中获取 成员方法 select table filed where limit order group having $sql = 'select %field% from %table% %where% %group% %having% %order%%limit%';","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH06-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C%E7%B1%BB/"},{"title":"PHP[OOP入门]PH08-设计模式","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day08-设计模式 设计模式概述 设计模式（Designpattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。 模式的经典定义：每个模式都描述了一个在我们的环境中不断出现的问题，然后描述了该问题的解决方案的核心，通过这种方式，我们可以无数次地重用那些已有的解决方案，无需再重复相同的工作。即模式是在特定环境中解决问题的一种方案 现在有两派，有的人建议使用设计模式，有的人不建议使用设计模式！ 解决代码的耦合度 耦合度越低越好 高内聚低耦合（对内要高内聚，对外要低耦合） 设计模式不分语言。php是世界上最优美的语言 1、单例（单一实例）实例化 这个类只能创建一个对象。 php的应用主要在于数据库应用,一个应用中会存在大量的数据库操作，使用单例模式,可以避免大量的new 操作消耗的资源 步骤 1、构造函数需要标记为private 2、保存类实例的静态成员变量 3、获取实例的公共的静态方法 2、简单工厂、标准工厂 接口中定义一些方法 实现接口的类实现这些方法 工厂类：用以实例化对象 优点：为系统结构提供了灵活的动态扩展机制。方便维护 3、工厂方法 工厂方法模式核心是工厂类不再负责所有对象的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，它仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节 4、观察者 涉及到两个类： 一个是被观察者 1、添加观察者 2、删除观察者 3、发送通知 一个是观察者 1、做出反应即可 在php中：用户注册（收到邮件，收到短信，或者收到其他信息） 它是一种事件系统，意味着这一模式允许某个类观察另一个类的状态，当被观察的类状态发生改变的时候，观察类可以收到通知并且做出相应的动作;观察者模式提供了避免组件之间紧密耦合的另一种方法 官方接口 SplSubject attach 添加观察者 detach 删除观察者 notify 通知 SplOberser update 做出响应 5、适配器 生活中就有很多适配器 电源适配器 就是里面的变压器 220v 可将一个类的接口转换成客户希望的另外一个接口，使得原本不兼容的接口能够一起工作。通俗的理解就是将不同接口适配成统一的接口 6、策略模式 （1）多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。 （2）需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。 （3）对客户隐藏具体策略(算法)的实现细节，彼此完全独立。 （4）客户端必须知道所有的策略类，并自行决定使用哪一个策略类，策略模式只适用于客户端知道所有的算法或行为的情况。 （5）策略模式造成很多的策略类，每个具体策略类都会产生一个新类。 优点： 1、策略模式提供了管理相关的算法族的办法 2、算法封闭在独立的Strategy类中使得你可以独立于其Context改变它 3、使用策略模式可以避免使用多重条件转移语句 7、门面模式 优点 1、它对客户屏蔽了子系统组件，因而减少了客户处理的对象的数目并使得子系统使用起来更加方便 2、实现了子系统与客户之间的松耦合关系 3、如果应用需要，它并不限制它们使用子系统类。因此可以在系统易用性与能用性之间加以选择 适用场景 1、为一些复杂的子系统提供一组接口 2、提高子系统的独立性 3、在层次化结构中，可以使用门面模式定义系统的每一层的接口 8、DI（Dependency Injection）依赖注入 （Ioc反转控制） 9、MVC 10、容器","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH08-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"title":"PHP[OOP入门]PH09-MVC框架","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day09-MVC框架 1、mvc概念 model view controller 2、psr规范 psr1：基础编程规范 psr2：编码风格规范 psr3：日志接口规范 psr4：自动加载规范 3、单一入口（简单路由） index.php?m=index&amp;a=index pathinfo index.php/index/index spl_autoload_register __autoload($className) 4、框架目录架构 app model UserModel.php view user login.html register.html index index.html about.html controller Controller.php UserController.php IndexController.php config config.php vendor lib Model.php Page.php Tpl.php public css js fonts editor cache 缓存 5、命名空间映射 将命名空间和目录结构对应起来叫做命名空间映射 今天的代码命名空间的映射是一一对应的，大家可以自己改进代码，将一个命名空间对应多个目录？ 'model' =&gt; 'app/model/' 'model\\test' =&gt; 'app/model/lala' 'controller' =&gt; 'app/controller/' 'vendor' =&gt; 'vendor/lib' 6、MarkDown介绍","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH09-MVC%E6%A1%86%E6%9E%B6/"},{"title":"PHP[OOP入门]PH13-异常处理、composer、容器、反射","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day13-异常处理、composer、容器、反射 1、异常处理 做两手准备（planA planB） 生活中 代码中 正常的逻辑，代码会按照你写的顺序正常的往下执行，在执行的过程中，往往会有一些异常的情况，碰到异常的情况，我们应该如何应对呢，这就是异常处理 在php中：try catchException(异常类，所有异常处理类的基类)，在代码中如果有异常了，我们要手动抛出异常 try:尝试着去执行一些有异常情况的代码，如果出现异常，手动抛出 throw:抛出异常 catch:捕获异常，进行下一步处理 【注】try-catch是一种结构，一个try至少对应一个catch 【注】在try和catch之间不能有任何的代码 try { } catch () { } 执行流程： 程序首先执行try中的代码，如果碰到了throw，那么try里面的throw下面的代码将不再执行，直接被catch捕获到这个异常，在catch中再执行你想执行的流程 Exception：官方的异常处理类，是所有异常类的基类 构造方法：错误信息，错误代码 getMessage getCode 自定义异常处理类:一定要继承自官方异常处理类 final: 类：代表此类不能被继承 方法：代表这个方法不能被重写 多个捕获 【注】如果是多个捕获，那么自定义的异常处理捕获要放到官方捕获的上面 嵌套 见代码 自定义异常处理函数 set_exception_handler('exceptionHandle'); 注册一个函数用来处理异常信息 2、composer 打开openssl扩展 如果安装成功，在cmd下输入composer，敲回车，显示出来即安装成功 基本dos指令 cd 拖过来你的那个项目文件夹 dir 显示当前文件夹下面所有的文件 composer.json文件 编写该文件,这个文件就是你的composer的配置文件，你想安装的一些包的信息都要写到这个文件中，而且按照固定的格式写（json格式） { &quot;employees&quot;: [ { &quot;firstName&quot;:&quot;Bill&quot; , &quot;lastName&quot;:&quot;Gates&quot; }, { &quot;firstName&quot;:&quot;George&quot; , &quot;lastName&quot;:&quot;Bush&quot; }, { &quot;firstName&quot;:&quot;Thomas&quot; , &quot;lastName&quot;:&quot;Carter&quot; } ] } json格式：两种数据类型 对象{} 数组[]键使用双引号引起来，键值对中间使用逗号隔开 修改为国内镜像网 github.com packagist.org https://pkg.phpcomposer.com/ 国内镜像 只要你安装了composer，默认是从国外镜像下载，你得修改成国内镜像，否则后果自负 执行如下指令，修改镜像源 composer config -g repo.packagist composerhttps://packagist.phpcomposer.com require加载路由包 &quot;require&quot;: { &quot;noahbuscher/macaw&quot;: &quot;dev-master&quot; } 运行composer update指令进行下载 版本号 1.0.* 表示任何从 1.0 开始的开发分支，它将会匹配 1.0.0、1.0.2 或者1.0.20 1.0.2 对应确定的版本号 &gt;=1.0 &gt;=1.0,&lt;2.0 &gt;=1.0,&lt;1.1|&gt;=1.2 ~1.2 相当于 &gt;=1.2,&lt;2.0 ~1.2.3 相当于 &gt;=1.2.3,&lt;1.3 dev-master github上面的主版本号 参数 项目基本描述 &quot;name&quot;: &quot;laravel/laravel&quot;, &quot;description&quot;: &quot;The Laravel Framework.&quot;, &quot;keywords&quot;: [&quot;framework&quot;, &quot;laravel&quot;], &quot;license&quot;: &quot;MIT&quot;, &quot;type&quot;: &quot;project&quot;, autoload(重点) 通过composer安装的包，composer都已经为我们实现了自动加载，使用的时候，直接使用即可 【注】使用第三方包之前，要首先包含 include 'vendor/autoload.php'; 如果是自己写的类，想用通过自动加载加载过来，需要使用下面两种方法中的任意一种 psr-4 ：遵从psr-4的规范进行加载 classmap：文件夹映射，将该文件夹下面的所有文件包含进来 【注】修改完配置文件中的autoload参数之后，要首先执行 composerdump-autoload composer常用指令 通过composer list来展示所有的指令 require 安装包我们可以通过配置文件来进行加载，也可以通过指令模式进行加载 composer require noahbuscher/macaw:dev-master 3、依赖注入（DI）、反转控制（IOC）、容器 容器优点： 1、降低耦合度 2、实现惰性加载 3、便于管理 4、反射 ReflectionClass 反射类对象 ReflectionMethod 反射方法对象 ReflectionParameters 反射参数对象 5、虚拟主机 httpd.conf vhost_alias_module rewrite_module Include conf/extra/httpd-vhosts.conf","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH13-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%81composer%E3%80%81%E5%AE%B9%E5%99%A8%E3%80%81%E5%8F%8D%E5%B0%84/"},{"title":"PHP[OOP入门]PH16-DOM操作、事件、选项卡","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day16-DOM操作、事件、选项卡 &lt;html&gt; &lt;head&gt; &lt;meta charset='utf-8'&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 数组声明 声明方式数字下标 var arr1 = ['张国荣', '林俊杰', 'beyond', '陈奕迅']; 这种就是索引数组，js中没有关联数组 追加方式字符串下标 arr1['kobe'] = 24; 可以通过这种方式给数组对象增加属性，就类似于php中的关联数组 获取数组长度 arr.length 但是只能获取索引数组的长度 数组遍历：for for in for 只能遍历索引数组 for in 会遍历数组中所有的键 数组常用方法：push pop shift unshift join reverse slice arr1.push 对象创建三种方法 Object json格式 json_encode json_decode function 1、js核心 css有很多属性，我们通过js找到对应的对象。然后为事件添加一些对应的方法，再触发这个事件的时候，就会执行对应的方法 事件是官方为我们提供好的 方法是需要我们自己写的 2、DOM操作（document object model）文档对象模型 document.getElementById() 根据id找到对象，根据需求（哪些事件）修改对象的属性即可 3、常用事件 onmouseover 鼠标悬停事件 onmouseout 鼠标离开 onmouseup 鼠标弹出 onmousedown 鼠标按下 onmousemove 鼠标移动 onclick 点击事件 ondblclick 双击事件 onblur input框 失去焦点 onfocus 得到焦点 4、简单效果 获取对象属性，获取对象的style 获取类名：oDiv.className 获取宽度：oDiv.style.width 获取背景色: oDiv.style.backgroundColor css中带杠的，在js中属性名变为小驼峰 获取标签文本 innerHTML:获取标签和内容 innerText：只获取文本信息 点和中括号区别 点： 只能获取对象已有的属性，点后面只能根存在的属性名 中括号：都可以。 使用点的地方肯定可以使用中括号，使用中括号的地方不一定能使用点 添加事件 多种方法，看代码 显示隐藏图片 控制div的display属性， none block之间修改即可 this 就是当前对象，可以通过方法直接传递过去 onclick=&quot;change(this)&quot; 表单内容控制（onblur、onfocus） onload加载 当整个页面加载结束之后，调用window.onload方法 点击事件的函数都要写在onload的外面，否则找不到该方法 5、通过className Name Tag获取对象 getElementById document.getElementsByClassName //得到的是一个集合，下标从0开始 document.getElementsByName document.getElementsByTagName 这些得到的都是集合，需要通过下标来依次访问 6、选项卡、滑动门(重点) 8、获取非行内样式","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH16-DOM%E6%93%8D%E4%BD%9C%E3%80%81%E4%BA%8B%E4%BB%B6%E3%80%81%E9%80%89%E9%A1%B9%E5%8D%A1/"},{"title":"PHP[OOP入门]PH14-PDO","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day14-PDO 1、概述 pdo就是用来连接数据库的 mysqli是用来连接数据库的 使用pdo可以连接其他的数据库，连接方法不变 pdo可以用来连接所有的数据库，但是前提你要安装对应的驱动 pdo的扩展库 mysql和pdo的驱动 mysql oracle sqlserver 2、使用（手册） 3个类 PDO PDOStatement PDOException 连接 try { $dsn = 'mysql:host=localhost;dbname=fen;charset=utf8'; //如果连接失败。pdo内部会自动的抛出异常 $pdo = new PDO($dsn, 'root', '1234567'); echo '连接数据库成功&lt;br /&gt;'; } catch (PDOException $e) { echo $e-&gt;getMessage(); } 获取和设置信息 setAttribute 在下面讲解pdo的时候设置看看 getAttribute 可以获取一些信息，都是pdo为我们提供的常量 PDO::ATTR_AUTOCOMMIT PDO::ATTR_CLIENT_VERSION PDO::ATTR_SERVER_INFO PDO::ATTR_DRIVER_NAME 错误模式 默认模式：pdo有两个方法供我们使用 errorCode errorInfo 警告模式：$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_WARNING); 异常模式：$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_); 我们需要将sql语句的执行放到try中来执行 PDO执行sql语句 query=&gt;查询=》要结果集的 返回的是PDOStatement对象，可以通过遍历对象查看所有结果，该结果关联和索引都有 exec=&gt;增删改=》不要结果集的，要受影响的行数 事务处理 什么叫做事务？ wo 0+500 li 1000-500 这两条语句必须都执行成功才能完成交易，如果有一条语句失败，那么交易就失败，所有的状态都要恢复（回滚）。这种就叫做一个事务 myisam:不支持 innodb:支持事务 小利给爱斌转500块钱 PDO::beginTransaction — 启动一个事务 PDO::commit — 提交一个事务 PDO::rollBack — 回滚一个事务 预处理类 预处理语句 优点：效率、安全（sql注入） PDOStatement prepare 预处理sql语句 execute 执行sql语句 增删改 查（结果集） PDO::FETCH_BOTH PDO::FETCH_ASSOC PDO::FETCH_NUM PDO::FETCH_OBJ setFetchMode 设置默认的提取模式 绑定列(了解) 3、虚拟主机 1、点击配置 2、在 httpd.conf 中，将下列打开 vhost_alias_module rewrite_module Include conf/extra/httpd-vhosts.conf","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH14-PDO/"},{"title":"PHP[OOP入门]PH15-js基本语法","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day15-js基本语法 &lt;html&gt; &lt;head&gt; &lt;meta charset='utf-8'&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 一、基本介绍 javascript 网景 sun 火狐浏览器 特点：杂乱无章 非常的乱 没有规律可循 四种声明方式 第一种：在页面的任何地方，写入&lt;script&gt;js代码&lt;/script&gt; 第二种：在a标签中写js &lt;a href=&quot;javascript:&quot;&gt;&lt;/a&gt; 第三种：外联式 .js 引入进来这个文件即可 第四种：直接通过添加事件写入 三种打印输出方式 第一种：弹窗式 alert(); 第二种：借助浏览器的控制台 谷歌、火狐、360、ie、qq ie 678910 垃圾 非ie 兼容性 我们都以谷歌和火狐为例 第三种：document.write(); 二、基本语法 1、变量声明 变量声明:都要以var开始，不以var开始也行，但是我们要求都要以var开始.区别后续再了解 分号结尾：js中的语句要以分号结尾，但是不以分号结尾也行，但是要以回车结尾，一般我们都要求以分号结尾。 命名规范 （1）变量名由数字、字母、下划线组成，或者$ （2）不能以数字开头 （3）不能是系统关键字 （4）严格区分大小写 （5）不成文的规定 int float string object array iTest fTest sTest oDiv aDiv 2、注释格式 单行 // 多行 /* */ 3、数据类型 php中数据类型（8）:整型、浮点、布尔、字符串、数组、对象、资源、null 类型 整型、浮点、布尔、字符串、数组、对象、null、未定义、NaN typeof：通过这个函数查看变量的类型 undefined:定义一个变量没有给值 字符串 （1）加引号的都是字符串，单引号，双引号 （2）单引号和双引号都不解释变量 （3）单引号和双引号都解释转义字符 （4）字符串的拼接 使用 + 自动类型转化 字符串0在js中是真的，在php中是假的 各类型使用对象方式创建 Number String Boolean Array Object 对象、未定义、NaN NaN:not a number 两个NaN永远不相等，判断是否是NaN使用isNaN函数 4、运算符 算术 * / % += -= %= /= ++ -- 表达式的值就数学运算的结果 比较 &gt; &lt; &gt;= &lt;= == != ===(全等) !==(不全等) 逻辑 &amp;&amp; || ! 在php中逻辑与和逻辑或得到的都是布尔值 在js中，逻辑与得到的后面的一个操作数，如果两个操作数都为真，那么取后面的操作数，如果其中有一个操作数为假，那么就是这个假操作数 逻辑或得到的是后面的一个操作数，如果这两个有一个为真，有一个为假，那么其是那个真值，如果两个都为真，取前面那个一个真操作数，如果两个都为假，取后面那个假操作数 短路：逻辑与=》前面的为假，后面不判断 逻辑或=》前面的为真，后面的不判断 ！ 真假互换 +运算符 只要其中有一个是字符串，那么就按照字符串拼接处理，其他的按照数字加减 将字符串转化为Number的函数 parseInt 字符串以数字开头==&gt;截取前面的整型 字符串以字母开头==》NaN parseFloat 字符串以数字开头==&gt;截取前面的浮点 字符串以字母开头==》NaN 5、流程控制 通过Math对象访问成员方法使用的是 . Math对象 random :得到的是0-1之间的一个随机数，这么多年来，没有出现过0和1 ceil ：向上取整 floor ：向下取整 round ：四舍五入 max ：最大值 min ：最小值 if else else if: else if 之间要有空格 switch case : 都一样 for while do-while :和php中的是一样的 6、函数声明 注意事项 函数的定义格式和php中一模一样 php中函数的名字不区分大小写 （1）函数的名字区分大小写 （2）函数可以重载，后面的函数会覆盖前面的函数 形式参数、默认参数 在形式参数中不要加var 函数的形式参数不管有没有，再调用函数的时候你随便传递 全局变量和局部变量 全局变量全局有效 局部变量函数体内有效 如果局部变量定义和全局变量同名，那么局部变量会覆盖全局变量 变量必须都加var 可变长度参数 arguments 数组 匿名函数 和php是一样的 封闭空间 新内容，php中没有 (function (a) { alert(a); })('js真乱没法说'); 回调函数 和php中一样,传递的时候直接传递函数名 内部函数 内部函数只能在内部使用 外部函数随便调用 递归函数 和php中一样 数组声明 声明方式数字下标 追加方式字符串下标 获取数组长度 数组遍历：for for in 数组常用方法：push pop shift unshift join reverse slice 对象创建三种方法 Object json格式 json_encode json_decode function 这些对象方法大家自己测试一下 字符串对象方法 indexOf lastIndexOf substr replace toLowerCase toUpperCase Date getDate getDay getMonth getHours getMinutes getSeconds setMonth","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH15-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"title":"PHP[OOP入门]PH17-定时器","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day17-定时器 &lt;html&gt; &lt;head&gt; &lt;meta charset='utf-8'&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 1、封闭空间实现滑动门 2、获取非行内样式 3、定时器 分为两种 周期性定时器：周期性的去执行一个方法 定时器 = setInterval(方法, 时间); 时间以ms为单位 clearInterval(定时器名); 一次性定时器：执行一次 定时器 = setTimeout(方法, 时间); 时间以ms为单位 clearTimeout(定时器名); 计数器 一次性定时器使用 闪动效果 广告消失 秒表 00:00 开始、暂停、重置 倒计时 日期对象 飘动广告(自己实现) 鼠标快速划过 4、全选、全不选、反选 5、处理className兼容 IETester getElementsByName 必须是document对象 getElementById 必须是document对象 getElementsByTagName document和子对象都可以 getElementsByClassName document和子对象都可以","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH17-%E5%AE%9A%E6%97%B6%E5%99%A8/"},{"title":"PHP[OOP入门]PH18-DOM操作、吸顶条、事件绑定","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day18-DOM操作、吸顶条、事件绑定 &lt;html&gt; &lt;head&gt; &lt;meta charset='utf-8'&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 1、全选、全不选、反选 2、处理className兼容 IETester(用来查看所有ie浏览器的兼容性) //getElementsByName 必须是document对象 getElementById 必须是document对象 getElementsByTagName document和父对象都可以 getElementsByClassName document和父对象都可以 3、DOM节点操作 children 所有的子对象 (直接子节点) parentNode 父对象 火狐或者谷歌 firstElementChild 长子 lastElementChild 老幺 previousElementSibling 哥哥 nextElementSibling 弟弟 IE 6/7/8 firstChild lastChild previousSibling nextSibling tagName //得到标签名，得到的为大写的标签名 4、添加删除节点 createElement 添加节点 只能通过document来添加 removeChild 删除节点 父对象或者document都可以 appendChild 追加节点 insertBefore 插入节点 div中添加图片 5、setAttribute getAttribute 通过点和中括号只能获取官方属性 通过上面两个可以获取自定义的和官方的 6、添加上传文件 7、弹出图片 8、吸顶条 offsetTop 距离顶部的值 offsetLeft 距离左边的值 offsetWidth 宽度 offsetHeight 高度 以上属性，只能读取，不能设置 onscroll事件 clientWidth : 在h5标准下，获取使用documentElement 不在的话使用body clientHeight : 在h5标准下，获取使用documentElement 不在的话使用body document.body.scrollTop : 获取卷起的高度 吸顶条实现 吸顶条抖动问题 9、右底部广告、短信倒计时 右下角弹出大娟 思考：qq头像资料","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH18-DOM%E6%93%8D%E4%BD%9C%E3%80%81%E5%90%B8%E9%A1%B6%E6%9D%A1%E3%80%81%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"},{"title":"PHP[OOP入门]PH19-BOM、表单","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day19-BOM、表单 &lt;html&gt; &lt;head&gt; &lt;meta charset='utf-8'&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; BOM：browser object model 没有标准 window的属性和方法 document history location navigator event setInterval setTimeout DOM：document object model w3c(标准统一) 1、事件 事件绑定 addEventListener(事件 'click', 方法) 主流浏览器 attachEvent(事件 'onclick', 方法) 垃圾(ie)浏览器 removeEventListener detachEvent 事件对象 事件映射到js中也是一个对象，这个对象的获取方法不一样 主流获取对象方式：在闭包中写一个参数ev ie浏览器获取方式：是window的一个属性 window.event //兼容性写法获取事件对象 var oEvent = ev || event; 取消事件冒泡 cancelBubble\\stopPropagation() 上面两个都是event事件的属性和方法 cancelBubble：属性设置为true 均可以 stopPropagation()：方法 谷歌、火狐可以，ie不可以 子对象绑架父对象 事件源对象 srcElement 谷歌和ie可以 火狐不可以 target 谷歌和火狐可以 ie不可以 拖拽效果 获取鼠标的x和y坐标 oEvent.clientX, oEvent.clientY 键盘事件 event.keyCode 2、小游戏 3、小知识点 禁止鼠标右键（oncontextmenu） 超链接和点击事件同时触发 表单里面的 type=submit有默认提交的功能，也可以阻止 return false; //万能方法 下面两个有的不行，慎重使用 oEvent.returnValue=false oEvent.preventDefault() 4、window对象 打印效果 window.print(); 弹窗效果：window.alert\\window.confirm\\window.prompt 打开和关闭 open close history back() go() location href,protocol,hostname,port,pathname,search location.href reload(); navigator navigator.appName Web浏览器全称 都是netscape navigator.appVersion Web浏览器厂商和版本的详细字符串 navigator.userAgent 客户端绝大部分信息 navagator.platform 浏览器运行所在的操作系统 5、正则对象 简单 6、表单对象 三种查找方法 submit()方法 method属性 action属性 失去焦点得到焦点 js验证表单内容 附加功能： 积分功能：黄瓜5 西瓜3 葡萄1 吃完：弹出小红旗 开始：10 ====》（20-100） 封装pdo版本的model类","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH19-BOM%E3%80%81%E8%A1%A8%E5%8D%95/"},{"title":"PHP[OOP入门]PH20-自动播放选项卡、懒加载、瀑布流","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day20-自动播放选项卡、懒加载、瀑布流 location href,protocol,hostname,port,pathname,search location.href = 'http://www.baidu.com\\' 或者 location ='http://www.baidu.com\\' iframe a b c d(location.href ) parent.location.href 父级实现跳转 top.location.href 最顶层的实现跳转 reload(); //刷新 parent.location.reload(); top.location.reload(); 正则对象 和php中的是一样的，只不过写法稍微有点不同 1、js验证表单内容(获取焦点) document.fm.username.focus(); 2、select下拉框 selectedIndex options 充话费效果 3、自动播放选项卡 4、懒加载(延迟加载) 5、瀑布流 选择法、冒泡法、快速排序 （下去要查一下这些算法）","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH20-%E8%87%AA%E5%8A%A8%E6%92%AD%E6%94%BE%E9%80%89%E9%A1%B9%E5%8D%A1%E3%80%81%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81%E7%80%91%E5%B8%83%E6%B5%81/"},{"title":"PHP[OOP入门]PH21-ajax","text":"该部分为 php 面向对象的入门部分，较为肤浅且参杂过分已经不是主流的知识。 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day21-ajax(灰常重要) 1、应用场景 asynchronous javascript and xml === ajax 注册用户的时候，要写用户名，写了用户名之后，只要你的光标离开这个input框，我就立马知道你这用户名是否被注册过（ajax）让ajax去和服务器进行交互，交互完毕之后，收到服务器返回的结果，根据结果我再判断页面到底应该显示什么 页面没有刷新 在当前页面中通过ajax和服务器进行交互，达到局部刷新的效果 2、ajax使用 使用起来非常的简单，ajax就是js中的一个对象，通过调用这个对象的方法就完成了和服务器的交互 创建对象 谷歌、火狐、Opera、IE7以上 var xhr = new XMLHttpRequest(); //主流浏览器中创建ajax对象的方式 var xhr = new ActiveXObject(“Microsoft.XMLHTTP”); //垃圾浏览器的方式 var xhr = new ActiveXObject(“Msxml2.XMLHTTP”); var xhr = new ActiveXObject(“Msxml2.XMLHTTP.3.0”); var xhr = new ActiveXObject(“Msxml2.XMLHTTP.5.0”); var xhr = new ActiveXObject(“Msxml2.XMLHTTP.6.0”); //IE维护的最高版本 get方式 xhr.open('get', '1.php?username=goudan&amp;password=123'); xhr.send(); post方式 xhr.open('post', 'post.php'); xhr.setRequestHeader('content-type','application/x-www-form-urlencoded'); xhr.send('username=goudan&amp;password=123'); onreadystatechange ：当ajax状态改变的时候触发这个事件 readyState（01234） : ajax的状态 0：初始化 1：执行了open方法 2：执行了send方法 3：得到了部分响应数据 4：得到了全部的响应数据 这里面我们关心的就是4，到4的时候数据就过来了 status:http的状态码 200 responseText：现在都是使用这个 responseXML：这个现在已经不用了 将JSON字符串转化为js对象 //第一种方式 var obj = JSON.parse(xhr.responseText); //第二种方式 var obj = eval('(' + xhr.responseText + ')'); 将js对象转化为JSON格式的字符串 var str = JSON.stringify(obj); 3、ajax函数封装 encodeURIComponent 4、同步和异步 同步：前端在等待请求结果，结果来了之后代码再往下进行 异步：前端不等待请求结果，结果来了直接执行提前写好的回调函数即可 【注】事件绑定的代码我们都要写到open方法的上面。 5、跨域 localhost 127.0.0.1 不是同一个域 localhost www.wokao.com (1) 在php文件中中写如下代码 header('Access-Control-Allow-Origin:*'); (2)jsonp json with padding 6、用户注册","link":"/2017/01/01/coding/php/php-oop-%E5%85%A5%E9%97%A8/PH21-ajax/"},{"title":"PHP[入门]P07-PHP初认识","text":"day07PHP初认识 PHP运行原理 wampServer使用介绍 访问 php文件格式与语法格式 变量 打印 输出 数据类型 这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day07PHP初认识PHP：Hypertext Preprocessor 超文本预处理器 PHP运行原理运行在服务器端的脚本语言 可以内嵌在html中 必须要有的，服务器（apache） 数据库（mysql） php引擎 集成开发环境: PHPstudy WAMPServer XAMPP 运行 wampServer使用介绍修改www/index.php 12$projectContents .= 'http://localhost/'.$file.$UrlPort.'/&quot;';$projectContents .= 'http://localhost/'.$UrlPort.'/'.$file.'/&quot;'; www是放我们写的php文件 必须都放在www 运行:禁止双击 修改完配置文件不管是php.ini还是我们的httpd.conf都要重启服务 重新安装bbs 第一步:去install.lock 删除掉 第二步：数据库名字不要跟上次一样 phpinfo(); php扩展和配置信息等 访问localhost 本机主机名 127.0.0.1 本机ip 局域网访问：Require all granted 第一步：关闭防火墙 第二部：修改apache wamp64\\bin\\apache\\apache2.4.17\\conf\\httpd.conf 看自己的ip地址: 控制台 cmd-&gt;ipconfig-&gt;ipv4 就是你的ip地址 PHP是模块化的引擎 php文件格式与语法格式标准风格 &lt;?php 中间是php代码 ?&gt; 但是去过这个文件是纯 php 代码的时候 &lt;?php 段标记风格 &lt;? ?&gt; 修改php.ini 将 short_open_tag=on 重启服务(一般不使用 知道记住就行) 简写风格:&lt;?= 1;?&gt; 等价 &lt;?php echo 1;?&gt; $_SERVER['REMOTE_ADDR']; 获取当前访问用户的ip地址 $_SERVER['HTTP_REFERER']; 上一级页面的地址（父级）上一级页面的来源地址 注释： /* 中间是注释这是块注释 */ // 单行注释 # 单行注释 每条语句结束加上; 变量在程序的运行中可以存储值的 在程序的运行中其值改变的 声明变量: 必须以$开始 变量名是自定义的 规则： 以数字，字母，下划线组成不能以数字开始变量名严格区分大小写 说明:变量名要见名识意思（首选英文，就用全拼）驼峰命名法 $Name $userName下划线命名法 $user_name 四种操作: 定义: $num = 5;改变值：直接赋值 $num = 10;干掉变量: unset(变量名);判断这个变量是否存在:isset(变量名); 打印 输出echo :不是函数 是语法结构 输出变量值 输出多个变量用逗号隔开 print():打印一个变量 一般不使用 print $num; print_r()：可以打印一个变量或者一个数组 同样也不经常使用但是要知道 var_dump():打印一个变量或者一个数组时候经常使用因为会打印出详细信息包括数据的类型和值 经常使用的 数据类型标量： 整型：int integer 负数也是 就是整数 浮点: float/double 就是小数 科学计数法 【注】千万尽量不要用浮点型数作比较 布尔：bool boolean false 等价于 0true 等价于 1 一般用于判断的时候 eg: 1234567$num = false;if ($num) {echo 111;} 字符串: str string 用单引号跟双引号引起来的都是字符串 单引号和双引号的区别： 双引号解析变量，单引号不解析变量 单引号效率比双引号高 （建议能用单引号，就不用双引号） 双引号中放变量的时候 要有分隔符（推荐完美用{}） 双引号中不能有双引号，单引号中不能有单引号 如果需要的话请转义 单双引号可以相互嵌套 原样输出 单引号不转义字符 支持\\\\ \\' 双引号支持转义字符 eg：\\n \\r 双引号中使用单引号引起来变量会被解析 拼接字符串： 用口水'.' 拼接 eg: $str=&quot;wwww'$str1'&quot;; 定界符:”heredoc” 1234567891011$str = &lt;&lt;&lt;&quot;ABCD&quot;bug是不易被发&quot;现&quot;你们经常出现的是错误dwjhrkeABCD;[注]:相当于双引号的字符串 但是这里面支持使用双引号'nowdoc'$str = &lt;&lt;&lt;'ABCD'; 12345bug是不易被发'现'你们经常出现的是错误dwjhrkeABCD; 注:开始必须有&lt;&lt;&lt;’ASS’ 结尾必须顶格 混合(复合)： 数组 array 一组数据的集合 对象 object 一组有关系的数据个体 特殊： 空 null ：空就是null null就是空 产生 null 的三种方式 1.直接给变量赋值为 null 2.直接定义一个空变量 eg:$num; 3.unset();直接干掉 资源:resource gettype() empty() empty 和 isset 的区别 程序的执行流程:默认从上到下执行 思考，查阅： echo和print ,print_r的区别？","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P07-PHP%E5%88%9D%E8%AE%A4%E8%AF%86/"},{"title":"PHP[入门]P09-流程控制","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day09-流程控制 settype() 可变变量 变量的引用 1.流程控制中的三种结构 顺序结构 分支结构 循环结构 2. 分支结构 单向分支 语法结构： if (表达式) { 语句体; } 执行流程: 首先判断表达式如果表达式为真，那么执行大括号里面的语句ti;如果为假，跳过大括号里的继续往下执行; 双向分支 语法结构： if (表达式) { 真区间; } else { 假区间; } 执行流程: 首先判断表达式是否为真，为真走真区间，如果表达式为假，走假区间 永远不会同时执行真区间的语句体和假区间的语句体 多向分支(巢状分支) 语法结构: if (表达式1) { 语句体1; } else if (表达式2) { 语句体2; } else if (表达式3) { 语句体3; } else { 语句体4; } 执行流程: 首先判断表达式1如果表达式1为真执行语句体1然后结束整个结构.若为假判断表达式2...如果所有的表达式都为假的时候，执行else 当所有的情况都做了判断，那么最后else 可以省略 一般用于区间判断 嵌套分支 5)switch...case (break,default) 用于确定值判断 语法结构： switch (变量) { case 值1： 语句体1; break; case 值2： 语句体2; break; case 值3： 语句体3; break; default: 语句体4; } 执行流程: 拿到这个变量值以后进行case值的对比,如果匹配成功走对应case区间;然后比如break跳出switch结构如果 case所有的对比都不匹配，走default [注]： 基本上每个case 都有一个break如果没有break,一直往下执行直到碰到break结束整个结构 case后边值可以是标量（最好不放浮点）,常量来做比较 当所有的情况都罗列出来那么default可以不加 多个case可以执行同样的语句 3.循环结构 for 语法结构： for (变量初始化; 循环条件; 计数条件) { 循环体; } 执行流程： 进入for首先且执行一次变量初始化，然后判断循环条件是否满足，为真执行循环体;再执行计数条件--&gt;继续判断循环条件，为真继续执行循环体，再执行计数条件，知道循环条件为假，那么结束整个循环 【注】:双层for循环 第一层控制行，第二层控制列 特点：灵活多变的 1.第一个表达式跟第三个表达式可以提出来，但是第一个要放上分号占位表示第二就是循环条件 2.循环提交可以省略 但是会出现死循环 这时候要用break while 语法结构： while (循环条件) { 循环体; } 执行流程： 首先判断循环条件，如果为真执行循环体，为假no执行 [zhuyi]while非常容易写出死循环那么两种情况 第一加上计数条件第二种break; do..while 语法结构： do { 循环体; } while (循环条件); 执行流程： 首先进入的时候先执行一次do大括号里的循环体、然后再去while判断循环条件,如果为真执行do里的循环体，直到while条件为家终止循环 while 跟do..while区别 while:先判断再执行 do..while：先执行再判断 （至少执行一次） goto： 直接跳到指定的标号处 echo '村长你的牙好亮啊&lt;br /&gt;'; goto test; echo '村长你的牙好亮啊&lt;br /&gt;'; echo '村长你的牙好亮啊&lt;br /&gt;'; echo '村长你的牙好亮啊&lt;br /&gt;'; test: echo '村长你的牙好亮啊&lt;br /&gt;'; echo '村长你的牙好亮啊&lt;br /&gt;'; (break continue) break 用于结束循环,不管break后边有多少语句，碰到break立即结束循环 continue: 用于结束本次循环不管后边有多少语句，都不执行，后进入下一次循环","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P09-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"},{"title":"PHP[入门]P08-类型转换，运算符，表达式","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day08类型转换，运算符，表达式 资源：resource $con = fopen('ceshi.txt', 'r'); 【注】第一个参数(arg) 不要用中文 $con = false; if ($con) { echo '真区间'; } else { echo '假区间'; } gettype() ：获取数据的类型 empty()：判断的是这个变量是否为空 为空返回真true 不为空返回的是false empty和isset的区别（） empty() 判断这个变量是否为空 为空返回真 不为空返回的是false isset() 判断这个变量是否定义 如果定义返回真 如果没有定义返回假 使用：一般在判断数组或者一个变量里面是否有值的时候用empty 2.判断类型（） is_array() is_bool() is_float() is_integer() is_null() is_numeric() is_object() is_resource() is_scalar()检测是否是标量 is_string() 返回值：是要判断的类型 就返回真 不是就返回假 3.类型转换：（） 强制类型转换 1.转换函数 intval() strval() floatval() boolval() 只在使用的时候改变了变量的类型 并没有改变变量本事的类型 2.在变量前边加上(int)(string)(float)(bool)转换方式 只在使用的时候改变了变量的类型 并没有改变变量本事的类型 3.settype() arg: var 要转换的变量。 type 的可能值为： boolean integer float string 设置变量的类型，会改变变量本身的类型 [注] settype($num, 'null') 等价于 unset($num); [注] 1.当字符串转为整型 或者浮点型时候 开头如果不是数字那么直接转为0 2.空转为整型是整型的0 3.空转为浮点型是浮点型的0 4.空转为字符串是空字符串 5.浮点型的1234.0 转为字符串是1234 6.浮点型的1234.45 转为字符串是1234.45 7.浮点型转为整型的时候小数点后边的全部干掉 自动类型转换： 用 . 拼接时候会转换成字符串 在运算的时候会自动转换 1.做加减乘除运算的时候 字符串会自动转为整型或浮点型 2.bool值参与运算的时候 自动将true转为1 false转为0 3.如果用点拼接字符串 然后在拼接bool值 布尔值true转为1 false转为0 4.如果if小括号里面有运算表达式 最后都转为bool值 [注]:转为bool值为假的情况 1.整型的0是假 其余都是真 2.浮点型的0.0是假 其余都是真 3.空字符串是为假 就算一个空格他也是真 4.字符串里有一个0 是假 其余为真 5.null(空)是假 6.未声明成功的资源也是假 7.空数组也是为假 4.常量 （） 常量定义 在程序的运行的运行过程中 其值不会被改变的 不可以unset 定义： define('常量名', '常量值'); 规范： 1.常量名用单引号(双引号也行，但是从效率考虑用单引号) 2.一般都常量名都使用大写(规定必须用大写) 3.常量名也区分大小写 4.常量名定义时候也是数字 字母下划线不能以数字开始 尽量不用数字 5.常量的值只能用标量 6.常量的作用域是全局 7.常量调用时候不能写在字符串中，想使用可以用 . 拼接 8.不可以重复定义 常量判断: defined(常量名) 是否定义了常量 定义了返回true否则返回false 系统常量（） __LINE__ 当前所在行数 __FILE__ 在前所在文件全路径 __DIR__ 所在目录 PHP_OS php运行的系统 PHP_VERSION php的版本 (了解先背下来） __FUNCTION__：当前函数名 M_PI ：圆周率 __CLASS__ ：当前类名 __METHOD__：当前成员方法名 __NAMESPACE__：当前命名空间 5.可变变量 $hello = 'lilei'; $lilei = 'hanmeimei'; echo $hello . '&lt;br /&gt;';//lilei echo $lilei . '&lt;br /&gt;';//hanmeimei echo $$hello; // hanmeimei // $$hello = $lilei; 6.变量的引用 //当我们没有使用&amp;引用变量时两个变量有各自的存储空间 当使用了&amp; 以后 两个变量指向使用的是同一个存储空间 修改一个的值 另一个也会修改 $num = 20; $num1 = &amp;$num; $num1 = 30; echo $num . '&lt;br /&gt;'; echo $num1 . '&lt;br /&gt;'; 7.运算符和表达式 运算符: 表达式:由变量 常量 运算符组成 【注】表达式都有值 算数运算符： + - * / % 赋值运算符： = += -= *= /= %= .= += .= 自增自减： 自增:++$num $num++ 都会让$num + 1 自减：--$num $num-- 都会让$num -1 区别： $num = 3; $num1 = ++$num; ++$num 先加再用 先把1加给$num //4 $num1=4 --$num 先减再用 $num1 = $num++ $num++ 先用再加 先把$num本身的值赋给$num1 之后自身+1 $num-- 先用再减 关系运算符：&gt; &lt; &gt;= &lt;= == != === !== == 模糊等于 只比较值 不比较数据类型 != 模糊不等于 === 全等于 就是值和类型都相同表达式才为真 !== 不全等 有一个不管是值还是类型有一个一样 就为真 逻辑运算符 &amp;&amp; and || or ! xor &amp;&amp; and 逻辑与：并且 当两个表达式同时为真 才执行真区间 || or 逻辑或：或者 当两个表达式只要有一个表达式为真 就执行真区间 xor 逻辑异或 相异时候为真 相同的时候为假 短路原则： &amp;&amp; and 当第一个表达式为假的时候 直接走假区间 不会判断第二个表达式是真还是假 || or 当第一个表达式为真的时候，直接走真区间 不会判断第二个表达式为真还是假 !:取反 true取反是false 按位运算(了解) &amp; | ^ ~ &lt;&lt; &gt;&gt; 8.优先级 先乘除后加减 如果不行直接加上小括号 9.三元运算符 ? : 表达式 ? 真区间 : 假区间; 其他运算符 @ =&gt; -&gt; ``:执行系统的命令 @:抑制错误输出(单行) =&gt;:数组中键值对的关联符 -&gt;:对象成员的访问方式 掌握系统函数 floor():返回不大于 value 的最接近的整数，舍去小数部分取整。 ceil(): 返回不小于 value 的下一个整数，value 如果有小数部分则进一位。 round():四舍五入 ---------------- PHP官网（中文）：http://www.php.net PHP学院：http://www.phpxy.com PSR规范 -------------- 错误： parse 或者syntax 解析 notice 通知 warning 警告 fatal 致命 --------------","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P08-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"PHP[入门]P10-函数","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day10-函数 变量的引用unset其中一个值 常量说常量值是标量类型 在php7.0以后我们的常量值可以是数组 1.为什么要自定义函数 可以提高代码的重用性 提高开发效率 减少了代码的冗余量 定义函数就是封装功能 2.分类： 系统函数 自定义函数 3.自定义函数 定义： 语法格式： function 函数名([参数列表]) { 函数体; [return 返回值]; } 调用 函数名([参数列表]); 函数名命名规范： 1.必须以function 开始 2.如同变量一样 ，以数字字母下划线组成 不以数字开始 3.函数不区分大小写 但是要求大家区分大小写 4.函数命名不能使用系统已经定义过的关键字或者系统函数名称 5.命名一般遵从的是小驼峰命名法或者下划线 （根据具体的项目安排） [注意]： 函数可以重复调用，甚至在函数前边后边（函数是条狗，哪里需要哪里吼） 函数不可以重复定义 即函数不能被重载 如果函数定义了，不调用不执行 参数：【根据实际的需求增加，可以有可以没有】 我们在定义函数时候的小括号里面的参数叫形参 在调用函数的时候小括号里面的实参 如果我们的形参里参数有带默认值的参数，放在参数列表的后边 参数值是可变的，提高了代码的重用性 如果没有形参，调用函数的时候传实参那么不会报错（这种事情瞎子才干） return:【根据实际需求，可以有可以没有】 调用函数的时候给返回值; return 返回值;(如果有多个返回值:可以放在数组里或者.拼接); return 返回值; 当前return结束以后，后边的语句就不再执行 4.变量的作用域 变量可使用的地方 外部变量:就是函数外部的变量 内部变量:就是函数内部的变量 在函数内部不可以使用函数外部的变量 解决方法： 1.使用关键字global外部变量名（不推荐使用，因为可以在函数内部改变外部变量值） 2 推荐使用的方式 超全局变量： 5.静态变量： static 关键词在函数加载的时候定义一次，即使函数执行以后也不会释放，依然存在 6.内部函数： 函数里面还有一个自定义函数 【注】: 只能定义一次解决方式有三种 1.static 2.function_exists 3.is_callable 调用内部函数的时候，只能在函数定义之后调用，不能前边调用 当调用了外变的函数以后，才可以在外部使用内部函数 7.变量函数： function demo() { echo '踏歌长行，梦想永在'; } // demo(); $str = 'demo'; $str(); //== demo(); 8.匿名函数 $str = function () { echo 'youmengxiang'; }; 把一个没有名字的函数就是匿名函数 直接赋给一个变量使用 调用方式 变量名(); 匿名函数想要使用外部变量的时候 使用use关键词 use(变量名)如果有多个用逗号隔开 想要在匿名函数内部改变use过来的变量值 在use时候传变量的引用eg:use(&amp;$name) $str(); 9.回调函数: 10.递归函数： 11.引用传参： 12.可变参数类型 func_num_args() func_get_args() func_get_arg($i) ... 13.include require include_once require_once --------------- 超全局变量 $GLOBALS $_REQUEST $_GET $_POST $_FILES $_COOKIE $_SESSION --------------- 错误： Notice 提示 Warning 警告 Error 错误 ---------------- 常用数学函数： abs() 绝对值 max () 最大值 min() 最小值 mt_getrandmax() 最大随机数 pi() 圆周率 pow() x的y次方 round() 浮点数四舍五入 deg2rad() 角度转弧度 rad2deg() 弧度转角度 --------- 变量的值传递跟引用传递的区别 //值传递 $num = 10; $num2 = $num; //传引用 $num = 10; $num2 = &amp;$num; unset($num); echo $num2;","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P10-%E5%87%BD%E6%95%B0/"},{"title":"PHP[入门]P11-函数再认识","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day11-函数再认识 //注意：定义函数定义了形参没有给默认值，调用函数的时候会包warning错误缺少参数 回调函数我们要传入可以调用的函数名，那如果传参数是错误的，防止错误的方式 加上判断，判断传入的回调函数名是否正确或者是否可以调用 递归函数： 核心思想： 自己调用自己的一个过程 主要三个组成部分： 自己调用自己 结束条件 核心的逻辑块 优点： 高大上代码 缺点: 效率低，占用内存大，而且可读性差 //大多数人都理解99% 引用传参： 使用方式： eg: function show(&amp;$str) { echo $str; } show($str); ： 1.引用时两个变量指向同一个存储空间 那么在传实参的时候必须传的是变量 2.引用传参的 &amp;必须放在的是我们的形参中 3.使用引用传参 在函数内部改变参数的值，函数外部的值也会改变 4.在使用引用传参时，如果传的是一个没有定义的变量不会报错，相当于定义了一个变量 可变参数类型 func_num_args() //返回的是调用时候实参参数的个数 func_get_args()//返回的是实参列表中所有的值 类型是数组 func_get_arg($i) // 返回的是指定的实参中的某一项 ... php7.0新特性： 1.function show($str, $str2) { var_dump($str);//1 var_dump($str2);//2 } $arr = [1, 2, 3]; show(...$arr);//传实参时候传的是数组，用了...以后将实参数组解析然后依次赋值给函数的形参 function show(...$arr) { var_dump($arr); } show(1, 2, 3, 4, 5); //jiang shican zhong de canshu liebiao jiexi cheng shuzu include require include_once require_once：区别 include :包含文件并执行 参数：文件路径跟名字 如果包含错误 报的是警告的一个错误 但是不影响程序的继续执行 require ：包含文件参数文件的路径 如果包含错误 报的是致命的错误影响程序的继续执行（程序不会往下执行） include_once :包含文件在包含文件时候首先判断是否已经引入如果有不执行包含如果没有不包含 require_once : 同理 declare(strict_types = 1); function show( string $str) { var_dump($str); } show('2'); //形参中使用类型定义以后传参要穿指定的类型，但是因为我们的PHP属于弱类型语言，如果定义的是int传入的是'2'会自动转成int我们加上declare指令 以后强制传入指定的类型 function show($str):string { return $str; } //要求的是函数的返回值类型 如果我们在传实参时候传的是int返回默认转成string 如果使用declare指令 那么要求传的实参也是string --------------- 函数的注释 /** * @name 累加函数 * @author wlj wanglijuan@1000phone.com * @param int(mixed) $num 累加开始值 * @param int $num2 累加结束值 * @return array */ --------------- 超全局变量 $GLOBALS $_COOKIE 得到会话控制中cookie传值 $_SESSION得到会话控制中session的值 $_FILES得到文件上传的结果 $_GET得到get传值的结果 // $_POST得到post传值的结果// $_REQUEST即能得到get的传值结果，// 也能得到Post传值的结果 __FUNCTION__ ---------------- 手册使用找规律 1. 看函数的功能和版本 2. 看返回值 var_dump() gettype() isset() empty() 3. 看传入的参数要求是什么 copy(复制谁，复制到哪儿去) 4. 看到[]（中括号）代表可选，参数可传可不传 5. ... 就是后面可以传入任意多个参数 6. &amp; 就必须要传变量，并且函数会改变原变量的值 7. Mixed 可传入任意类型 8. Callback 就是可以传入回调函数 9. 有没事看手册","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P11-%E5%87%BD%E6%95%B0%E5%86%8D%E8%AE%A4%E8%AF%86/"},{"title":"PHP[入门]P12-数组","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day12 数组 1.数组定义 数组：一组数据的集合 集合：值可以是任意类型 array 名词解释： 元素：数组中的一个数据 键值对：键值对就是一个元素 0 =&gt; 'balue' 键：为了找到值而存在 key [注]：不能重复 默认从零开始 值：是真正要使用的东西 value 可以是任意的类型 定义： 1.[]: 定义一个数组 （php5.4以后才支持这种定义方式） eg: $arr = [2, 'ser', 3.4]; 2.array: $arr = array(true, 2.3 , 'str'); 3.直接赋值法： $arr[] = 'duhaitao'; $arr['name'] = 'wangchun'; $arr[2] = '王美丽'; [zhu]:如果没有指定下标默认从0开始 如果指定下标 那么你指定的下标 如果数组中已经有了正整数的下标，而再赋值的时候默认从当前key中寻找到最大的非负整数中+1 数组的四种操作： 读/删除/追加元素/修改元素的值 如果操作时候 key已经存在 再赋值 相当于修改 如果没有就是追加 删除其中的某个元素 数组的元素键不变 不会随着删除而更改键 删除其中的某个元素以后立即增加新的元素 也不会代替刚被删除的元素的key 2.数组的分类 下标区分： 下标只有整数跟字符串 索引数组：键都是整型 关联数组：数组的键中只要一个key是字符串 声明关联数组时候 指定键 key =&gt; value 'key' =&gt; value 在定义关联数组的时候 如果没有指定下标 （如果下标里面都是字符串的时候默认 从0 开始，如果已经有整数小标 那么从中寻找到最大的非负整数进行+1） 维度区分： 一维数组: 确定数组中的值需要一个下标的是一维数组 二维数组:确定数组中元素的值 需要两个下标的是二维数组 多维数组:数组A中元素的值插入的是B数组 然后B数组中又插入C数组这种叫多维数组 从三维开始就叫多维 4.数组的遍历 for for (变量的初始化, 循环条件, 计数条件) { 循环体; } [注]：只能用于索引数组 而且是下标连续的索引数组 foreach 语法 foreach (遍历的数组 as [$key =&gt; ] $value) { 操作; } [zhu]: as 是不能缺少的 [key =&gt; ]是可以省略 每一次遍历 是将key赋值给指定的变量$key 将值赋值给 $value 知道读完所有值会自动结束遍历 list 只能用于索引数组 默认要连续下标的 如果不连续 读取要用，占位 将false 赋值给list 打印以后是false each ------------ 数组函数","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P12-%E6%95%B0%E7%BB%84/"},{"title":"PHP[入门]P14-mysql基础","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day14-mysql基础 1.数据库系统的组成部分 数据库系统 数据库 表 字段 数据 2.数据库分类 关系型数据库 非关系型数据库 3.SQL含义 Structured Query Language结构化查询语言 数据库的默认端口号是：3306 4.SQL的分类 DDL：数据定义语言 对数据库的库，表，字段的创建 修改 删除的操作 DML：数据的操作语言 主要对数据 进行增加 删除 修改 DQL：数据的查询语言 主要对数据进行查询 DCL：数据的控制语言 DTL：数据的事物 5.配置mysql相关环境变量 1.把mysql bin目录路径复制 2.打开计算机属性-》系统属性-》高级系统设置-》高级-》环境变量-》系统变量-》path修改path值 不能删除以前的在值后边加上分号 把第一步路径粘贴上 3.关闭dos窗口 重新打开 mysql 启动dos: 1 开始菜单 -》搜索程序打开cmd 回车 2 win+R -&gt; cmd 不修改环境变量想执行mysql 切换到mysql bin 目录下 d: cd 切换目录 6.链接数据库 mysql -hlocalhost -uroot -ppassword 主机名 用户名 密码 ** 如果访问的是本机的数据库 可以省略-h 链接mysql 时候 密码回车敲 退出mysql命令： quit; exit; help; \\h 帮助命令 \\c 清除历史 清除错误都可以使用 \\G 更友好的显示 注意： 语句结束切记不要忘记分号 7.基本命令 show databases; 显示 当前所有的数据库 create database databasename; 创建数据库 drop database databasename; 删除数据库 use databasename; 选中数据库 使用数据库 show create database databasename; 显示库结构 8.表语句 show tables; 显示当前选中的库中的所有表 create table tablename(字段名 类型, 字段名 类型,字段名类型); 创建一个表 desc tablename; 查看选中的表的结构 drop table tablename; 删除选中的表 alter table tablename modify 字段名 varchar(40); 修改表字段类型 alter table 表名 add 字段名 字段类型; 增加字段 alter table 表名 add 字段名 字段类型 after 字段名;增加字段设置字段的位置 alter table 表名 add 字段名 字段类型 first; 增加的字段放在字段的最前边 alter table tablename drop 字段名; 删除表中字段 alter table tablename change 字段原名 新字段名 数据类型;修改表中的字段名 alter table tablename rename newtablename; 修改表名 *字段增加和修改语句(add/change/modify)中，最后都可以加一个可选项first|after。 ---------- 修改表字段 alter table tablename [modify/add/change/drop] 创建表语句的时候每次都要指定存储引擎 和字符集 engine = innodb default charset=utf8 解决每次都要设置表引擎和字符集修改mysql配置文件my.ini my.ini 打开方式 直接在小绿W打开也可以在wamp64/bin/mysql/mysql5.7.9/my.ini 修改 default-storage-engine=InnoDB 添加 character_set_server=utf8 -------- 注：一定先use 使用库以后才能操作选中的这个库里面的数据 ----------- json_encode 将字符串转换成json字符串一般用于最多的时候就是将数组转成json json_decode 将json串转成 object，第二个参数传true 才返回的是数组 -----------","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P14-mysql%E5%9F%BA%E7%A1%80/"},{"title":"PHP[入门]P13-时间相关函数和错误处理","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day13-时间相关函数和错误处理 时间的用途： 1.时间函数 Unix时间戳： 1970年也叫计算机元年 1970/1/1 0:0 开始距离现在的秒数 时间戳 默认取到的时间戳是格林威治时间 0时区 我们现在在东八区 时差8小时 time(); $_SERVER['REQUEST_TIME'] date(); 解决时差问题： 1：date('Y-m-d H:i:s', time()+ 3600 * 8); 2：date_default_timezone_set('PRC'); 3：修改配置文件:date.timezone =&quot;PRC&quot; 默认是UTC 2.时间日期相关函数 mktime(); 参数： 时分秒月日年 返回unix时间戳 格式化使用date checkdate();当前要判断的日期是否存在 参数：月日年 返回值布尔 getdate(); 参数是时间戳 如果不传默认当前时间戳 返回是数组 strtotime(); 参数：是英文字符 返回值是时间戳 经典的面试题 打印昨天的时间 date_parse();参数字符串 eg:2017-01-28 10:30:24 返回值是数组 microtime();返回时一个有时间戳还有微妙数的字符串 3.错误处理 错误级别：notice注意 warning警告 error致命错误 declare(strict_types = 1) trigger_error() 抛出用户自定义的错误信息 参数一个是 错误信息预定义的系统常量 处理错误方式： @：抑制单行错误 抑制notice warning 错误显示 对于error不起作用 display_errors:修改配置文件值为ON显示所有的错误（可以是值为1），为off不显示所有的错误（值可以0），当出现notice和warning时候是不显示正常执行 当是error 时候 程序无法运行 error_reporting :显示错误 默认值是E_ALL eg:不想显示notice错误时候可以将值改为 E_ALL &amp; ~E_NOTICE 我们的waining同理 函数： error_reporting()： // 关闭所有PHP错误报告 error_reporting(0); // 除了 E_NOTICE，报告其他所有错误 // 这是在 php.ini 里的默认设置 error_reporting(E_ALL ^ E_NOTICE); // 报告所有 PHP 错误 (参见 changelog) error_reporting(E_ALL); ini_set()：设置配置文件的值 ini_set('display_errors', '1'); ini_get(): 获取配置文件的值ini_get('display_errors'); set_error_handler('自定义的函数名'); 当出现错误时候出来error会自动触发在这个set_error_handler函数 会调用传给函数的自定义函数 error_get_last() //留作作业 错误日志 log_errors： 配置文件 是否打开写入错误日志 error_log 系统日志syslog error_log = syslog 默认不写入系统错误日志 管理工具 - 时间查看器- windows日志- 应用程序 die() exit() url相关函数补充 parse_str parse_url urlencode urldecode base64_encode base64_decode json_encode json_decode","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P13-%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"title":"PHP[入门]P15-数据库 数据类型 字符集  存储引擎","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day15 数据库 数据类型 字符集 存储引擎 1.数据类型 int 默认没有设置int字节 11位 char varchar 数据类型的区别： timestamp: regtime timestamp default current_timestamp; 在增加数据的时候没有给指定的时间类型字段值的时候，默认填充的值是当前时间的时间戳 enum:枚举类型 用于互斥的 单选项 新建字段时候 sex enum('w','m'); // sex enum(1,2,.….); 存储值时候： insert into user values('w'); insert into user values('1'); set:集合类型 设置字段类型：love set('eat','play','sport','wan'); // ; 1 2, 4, 8; insert into user values('eat,play'); insert into user values('6'); unsigned:无符号 规定 没有负数 int(10) unsigned eg：编号，年龄...... auto_increment：自增 常用于：id 修改起始值：alter table user auto_increment=起始值 default '值'： 默认值 再给某个字段增加值的时候就是插入数据时没有给值默认使用设置的默认值 not null :创建时在字段语句后接上：not null 2.字符集 utf8 GBK GB2312 3.存储引擎 show engines;可以查看到当前服务器支持的所有引擎。 myisam 和 innodb的区别 myisam 不支持事物 表锁 支持全文索引 查询的速度快 innodb 支持事物 行锁 支持外键 数据操作速度快 默认读取不加锁处理大数据优先选择innodb 4.索引 普通索引： 格式：alter table 表 add index(字段); 唯一索引： 当前列值唯一 格式：alter table 表 add unique(字段); 主键索引:不允许有空值 也别重复 是特殊的唯一索引 【注】基本上每个表都有id会给主键索引 自动递增 格式：alter table 表 add primary key(字段); 全文索引： 格式：alter table 表 add fulltext(字段); 删除索引： 格式：alter table 表 drop index字段; 删除主键索引： 格式: alter table money drop primary key; 5.DML(增，删，改) 增： 1.insert into tablename values(值1,值2,.…); [注]:按照字段的顺序跟值一一对应 添加； 如果有默认值 不想给定值可以用null 2.insert [into] 表 values(值1,值2,值n);可以将into省略（知道就好，尽量不用） 3.insert into tablename(字段1,字段2,.….) values(值1,值2,.….); [注]：按照自己赋的字段 字段跟值一一对应; 4.insert into star(name, money, province, age, sex) values('黄晓明', 2000000, '山东', 39, 0), ( 'angelababy', 3000000, '上海', 27, 1), ( '陈赫', 150000, '福建', 31, 0); [注]：字段名和值要一一对应，每条数据用小括号括起来，每条数据用逗号分隔开最后的使用分号结束; 插入数据时候可以不传值的情况 1.自增的字段 （默认+1） 2.有默认值的字段 default 3.可以为空的字段 删除： delete from tablename where 条件; [注]:要写where条件 不然后果自负 修改： update tablename set 字段1=值1, 字段2=值2 .. where 条件; [注]：要写where条件 不然就是修改全表数据了; 6.DQL(查) 1.select * from tablename; [注]：是执行效率最低的一种方式,会每天数据全部读一遍; 2.指定字段查询： select 字段名,字段名 from star; 3.查询出不重复的记录 select distinct age, sex from star; [注]:两个字段查询的是组合起来不重复的记录。 一个字段 当前字段不重复的记录 4.有条件的查询 select 字段名,.… from star where age = 43; select * from star where age = 43; 5.条件查询 select * from star where age&gt;32 and sex=0; select * from star where age&gt;32 or sex=0; select * from star where age between A and B; //区间 在A和B之间 包含A B select * from star where age in(32,43);//在in值中的数据 like : '%'代表模糊查询 [注]：效率很低 也是查询所有进行匹配 排序： order by 字段名 desc/asc desc:倒序 asc :默认的正序 多字段排序： order by 字段名1 desc, 字段名2 desc [注]：多字段排序呢先按照前边的字段进行排序，如果前边的都相等排序失败，就按照第二个字段进行排序 limit 限制查询结果集 limit 2; 取符合条件的数据的前两条 limit 0,3; 取符合条件的数据从0（第一条）开始取，取了三条数据以后结束 7.where条件 8.结果集排序 9.限制结果集 10.分组","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P15-%E6%95%B0%E6%8D%AE%E5%BA%93_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B_%E5%AD%97%E7%AC%A6%E9%9B%86_%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"},{"title":"PHP[入门]P16-php中数据库的操作","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 day16 1.mysql函数 使用方式： select 函数(字段名) as 字段别名 from tablename ; 注：尽量不用 as 给字段起别名 2.分组： select count(age) as count ,age from tablename group by 字段名; select count(age) as count ,age from tablename group by 字段名 having条件; 分组以后数据再次过滤 条件使用having 3.链接： 内连接： 隐式链接：select 表1.字段 [as 别名], 表n.字段 from 表1 [别名], 表nwhere 条件; 显示链接:select 表1.字段 [as 别名], 表n.字段 from 表1 [别名] join表n on 条件; 表1 inner join 表2 on 条件 表1 join 表2 on 条件 inner一般使用习惯是可以省略掉的 外链接： 左连接：select 表1.字段 [as 别名], 表n.字段 from 表1 [别名] leftjoin 表n on 条件; 说明：以左边表数据为准进行匹配查询 如果右边对应表没有对应数据 null 右链接：select 表1.字段 [as 别名], 表n.字段 from 表1 [别名] rightjoin 表n on 条件; select guser.username,goods.name ....…. 说明：以什么方式关联就以什么表为主 4.子查询 以一个结果集作为另一个查询的一部分或者是条件 select * from user where gid in (select gid from goods); 5.全外链接(记录联合) 将讲个关联查询结果合并到一起，没有对应的数据时候 用null select * from guser lu left join goods lg on lu.gid=lg.gid union select* from guser ru right join goods rg on ru.gid = rg.gid; union 是将 union all 后的结果进行一次distinct，去除重复记录后的结果 6.修改更新： update money set balance=balance-500 where userid = 15; update 要操作的字段名 set 字段名=字段名(实际的意义指字段里的对应值)-190where 条件 两个表同时修改 update user u, goods g set u.gid=0, g.price=1799 where u.id=8 andu.gid=g.gid; 说明： 先将user表里 gid 值 把user表中id为8的用户gid改成0然后运用关联gid值 就是拿到的user gid 再把goods修改 7.清空表记录 1.delete 删除 说明： 索引也就通常说的id 是自增的使用delete删除数据id保留 再添加数据时候从删除前的id+1 2.truncate table user; 说明：与delete的区别就是清空数据时候连索引值一起清空。 8.权限控制(了解)： show grants;显示用户 创建用户： create user ‘username‘@’host’ identified by ‘password’; 赋予操作权限： grant 权限 [privileges] on 库.表 to 用户@主机 [identified by‘密码’]; 刷新： flush privileges; 剥夺权限： revoke select on test.* from ‘aaa‘@’%’; 说明： * 代表操作索引的表 % 代表模糊匹配 all 所有操作（insert delete select update） 9.事务 默认的配置autocommit值是1 自动提交 将set autocommit=0;以后意思是手动提交; commit 开启事务： begin; //如果begin不好使时候可以使用set autocommit=0; 提交事务： commit; 回滚： rollback; 10.导入导出 导出：mysqldump -uroot -p 数据库 &gt; xxx.sql // 一定是退出mysql 导入：mysql -uroot -p 数据库 &lt; xxx.sql //注意： 一定新建一个数据库","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P16-php%E4%B8%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%93%8D%E4%BD%9C/"},{"title":"PHP[入门]P17-php查询数据库","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 天龙八步： 1：链接数据库 2：判断数据是否链接成功 3：选择数据库 4：设置字符集 5：准备sql语句 6：执行sql语句 7: 解析结果集 8：关闭数据库 释放资源 &lt;?php /* 1.连接数据库 参数： 1).主机名：localhost //ip地址 2).用户名 3).密码 返回值： 成功：object; 失败：false; */ $link = mysqli_connect('localhost', 'root', '123456'); //var_dump($link); /* 2.判断链接是否成功 */ // if($link == false) if (!$link){ exit('数据库链接失败'); } /* 3.选择数据库 参数： 1).$link 2).databasename 返回值： true false */ $db = mysqli_select_db($link, 'qf_1701'); // var_dump($db); if (!$db) { echo '错误号:' . mysqli_errno($link); echo '错误信息:' . mysqli_error($link); exit('数据库选择失败'); } /* 4.设置字符集 //HTML utf-8 php utf8 mysql utf8 参数： 1).$link 2).字符集 utf8 */ mysqli_set_charset($link, 'utf8'); /* 5.准备sql语句 //单独提出来sql语句:拼接sql 如果出错 可以直接输出sql语句 方便排错 */ $sql = 'select * from qf_user'; /* 6执行sql语句 参数： 1).$link 2).sql语句 返回值： 成功：object 失败：false */ $result = mysqli_query($link, $sql); /* var_dump($result); var_dump(mysqli_affected_rows($link)); die; */ /* 7.解析结果集 mysqli_fetch_* mysqli_fetch_assoc() //返回一条关联数组的数据 mysqli_fetch_array() //返回一条关联数组的数据 mysqli_fetch_row() // 返回一条索引数组的数据 mysqli_affected_rows() 返回执行受影响的行数说明：增删改返回受影响行数，查询返回数据的和 mysqli_num_rows()//自己测试 mysqli_insert_id //更新数据时候 成功返回插入数据的id */ date_default_timezone_set('PRC'); if ($result &amp;&amp; mysqli_affected_rows($link)) { echo '&lt;table width=800 border=1 align=center&gt;'; echo '&lt;caption&gt;用户信息&lt;/caption&gt;'; echo'&lt;tr&gt;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;用户名&lt;/td&gt;&lt;td&gt;邮箱&lt;/td&gt;&lt;td&gt;注册ip&lt;/td&gt;&lt;td&gt;注册时间&lt;/td&gt;&lt;/tr&gt;'; while ($data = mysqli_fetch_assoc($result)) { echo '&lt;tr&gt;'; echo'&lt;td&gt;' . $data['id'] . '&lt;/td&gt;'; echo'&lt;td&gt;' . $data['username'] . '&lt;/td&gt;'; echo'&lt;td&gt;' . $data['email'] . '&lt;/td&gt;'; echo'&lt;td&gt;' . long2ip($data['ip']) . '&lt;/td&gt;'; echo'&lt;td&gt;' . date('Y-m-d H:i:s', $data['create_time']) .'&lt;/td&gt;'; echo '&lt;/tr&gt;'; } echo '&lt;/table&gt;'; } /* 8.关闭数据库 */ mysqli_close($link);","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P17-php%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"title":"PHP[入门]P19-会话控制","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 会话控制 http协议： 特点：无状态 ，无连接的协议（脸盲） 状态码：200 请求成功 404 未知的页面 302，307 :重定向 400：语法错误 500：服务器错误 报文头部：请求行 空行 头部信息 头部信息：分为很多种，里面重要的是cookie信息 使用场景： 访问网站的不同页面的时候 ，为了避免用户身份的重复验证 就是用cookie session cookie: 是保存在浏览器中的指定文件内的cookie值是保存在本地的，这个值是用setcookie设置的，下次访问的时候，浏览器会自动将cookie值提交给当前所属的站点服务器，setcookie设置的作用域是’/‘，name整个站点都可以使用这个值. ----------------- 如果是第一次访问，没有请求跟返回的cookie值 在后台登录以后，设置cookie 以后 访问直接把cookie或者session值返回给浏览器 当第二次请求,login.php.时候，浏览器已经将刚才的值存储起来，当第二次请求的时候，会把数据提交给服务器，执行第二次请求以后，服务器不会返回值给浏览器 第三次.….都是一样，只要浏览器中有这个cookie值并且没有过期服务器就不会再返回值给浏览器，什么时候回有值返回给浏览器， 1.修改了cookie值 2.cookie过期 --------------- 设置cookie： setcookie('名','值','生存时间',域); 域：'/':当前站点都有效; 不传值：当前目录 读取： $_COOKIE['名']; 销毁： 1.设置生存时间为之前时间(浏览器自动判断不会提交) setcookie('名','值',time()-60,域); 2.unset($_COOKIE['name']); 特点： 使用COOKIE不安全，因为可以在浏览器中查看到 尽量不要使用cookie设置保存敏感信息 session: session:值存在服务器中，将一个加密的串返回给浏览器，也放在浏览器的cookie中 开启：session_start(); [注]:在开启session前边不要有输出,把session_start()放在文件开始最前边 设置session： $_SESSION['名']; 销毁： 1.unset($_SESSION['名']); 2.session_destroy() 函数 3.setcookie('PHPSESSID','','过期时间'); //因为值存在浏览器的cookie文件中，把时间设置为过期的，浏览器不会提交 函数： session_name(); 获取到的是在浏览器中存的cookie的key session_id(); 获取到的是在浏览器中存的cookie的value 面试题： 浏览器中禁用cookie以后，还能使用session么？ 答：不能使用，因为session的真正的值保存在服务器中，但是也有value存在浏览器的cooki中，是依赖关系。但是解决方式有： 1.手动拼接URL 2.session.use_trans_sid = 1 可以在url中自动拼接 session.use_only_cookies = 0 是否依赖于浏览器中的cookie 自动登录： 使用setcookie() ----------------- serialize:序列化 unserialize:反序列化","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P19-%E4%BC%9A%E8%AF%9D%E6%8E%A7%E5%88%B6/"},{"title":"PHP[入门]P20-图像处理","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 图像处理 准备工作： MIME：互联网邮件扩展类型 服务器会告诉浏览器当前返回的文件类型，当浏览器获取到content-type文件类型就会自动按照类型打开文件 header('location:'); header('content-type:text/css'); 常见的mime类型： HTML JavaScript css image/png image/jpeg image/gif 图像后缀： png jpg jpeg gif bmp wbmp 打开支持的相对应的扩展库php.ini 修改配置文件： 扩展库所在的目录：extension_dir =&quot;E:/wamp64/bin/php/php7.0.0/ext/&quot; 1.如果是wampsever : 在小绿那-&gt;php-&gt;php extension前边有对勾的就是支持的， 直接选择 之后会自动重启 2.修改配置文件：eg:打开gd2扩展库 extension=php_gd2.dll 将分号去掉 ，加上分好就是注释掉 如果还是没有支持相对应的扩展： 去扩展库文件目录，找对应.dll文件如果没有去官网下载或者拷贝别的地方的.dll --- GD库处理图像： 经常的使用的场景: 验证码 水印 缩放 数据图 .…. 六脉神剑： 1.创建画布 imagecreatetruecolor() 2.准备颜色 imagecolorallocate() 3.图像的处理 imagefill 4.设置header 头 header('content-type:image/png'); 5.保存/发送图像 imagepng() 6.关闭/释放资源 imagedestroy($img); ----------- 函数： imagecreate：创建画布 推荐使用 imagecreatetruecolor(width, height); 返回值 资源 --使用图片 imagecreatefromjpeg('meinv.jpg'); imagecreatefrompng(); imagecreatefromgif(); 准备颜色 imagecolorallocate() 填充背景颜色 imagefill() imagefilledarc($img, 100, 100, 100, 100, 0, 360, $color3,IMG_ARC_PIE);//填充的是圆 imagefilledarc($img, 300, 200, 80, 100, 50, 180,$color3,IMG_ARC_CHORD); 弧度变成直线链接 (出来的是个三角形) 保存图像 imagepng($img, [path/filename]); imagegif() imagejpeg() 图像处理： imagesetpixel($img, 100, 100, $color3); 画一个单一像素点 imageline($img, 0, 0, 500, 400, $color1); 画一条线 // imagerectangle($img, 100, 100, 200, 300, $color1);//画一个矩形两点可以确定一个矩形 imagefilledrectangle($img, 100, 100, 200, 300, $color1); // imagepolygon($img, [300, 100, 320, 150, 200, 200, 100, 200 ], 4,$color3); 多边形 imagefilledpolygon($img, [300, 100, 320, 150, 200, 200, 100, 200 ],4, $color3); -- 字符： imagechar($img, 5, 400, 50, 'A', $color3);水平的画一个字符 imagechar($img, 5, 400, 50, 'A', $color3); imagestring($img, 5, 400, 100, 'ABCD', $color3);//水平的画一行字符(不能是中文) imagefttext($img, 50,10, 100, 100, $color1, 'STXINGKA.ttf','明天就是情人节');//资源，字体的大小，倾斜的角度，开始的位置，color,ttf, string， -----获取指定图片的宽 高 getimagesize('图片名'); 返回值是数组 下标0 的是宽，1的是高 list($width, $height) = getimagesize('filename'); imagecopymerge($img, $imgto, 100, 100, 0, 0, 100, 100,30);//拷贝图像中的一部分，设置透明程度 参数：作为画布的原始图，拷贝的图，起始位置， 拷贝图的起始位置，拷贝图像的宽,高，0-100透明程度 imagecopy($img, $imgto, 100, 100, 0, 0, 100, 100); --------------------- 验证码思路： 1.创建画布指定宽和高(写成一函数，传宽跟高); 2.随机产生的字符串 3.画布随机填充浅色的背景 4.画布上增加上干扰元素（随机产生点，线，弧线的位置，随机的是产生元素的位置） 5.把验证码字符串写上 6.设置header头 7.发送 8.销毁资源","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P20-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"title":"PHP[入门]P18-php封装mysql函数","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 &lt;?php function dbConnect($host, $user, $pwd, $dbname, $charset) { $link = mysqli_connect($host, $user, $pwd); if (!$link) { return false; } $db = mysqli_select_db($link, $dbname); if (!$db) { return false; } mysqli_set_charset($link, $charset); return $link; } function dbInsert($link, $table, $data) { //字段 $fields = array_keys($data);//取所有key $fields = join(',', $fields); $values = array_values($data); $values = vTostr($values); $values = join(',', $values); $sql =&quot;insert into $table($fields) values($values)&quot;; $result = mysqli_query($link, $sql); if ($result &amp;&amp; mysqli_affected_rows($link)) { return mysqli_insert_id($link); } else { return false; } } function dbDelete($link, $table, $where) { if (empty($where)) { return false; } //作业 ，补充是数组的情况 and $sql =&quot;delete from $table where $where&quot;; $result = mysqli_query($link, $sql); if ($result &amp;&amp; mysqli_affected_rows($link)) { return mysqli_affected_rows($link); } else { return false; } } function dbUpdate($link, $table, $data,$where) { if (empty($where)) { return false; } $data = vTostr($data); $data = vUpdate($data); $data = join(',', $data); $sql = &quot;update $table set $data where $where&quot;; $result = mysqli_query($link, $sql); if($result &amp;&amp; mysqli_affected_rows($link)) { return mysqli_affected_rows($link); } else { return false; } } function dbSelect($link, $table, $fields = '*', $where = null,$order = null, $limit = null) { // fields where order by limit 0,5 if (is_array($fields)) { $fields = join(',', $fields); } if ($where) { $where = &quot; where &quot; . $where; } if ($order) { $where .= &quot; order by &quot; . $order; } if ($limit) { $where .= &quot; limit &quot; . $limit; } $sql =&quot;select $fields from $table $where&quot;; $result = mysqli_query($link, $sql); if ($result &amp;&amp; mysqli_affected_rows($link)) { return mysqli_fetch_all($result, MYSQLI_ASSOC); } else { return false; } } function vTostr($values) { foreach($values as $k =&gt; $v) { if (is_string($v)) { $v = &quot;'&quot; . $v . &quot;'&quot;; $values[$k] = $v; } } return $values; } function vUpdate($data) { foreach ($data as $k =&gt; $v) { $data[$k] = $k . '=' . $v; } return $data; }","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P18-php%E5%B0%81%E8%A3%85mysql%E5%87%BD%E6%95%B0/"},{"title":"PHP[入门]P21-验证码生成","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 --------------------- 验证码思路： 1.创建画布指定宽和高(写成一函数，传宽跟高); 2.随机产生的字符串 3.画布随机填充浅色的背景 4.画布上增加上干扰元素（随机产生点，线，弧线的位置，随机的是产生元素的位置） 5.把验证码字符串写上 6.设置header头 7.发送 8.销毁资源 水印： 1.准备图片,(两张图片 一张背景，一张水印) 2.确定位置(计算位置) 3.合并处理 4.保存（生成新的图片呢，还是原来，保存位置，文件） 5.释放资源 缩放: 1.打开或者准备一张图片 2.自己计算尺寸，(直接给一个倍数，形参); 3.变成一张新的图片 4.保存 5.销毁","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P21-%E9%AA%8C%E8%AF%81%E7%A0%81%E7%94%9F%E6%88%90/"},{"title":"PHP[入门]P22-文件操作","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 缩放: 1.打开或者准备一张图片 2.自己计算尺寸，(直接给一个倍数，形参); 3.变成一张新的图片 4.保存 5.销毁 ----------------- day22 文件函数 路径相关的函数 pathinfo('文件的路径+名字') 文件的具体信息 dirname(); 路径的名 basename 获取的是文件的名字 realpath() 返回绝对路径 从磁盘根部开始 DIRECTORY_SEPARATOR: 返回的是目录分隔符（系统） 【注】： windows / \\都能识别 获取到时\\ linux 系统是/ 正斜线 文件内容的相关函数 整体： file_get_contents('文件的名'):获取文件中的全部内容//不仅可以传一个文件名，还可以是一个url file_put_contents('文件','内容');可以将内容写入到文件中，成功返回字节数，失败返回false 【注】：将原来的文件内容覆盖 【了解】readfile 将文件的内容输出到缓冲区，真正返回的值是字节数 内容： **fopen('文件', '打开的方式') 打开一个文件, 打开方式： r: 只读的方式打开 文件不存在的时候会报警告错误 r+：以读写的方式打开, 从头覆盖内容进行写入 w: 以写入的方式打开 如果文件存在会将文件内容清零，打开的文件不存在则创建 w+：可读可写： 文件不存在创建，存在内容清零 a: 追加写入， 不能读文件不存在创建，指针指向文件末尾 a+：读写方式打开 写的方式追加 文件不存在创建 x: 创建文件以写入的方式打开，如果文件存在报警告错误 x+: 创建文件并与读写的方式打开 c: 以只写的方式打开，会从头覆盖内容写入，文件不存在则创建 c+: 以读写方式打开，同上 **fread('打开的资源', '读取的字节数');返回的是限制读取的字节 **fwrite('操作的资源', '写入的字符') *rewind() ：将文件指针返回到文件流的开头位置 fseek(): 设置指针的位置： 参数：资源，移动的字节数， 常量 SEEK_SET/开头SEEK_CUR/当前 SEEK_END/结尾 ftell() 获取当前文件中指针的位置 feof ()[end of file]判断指针在不在结尾 //最后一个字节数或者出错时候返回true 其余返回false fgetc() 读取出来一个字节， 指针位置保留 fgets() 读取一行 指针的位置保留 *fgetss() 读取一行 去掉内容中的html标签 fclose() 关闭这个文件 文件锁： flock() 常量参数： LOCK_SH：共享锁 LOCK_EX: 独占锁 LOCK_UN: 解锁 文件判断相关 （状态） file_exists();判断文件是否存在 存在 true 不存在false is_file() :参数名是否是一个文件 is_dir(): 参数是否是一个目录 is_readable(): 判断文件是否可读 is_writeable():判断文件是否可写 is_executable(); 是否是一个可执行的文件 //window .exe filesize() :文件字节数 filectime() : 创建时间 filemtime(): 修改时间 文件相关的函数 touch(): 创建一个文件 unlink(): 删除一个文件 copy(): 1.要拷贝的文件 2.拷贝后新文件的名字（要拷贝的路径+mingzi） rename(): 重命名：文件 目录 目录的操作 mkdir(): 新建目录 rmdir() : 删除目录 (删除空目录) rename()修改目录名 copy() 拷贝目录 opendir() :打开目录 readdir()读取目录 closedir()关闭目录 文件的属性 ---------- 作业： 拷贝：大文件 ：一边读，一边写","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P22-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"},{"title":"PHP[入门]P23-下载上传","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 1. fileatime: 在linux下边是正常的.win7以后因为影响性能所以关闭了这个配置 copy() 不能复制目录（递归拷贝文件） rename() 不仅可以修改文件或者目录名 也可以移动 mkdir() 默认只能创建一个目录 层级目录 mkdir('1701/2/16', 0777, true); 文件的属性： ftruncate('资源',size)：截断文件中的指定长度 返回是截断以后的 scandir() 浏览当前目录 filetype() 返回的是文件的类型 不是文件后缀 权限 0 111 111 111 0 7 7 7 - rwx rwx rwx 所有者 所属组 其他 chmod 改变文件的权限 chmod 777 文件名字 chmod -R 777 目录 chgrp 改变文件的所属组 chown: 改变文件所有者 文件的上传下载 使用场景： 上传：头像，朋友圈，微博 证件 ….. 下载：安装包，图片 … 准备工作： 七伤拳： 1.准备form表单 2.判断提交的值 3.判断文件是否错误 4.判断是否超出大小 form php 自定义 5.判断是否是允许上传的文件类型 （mime） 6.保存图片 //7.保存数据库图片路径 ##配置文件： upload_tmp_dir =&quot;E:/wamp64/tmp&quot; 上传的文件缓存在的目录 upload_max_filesize = 2M 允许上传文件的大小限制 file_uploads = On 允许上传 max_file_uploads = 20 允许同时上传的文件个数 memory_limit = 128M 允许脚本运行最大的内存 注意事项： 1.表单必须以post方式提交 不能忘记enctype 2.表单中传隐藏值：name=MAX_FILE_SIZE 3.多文件上传: name是数组 4.临时缓存的目录权限 5.php.ini是否开启允许上传配置 6.’##‘配置文件中的一些配置项 下载： 1.告知文件类型 2.告知附件 3.文件的大小 4.发送数据 header('content-type:image/jpeg'); header('content-disposition:attachment;filename=&quot;aa.jpg&quot;'); header('content-length:'. filesize('aa.jpg')); readfile('2.jpg');","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P23-%E4%B8%8B%E8%BD%BD%E4%B8%8A%E4%BC%A0/"},{"title":"PHP[入门]P24-正则表达式","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#d:匹配 0-9一个#D:除了 0到9#w:匹配 0-9 a-z A-Z 下划线#W:非字 除了 0-9 a-z A-Z 下划线#s:空白字符 n r t#S:除了空白字符#b:匹配词边界#B:除了词边界#[]:原子列表,匹配其中一个 [0-9]#[^]:反元素# . 除了n以外的字符#元字符 修饰原子 ，不能单独存在#*：贪婪模式，返回最大的匹配值#+：至少匹配一次#？：最多多匹配一次(0,1)#{}： 控制原子次数{n}n次 {m,n}m到n包括m,n{0,n}最多n次#^:指定开头原子 等同A#$:指定结尾#|:或 最低级的#():优先级最高 子模式#模式修正符#修饰整个表达式的匹配，模式秀政府卸载定界符之后#eg: /balabala/i#i:不区分大小写#s:多行#A:从目标的字符串开头进行匹配#U:贪婪模式取反","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P24-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"title":"随笔合集","text":"关于douyin接口数据爬取工具总结 2020-03-17 选取http抓包工具 选取android模拟器 android 安装工具 动作模拟驱动组合 数据分析 方法传递子组件 2020-01-31 分布式和任务分配杂谈 2020-03-08 http与websocket端口共享 2019-07-15 webpack有感 2019-06-29 强类型的鸭子类型 2019-07-14 面向对象杂谈 2019-06-29 起初，“面向对象”是专指在程序设计中采用封装、继承、多态等设计方法 圆形的太阳和圆形的眼睛有什么关系，游戏超级玛丽奥中山和云的其实是颜色不一样的图形他们又是什么关系 面向对象的缺点不包括 ‘运行速度慢’ 设计非教条 人挪活，树挪死 从数据绑定看现代库的本质 2019-06-28 双向绑定 （肤浅的例子） ioc 的多种实现途径 （php版本） 构建延迟加载 了解spring 2018-12-18 安装及启动 code sex 2018-11-04 关于douyin接口数据爬取工具总结 2020-03-17*为我最终使用的工具 选取http抓包工具 fiddler mitmproxy anyproxy * 选取android模拟器 逍遥模拟器 * android 安装工具 xposed * jesttrustme (劫持后可继续使用https) * 动作模拟驱动组合 php+adb 模拟操作 数据分析 直接 grep anyproxy log 数据 方法传递子组件 2020-01-31从实现上来看类似发布订阅，但从思路上来说并不完全一样，设计上侧重点有些许不同 今天看React中传递方法给子组件，因为传递的是方法，父组件控制逻辑，子组件控制调用，潜意识认为这是一种不可靠，不易维护的方法，但是react是推荐这种方式的，于是进一步思考了一下。发现每一步的职责都很清晰并没有混乱的发生 这个流程可以这样划分子组件包括子组件本身功能+触发，同时提供一个明确的绑定方式，并且明确回调中会传递的值，父组件提供父组件相关操作，开发只需要对两个组件进行绑定即刻如下php代码，下面绑定了一个匿名函数，模块的拼接者只需要按需转换即刻 12345// 这里是对子组件的提交事件进行了绑定，当子组件进行提交操作的时候触发，会传递子组件预定义好的数据，这里进行处理转化，然后传入$f中$s-&gt;submitBind(function ($value) use ($f) { $name = $value; $f-&gt;push(['name' =&gt; $name]);}); 与发布订阅，有些类似但又不同 下面是一段php父模块传递方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpclass Son{ private $value = ''; private $callback = null; public function input($value) { $this-&gt;value = $value; } public function submit() { ($this-&gt;callback)($this-&gt;value); } public function submitBind($callback) { $this-&gt;callback = $callback; }}class Father{ public $state; public function __construct() { $this-&gt;state = [ ['name' =&gt; 'xxx'] ]; } public function push($name) { $this-&gt;state[] = $name; } public function upload() { return $this-&gt;state; }}$f = new Father();$s = new Son();$s-&gt;submitBind(function ($value) use ($f) { $name = $value; $f-&gt;push(['name' =&gt; $name]);});$s-&gt;input('小张');$s-&gt;submit();var_dump($f-&gt;upload()); 分布式和任务分配杂谈 2020-03-08今天想给自己机子装个 RabbitMQ （不过感觉不在公司了，其实这个装的意义不是很大，个人写代码redis就足够了），然后想起分布式爬虫这个东西，因为之前听到其他人开发的时候用到了redis，于是就先想后查，觉得呢这个分布式爬虫的实现是基于redis的队列实现的，程序爬取一页后将将要爬取的东西塞到队列中，然后其他机器上的爬虫从队列中取任务继续进行其他任务。查询了一下原理也是这样的。于是就回想了一下过去接触的任务分配的方式吧。总的来说就是主动取，和主动分发着两种吧。 第一种就类似学校老师收到卷子后，找几个高年级的学生改卷子，然后每个人改的卷子是老师分给他的。比如ng的负载均衡。 第二种呢也是老师让高年级学生批改卷子，但是不一样的呢是老师只收卷子不负责具体哪个人改哪个卷子，所有的卷子摞起来，然后改卷子的人自己过来取，取的数量也是改卷子的人自己定。这种呢就像除了队列中任务一样，多跑几个脚本就是多个学生。日常开发这种用法比较多。而且比较简单，毕竟完全依靠队列的特性实现，不需要纠结任务的分配。 当然也有一些逗逼的方式。就是给脚本传参数然后也不要队列然后通过原始数据顺序取模进行分配。不过比较憨憨的是，一单想要加人或者减少人，就要告诉所有的任务，你取数据的方式要变啦，不然就会和别人取到同一个数据或者有数据跳过了。属于一口气吃成胖子的思路蛤蛤。 http与websocket端口共享 2019-07-15Q:为什么 Socket.IO 可以让 WebSockets 和 HTTP 监听在同一端口 A:websocket, http 都是基于tcp实现的。websocket 的连接请求都是用的http。websocket和http是在一个层面上的东西 微信的web客户端使用的是http keep-alive 进行数据的接受蛮有意思的。 日后填坑。 webpack有感 2019-06-29明天就要回乡了，抓紧看了下书（其实是被子都寄走了，晚上睡觉不舒服） 从B站上看了一下webpack相关的教程，快看完的时候突然发现了另个角度和后端工具对标的地方（以前只是对标了一下composer和npm，这次比较细致） node php 前端原生撸代码（这个阶段还没有用到node） 原生撸代码 使用node+npm 使用composer npm script composer script 使用了 node 的模块加载 使用由composer实现的psr4自动加载 以下为模块和另一侧弱对标 以下为模块和另一侧弱对标 使用webpack 使用了ioc模块 使用了sacc-load 使用了request 使用了axias 使用guzzlehttp 使用babel 使用doctrine/annotations 经过上诉模块的组合知乎前端的代码变得风格不同于原生的html开发，同时右侧的php代码也变得不同于原生的php代码，左侧隔离了原生网络请求，大量原生html，以及对css语法，js语法的一定改变，右侧则是更改由直接写代码变为控制器代码，$_REQUEST变成了request类，curl变成了封装好的httpclient，语法上也加强了注释对代码的影响，增加更多的功能，如果右侧加上了doctrine/orm 则更进一步对数据库操作进行了隔离，至此编码层面上既有非原生php语法的补充又有新增模块的全局函数和对底层的高度封装，从这一角度来看，虽然前端的编码改变也好，辅助的工具也好，和后端技术的代一定成都上也大同小异，不同的地方也就是给人的感受把，作为一个phper从原生phper-&gt;使用composer-&gt;使用框架因为处于渐进所以对于代码的写法感受较为温和，而前端代码由于直接从原生看到了使用webpack的写法，所以感觉跨度比较大。但是仔细想一想其实都是经过长时间迭代对工具的高度封装所得。尤其是一些同级语法分析器（用php的实现的对php语法的分析器和用js实现的对js语法的分析器）更是让工具以及库的使用更加巧妙（这里指的是对语言本身语法的改变）。 不过语法的改变倒是挺有意思的事情，（php的语法分析库大多被引来制作静态检测）,scss,styl,twig,smarty(模板大多用的正则其实不应该算在这里面，但是从使用角度上来说又是一种语法的扩充)，“计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决” “Any problem in computer science can be solved by anther layer of indirection.” 强类型的鸭子类型 2019-07-14鸭子类型 当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。 这是一个比较有意思的话题，而且go中接口的特性是golang支持鸭子类型的基础，因为go时强类型语言所以在这里和php做个比照 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpclass A{ public function run() { }}class B{ public function run() { }}interface canListen{ public function listen();}class man implements canListen{ public function listen() { echo 1; }}class Dvd implements canListen{ public function listen() { return '1'; }} A和B都事先了run方法，并且可以放入同一数组中循环调用man和Dvd都实现了listen并且结成了canListen，但因为canListen没有对返回值做限定所以导致如果你希望让对应的对象给你返回一个字符串，可能并不行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package main// WhatIsCar astype WhatIsCar interface { run() stop()}// Car astype Car struct { name string}// ACar astype ACar struct { Car fly string}// CCar astype CCar struct { fly string}func (car Car) run() { println(&quot;Car can run&quot;)}func (car Car) stop() { println(&quot;Car can run&quot;)}func (car ACar) run() { println(&quot;ACar can run&quot;)}func (car CCar) run() { println(&quot;CCar can run&quot;)}// 当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。// 因为 go 是静态语言本身具备静态检测，所以鸭子类型带来的负面影响较小func structTest() { var car WhatIsCar // car 实现了 whatiscar 的所以方法所以可以使用 car = new(Car) car.run() // ACar 继承了 car ,并且重写了run方法 所以也可以使用 car = new(ACar) // CCar 既没有继承 car ，也没有自行实现 whatiscar 的所有方法，没有实现接口，所以不能使用，故注释 // car = new(CCar) car.run()} 这也从一下方面反应了鸭子类型更多的时设计的一种而没有没有明确的好坏之说，相比于不严谨的弱类型代码，强类型的更严谨的约束了鸭子类型，使用上来说也相对安全一点。并且在OO的世界中抽象的角度不同可能得到的结论也不同。从可能存在的缺陷角度上来说如果使用了鸭子类型，那么尽可能使用鸭子的特征，尽量避免使用非鸭子的特征，比如你让所有的鸭子进了马戏团，但是你又要所有的鸭子去开汽车，但是鸭子的接口没有开汽车这个规定，那么那些不会开车的鸭子就会让你车翻得很严重咯 面向对象杂谈 2019-06-29起初，“面向对象”是专指在程序设计中采用封装、继承、多态等设计方法看下面一段php代码 12345678910111213141516&lt;?phpfunction eat(){ echo 'eat';}function eatFood(){ eat();}function eatFood2(){ eat(); eat();} 是不是和面向对象的继承封装多态差不多？虽然代码看着有点丑陋 再举例一个 oop 里面的一个设计模式观察者,php中有declare(ticks=1);这样一种用法，（这个写法的孪生兄弟pcntl_signal_dispatch()不是这次的重点）,它表示每执行多少语句去执行一下register_tick_function注册的方法或检测pcntl_signal信号量，是不是很适合用来实现观察者，但观察者的实现多大都是主动通知更改的时候触发了observer，而非被监听者观察到状态变化，因为从实现上来说，每执行一句就要观察一下状态是不是有点费劲呀，之后就演变成了发布订阅，因为服务端的业务代码大多数时候并没有实现真正的观察者。但是真正意义的观察者也是存在的，从实现角度上来说我们常用的守护进程大多都可以理解为观察者的实现，起进程，监控进程，发现挂掉就重启。 圆形的太阳和圆形的眼睛有什么关系，游戏超级玛丽奥中山和云的其实是颜色不一样的图形他们又是什么关系许多人可能会说圆形是太阳的一个属性，山的型状和云的型状也是他们的属性，那太阳和眼睛存在关系码？云和山又有什么关系呢？很显然在这种地方组合的表现要更加明显。 所以我个人认为面向对象并非一个完美的理论，而实一个阶段性的由开发人员长期开发得出来的经验总结 面向对象的缺点不包括 ‘运行速度慢’网上有人说面向对象的缺点里面包括了运行速度慢，这个观点简直就是放屁，因为面向对象的逻辑可以等价的转换为非面向对象的写法，所以无论是开发自己转换也好，还是语言底层自己转换也好，相同逻辑下效率是一样的，（个人反对因为现在计算机算力高，所以可以忽略某些问题，但面向对象本身是没有性能问题，即使有那也是编译器或解析器处理的问题，或编写语法转换器，所以这个缺点是不存在的，面向对象的缺点应该更多的观察它设计上的缺陷）。 设计非教条如果不能优雅的实现设计模式，那么或者时机不到（没有合适的api，或者没有合适的库的支持（例如反射类推进了ioc,php词法分析推进了php编程上使用注解）），要么可能就是过于追求本本主义，走了弯路 人挪活，树挪死从数据绑定看现代库的本质 2019-06-28这边文章目前没有想清楚如何表达只是作为一份草稿写来展示的 编码中没有什么是加一层解决不了的，如果有就再加一层 前端双向绑定的功能之一是由Object.defineProperty实现的 (可以并非唯一) ioc 可以利用反射 闭包可以用来延迟加载 现在我们作为一个无法使用例如 vue 或者使用 lavarl 这样的框架或者库的时候我们应该如何实现类似的功能 双向绑定 （肤浅的例子）监听所有的事件，在此基础上实现 set 和 get 的接口 从而实现事件的监听 ioc 的多种实现途径 （php版本）控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中 反射类分析类整体 编写由php写成的语法分析器解析代码，分析出依赖的对象 控制反转容器的依赖查找即分析代码的依赖，并解决这些依赖，竟然如此其实即使没有反射api的存在，只要可以对代码进行分析就可以把依赖解决。 1234567891011&lt;?phpnamespace App\\action;class Cat{ public function eat(Food $food) { }} 在php 框架之中大多框架的延迟加载是通过闭包实现的，下面是php延迟加载的一个简版php代码 123456789&lt;?phpfunction buildLazyClass($className,$params){ return function () use ($className,$params){ new $className($params); }} 1234567&lt;?php$lazyFood = buildLazyClass('Food')if(is_callback($lazyFood)){ return $lazyFood();} else { return $lazyFood;} 构建延迟加载如果一个语言没有实现闭包呢？ 那就只能自己想办法实现了现在第一步用反射类或者语法分析器分解目标类，分析出依赖的对象，第二部是构建延迟加载类，例如下面 1234567891011121314151617&lt;?phpclass LazyFood { private $isBuild = false; private $food = null; public getFood() { if($this-&gt;isBuild) { return $food; } else { $this-&gt;food = new Food() $this-&gt;build = true; return $this-&gt;food; } }} 这样就存在相同的业务编码，实现了相同的功能，相比之下如果使用了编译代码这一步，就可以想办法将执行代码中对依赖的分析解除，从而达到更高的效率 了解spring 2018-12-18今天安装了一下 spring cloud 并且运行得到了’hello world’，从第一个’hellow world’，到最中的spring cloud的开发过程和实现原理吧 官网文档先说一种（可以忽略这个） spring 下载路径, 下载后使用目录bin下的spring.bat,可以运行简单的‘hello world’，由于没有采用任何依赖管理工具，就跳过这个详细讲解 安装及启动 使用linux 和 xos 的童鞋自己去官网文档看下安装教程哦，这里稍微加入点 windows 的安装过程 使用 windows 的同学可以先安装一个 chocolatey，这个工具是 windows 上的包管理工具，类似于 linux 上的 apt-get、yum ，使用 choco 也可以安装一些例如 notepad++ 这样的软件，感兴趣的童鞋可以自己试一下 使用 choco 安装 maven 1choco install maven 首先创建一个 pom.xml 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.1.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 这个文件给我的第一感觉有点类似于 php 的 composer （php 的包管理工具），略有不同的是 maven 引入到了本地仓库，而不是当前路径下创建一个文件存放，这个和 php 包管理就略有不同 ，在 windows 下 maven 引入的文件会默认导入到用户目录下的 .m2 文件夹下的，其中这个 .m2 的路径配置是 Maven 安装目录下的 config 中的 setting.xml。 创建一个 java 文件，位于项目根目录下 src/main/java/Example.java，接下来可以执行一下命令，然后访问 localhost:8080, 至此第一个 spring 程序就跑起来了 1234567# 查看mvn dependency:tree# 第一种运行方式mvn packagejava -jar target/myproject-0.0.1-SNAPSHOT.jar# 第二种运行方式mvn spring-boot:run code sex 2018-11-04 我们来谈程序员对性的追求。 可靠性(relibility) 可读性(readability) 可维护性(maintainability) 可测试性(testability) 可扩展性(extensibility) 可移植性(portability) 可伸缩性(scalbility) 易用性(usability) 可用性(avaliability) 可重用性(reusability) 互操作性(interoperability) 可管理性(manageability) 可支持性(supportability) 一致性(consistency) 安全性(security) 性能(performance) 稳定性(stability) 精确性(accuracy) 可客制性(customizability) 魯棒性(robustness) from https://www.zhihu.com/question/29264868/answer/44134766","link":"/2019/06/28/blog/amazing-%E9%9A%8F%E7%AC%94/"},{"title":"基算要素","text":"tip input&amp;output 让gcc的cin和scanf一样快 不要用局部变量地址返回地址 一个简单的函数辅助理解c++中指针和数组的联系 algorithm 指针&amp;单链表链表 sudtoj-1138:单链表操作A sdutoj-1139:单链表操作B sdutoj-2054:双向链表 sdutoj-2121:链表排序 循环链表（略） 贪心 活动选择问题 []完全背包 []动态规划(01背包) 二叉树 sdutoj-2136:数据结构实验之二叉树的建立与遍历 数据结构实验之求二叉树后序遍历和层次遍历 多叉树 多叉树构建英文字典 排序 快排 二分查找 kmp dfs/bfs 迪杰斯特拉/弗洛伊德 克鲁斯卡尔/普瑞姆 tipinput&amp;output stdin stdout scanf() printf() gets() puts() getchar() putchar() 让gcc的cin和scanf一样快12ios::sync_with_stdio(false);std::cin.tie(0); 不要用局部变量地址返回地址1234int* func(){ int arr[2] = {} return arr;} 这是错误的，从函数本身的意义来说，该函数应该返回一个指针，但是函数体内的arr是一个临时变量，所以返回arr后会由于临时变量的销毁导致函数返回的地址是一个无意义地址。所以要将int arr静态化，或者改为全局函数 12345678910111213int arr1[2] = {};int* func1(){ arr1[0] = 0; arr1[1] = 0; return arr1;}int* func2(){ static int arr2[2] = {}; return arr2;} 一个简单的函数辅助理解c++中指针和数组的联系12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;int t = 0;void ceshi(char *p){ t++; if (t &gt; 11) { return; } else { cout &lt;&lt; p[0]; cout &lt;&lt; endl; ceshi(p + 1); }}int main(){ char str[] = &quot;0123456789&quot;; ceshi(str); return 0;} algorithm指针&amp;单链表链表sudtoj-1138:单链表操作ADescription 输入n个整数，先按照数据输入的顺序建立一个带头结点的单链表，再输入一个数据m,将单链表中的值为m的结点全部删除。分别输出建立的初始单链表和完成删除后的单链表。 Input第一行输入数据个数n； 第二行依次输入n个整数； 第三行输入欲删除数据m。 Output第一行输出原始单链表的长度；第二行依次输出原始单链表的数据；第三行输出完成删除后的单链表长度；第四行依次输出完成删除后的单链表数据。SampleInput 1231056 25 12 33 66 54 7 12 33 1212 Output 12341056 25 12 33 66 54 7 12 33 12756 25 33 66 54 7 33 solutions 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;bool equal(int a, int b){ return a == b;}struct node{ int data; node *next = NULL;};node *create(int i){ node *head; node *p; head = new node(); p = head; while (i--) { p-&gt;next = new node(); p = p-&gt;next; cin &gt;&gt; p-&gt;data; } return head;}/** * 创建逆序链表 */node *createR(int i){ node *head = new node(); node *p; while (i--) { p = new node(); cin &gt;&gt; p-&gt;data; p-&gt;next = head-&gt;next; head-&gt;next = p; } return head;}node *delRepeatNode(node *head){ node *p, *q, *t4del; p = head; while (p-&gt;next != NULL) { p = p-&gt;next; q = p; while (q-&gt;next != NULL) { if (equal(q-&gt;next-&gt;data, p-&gt;data)) { t4del = q-&gt;next; q-&gt;next = q-&gt;next-&gt;next; delete (t4del); } else { q = q-&gt;next; } } } return head;}node *delByData(node *head, int delData){ node *p, *t4del; p = head; while (p-&gt;next != NULL) { if (p-&gt;next-&gt;data == delData) { t4del = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; delete (t4del); } else { p = p-&gt;next; } } return head;}int getCount(node *head){ node *p = head; int counter = 0; while (p-&gt;next != NULL) { p = p-&gt;next; counter++; } return counter;}void printNodeList(node *head){ node *p = head; int counter = 0; while (p-&gt;next != NULL) { cout &lt;&lt; p-&gt;next-&gt;data; if (p-&gt;next-&gt;next != NULL) { cout &lt;&lt; &quot; &quot;; } p = p-&gt;next; } cout &lt;&lt; endl;}void testA(){ int n = 0; int waitDelData = 0; cin &gt;&gt; n; node *head = create(n); cin &gt;&gt; waitDelData; cout &lt;&lt; getCount(head) &lt;&lt; endl; printNodeList(head); head = delByData(head, waitDelData); cout &lt;&lt; getCount(head) &lt;&lt; endl; printNodeList(head);}void testB(){ int n = 0; cin &gt;&gt; n; node *head = createR(n); cout &lt;&lt; getCount(head) &lt;&lt; endl; printNodeList(head); head = delRepeatNode(head); cout &lt;&lt; getCount(head) &lt;&lt; endl; printNodeList(head);}int main(){ ios::sync_with_stdio(false); cin.tie(0); testA(); // testB(); return 0;} sdutoj-1139:单链表操作BDescription按照数据输入的相反顺序（逆位序）建立一个单链表，并将单链表中重复的元素删除（值相同的元素只保留最后输入的一个）。Input第一行输入元素个数n；第二行输入n个整数。Output第一行输出初始链表元素个数；第二行输出按照逆位序所建立的初始链表；第三行输出删除重复元素后的单链表元素个数；第四行输出删除重复元素后的单链表。SampleInput 121021 30 14 55 32 63 11 30 55 30 Output 12341030 55 30 11 63 32 55 14 30 21730 55 11 63 32 14 21 解答为上述代码的testB函数 sdutoj-2054:双向链表123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;bool equal(int a, int b){ return a == b;}struct node{ int data; node *next = NULL; node *last = NULL;};node *create(int i){ node *head; node *p; head = new node(); p = head; while (i--) { p-&gt;next = new node(); p-&gt;next-&gt;last = p; p = p-&gt;next; cin &gt;&gt; p-&gt;data; } return head;}void findLastAndNext(node *head, int data){ node *p = head; while (p-&gt;next != NULL) { if (p-&gt;next-&gt;data == data) { if (p != head) { cout &lt;&lt; p-&gt;data; } if (p != head &amp;&amp; p-&gt;next-&gt;next != NULL) { cout &lt;&lt; &quot; &quot;; } if (p-&gt;next-&gt;next != NULL) { cout &lt;&lt; p-&gt;next-&gt;next-&gt;data; } cout&lt;&lt;endl; } p = p-&gt;next; }}int main(){ ios::sync_with_stdio(false); cin.tie(0); int n = 0; int m = 0; cin &gt;&gt; n; cin &gt;&gt; m; node *head = create(n); int findData; while (m--) { cin &gt;&gt; findData; findLastAndNext(head, findData); } return 0;} sdutoj-2121:链表排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;iostream&gt;using namespace std;struct node{ int data; node *next;};node *creat(int n){ node *head, *p, *tail; head = new node; head-&gt;next = NULL; tail = head; while (n--) { p = new node; cin &gt;&gt; p-&gt;data; p-&gt;next = NULL; tail-&gt;next = p; tail = p; } return (head);}node *sortlist(node *head){ node *q, *p; int temp; for (p = head-&gt;next; p != NULL; p = p-&gt;next) { for (q = p-&gt;next; q != NULL; q = q-&gt;next) { if (p-&gt;data &gt; q-&gt;data) { temp = q-&gt;data; q-&gt;data = p-&gt;data; p-&gt;data = temp; } } } return head;}void printNodeList(node *head){ node *r; r = head; while (r-&gt;next-&gt;next != NULL) { cout &lt;&lt; r-&gt;next-&gt;data &lt;&lt; &quot; &quot;; r = r-&gt;next; } cout &lt;&lt; r-&gt;next-&gt;data &lt;&lt; endl;}int main(){ ios::sync_with_stdio(false); cin.tie(0); node *head, *r; int n; cin &gt;&gt; n; head = creat(n); head = sortlist(head); printNodeList(head); return 0;} 循环链表（略）贪心活动选择问题Description sdut 大学生艺术中心每天都有n个活动申请举办，但是为了举办更多的活动，必须要放弃一些活动，求出每天最多能举办多少活动。 Input输入第一行为申请的活动数n(n&lt;100)，从第2行到n+1行，每行两个数，是每个活动的开始时间b，结束时间e； Output 输出每天最多能举办的活动数。 SampleInput 123456789101112131215 2015 198 1810 154 146 125 102 93 80 73 41 3 Output 15 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;stdio.h&gt;using namespace std;struct actionTime{ int startTime = 0; int endTime = 0;};int main(){ int n = 0; actionTime actionTimeList[200] = {}; actionTime tmpActionTime; while (int scanfResult = scanf(&quot;%d&quot;, &amp;n)) { if (scanfResult == EOF) { break; } for (int i = 0; i &lt; n; i++) { cin &gt;&gt; actionTimeList[i].startTime &gt;&gt; actionTimeList[i].endTime; } for (int i = 0; i &lt; n - 1; i++) { for (int j = 0; j &lt; n - i - 1; j++) { if (actionTimeList[j].endTime &gt; actionTimeList[j + 1].endTime) { tmpActionTime = actionTimeList[j]; actionTimeList[j] = actionTimeList[j + 1]; actionTimeList[j + 1] = tmpActionTime; } } } // cout &lt;&lt; &quot;##############&quot; &lt;&lt; endl; // for (int i = 0; i &lt; n; i++) // { // cout &lt;&lt; actionTimeList[i].startTime &lt;&lt; &quot; &quot; &lt;&lt; actionTimeList[i].endTime &lt;&lt; endl; // } int j = 0; int sum = 1; for (int i = 1; i &lt; n; i++) { if (actionTimeList[i].startTime &gt;= actionTimeList[j].endTime) { sum++; j = i; } } cout &lt;&lt; sum &lt;&lt; endl; } return 0;} []完全背包[]动态规划(01背包)二叉树sdutoj-2136:数据结构实验之二叉树的建立与遍历123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;struct node{ char data; node *left = NULL; node *right = NULL;};char charList[60] = &quot;&quot;;int charListP = 0;node *create(){ char data = charList[charListP]; charListP++; if (data != ',') { node *p = new node(); p-&gt;data = data; p-&gt;left = create(); p-&gt;right = create(); return p; } else { return NULL; }}void proOrder(node *p){ cout &lt;&lt; p-&gt;data; if (p-&gt;left) { proOrder(p-&gt;left); } if (p-&gt;right) { proOrder(p-&gt;right); }}void inOrder(node *p){ if (p-&gt;left) { inOrder(p-&gt;left); } cout &lt;&lt; p-&gt;data; if (p-&gt;right) { inOrder(p-&gt;right); }}void lastOrder(node *p){ if (p-&gt;left) { lastOrder(p-&gt;left); } if (p-&gt;right) { lastOrder(p-&gt;right); } cout &lt;&lt; p-&gt;data;}int leafCounter = 0;void initLeafCounter(){ leafCounter = 0;}void getLeafCount(node *p){ if (p-&gt;left) { getLeafCount(p-&gt;left); } if (p-&gt;right) { getLeafCount(p-&gt;right); } if (p-&gt;left == NULL &amp;&amp; p-&gt;right == NULL) { leafCounter++; }}int deepCounter = 0;void initDeepCounter(){ deepCounter = 0;}void getDeep(node *p, int nowDeep = 0){ nowDeep += 1; if (p-&gt;left) { getDeep(p-&gt;left, nowDeep); } if (p-&gt;right) { getDeep(p-&gt;right, nowDeep); } if (p-&gt;left == NULL &amp;&amp; p-&gt;right == NULL) { if (nowDeep &gt; deepCounter) { deepCounter = nowDeep; } }}int main(){ while (cin &gt;&gt; charList) { charListP = 0; node *head; head = create(); // proOrder(head); // cout &lt;&lt; endl; inOrder(head); cout &lt;&lt; endl; lastOrder(head); cout &lt;&lt; endl; initLeafCounter(); getLeafCount(head); cout &lt;&lt; leafCounter &lt;&lt; endl; initDeepCounter(); getDeep(head); cout &lt;&lt; deepCounter &lt;&lt; endl; }} 数据结构实验之求二叉树后序遍历和层次遍历 其中层次遍历有循环多次比较深度和队列两种方式实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;using namespace std;struct node{ char data; node *left = NULL; node *right = NULL;};/** * 一切以构造先序构造条件为优先 */node *create(char *pre, char *in, int len){ bool isNode = len &gt; 0; // 判断当前pre字符串是否为空 if (isNode) { /*** * ROOT LEFT***** RIGHT***** * LEFT***** ROOT RIGHT***** */ node *p = new node(); p-&gt;data = pre[0]; int leftNodeNum = 0; int rightNodeNum = 0; while (pre[0] != in[leftNodeNum]) { leftNodeNum++; } // 下标0为起点所以找到root时正好为left的长度 rightNodeNum = len - leftNodeNum - 1; p-&gt;left = create(pre + 1, in, leftNodeNum); p-&gt;right = create(pre + 1 + leftNodeNum, in + leftNodeNum + 1, rightNodeNum); return p; } else { return NULL; }}void lastOrder(node *head){ if (head != NULL) { lastOrder(head-&gt;left); lastOrder(head-&gt;right); cout &lt;&lt; head-&gt;data; }}int deepCounter = 0;void getDeep(node *p, int nowDeep = 0){ nowDeep += 1; if (p-&gt;left) { getDeep(p-&gt;left, nowDeep); } if (p-&gt;right) { getDeep(p-&gt;right, nowDeep); } if (p-&gt;left == NULL &amp;&amp; p-&gt;right == NULL) { if (nowDeep &gt; deepCounter) { deepCounter = nowDeep; } }}int findDeep = 0;void deepOrder(node *head, int nowDeep){ if (nowDeep &gt; findDeep) { return; } if (head != NULL) { if (nowDeep == findDeep) { cout &lt;&lt; head-&gt;data; } deepOrder(head-&gt;left, nowDeep + 1); deepOrder(head-&gt;right, nowDeep + 1); }}void initDeepFunction(){ deepCounter = 0; findDeep = 0;}struct queueList{ node *data; queueList *next;};queueList *tail;queueList *queueHead;void insertQueueList(node *data){ tail-&gt;data = data; tail-&gt;next = new queueList(); tail = tail-&gt;next;}node *pushQueueList(){ queueList *waitDelNode = queueHead-&gt;next; node *data = waitDelNode-&gt;data; queueHead-&gt;next = queueHead-&gt;next-&gt;next; delete (waitDelNode); return data;}void deepOrderByQueue(node *treeHead){ queueHead = new queueList(); queueHead-&gt;next = new queueList(); tail = queueHead-&gt;next; insertQueueList(treeHead); while (queueHead-&gt;next != tail) { node *waitShow = pushQueueList(); if (waitShow-&gt;left != NULL) { insertQueueList(waitShow-&gt;left); } if (waitShow-&gt;right != NULL) { insertQueueList(waitShow-&gt;right); } cout &lt;&lt; waitShow-&gt;data; }}int main(){ char proStr[100]; char inStr[100]; int num = 0; cin &gt;&gt; num; while (num--) { cin &gt;&gt; proStr; cin &gt;&gt; inStr; node *head; head = create(proStr, inStr, strlen(proStr)); lastOrder(head); cout &lt;&lt; endl; // 利用层级多次调用遍历函数 // initDeepFunction(); // getDeep(head); // for (findDeep = 1; findDeep &lt;= deepCounter; findDeep++) // { // deepOrder(head, 1); // } // cout &lt;&lt; endl; // 利用队列深度遍历 deepOrderByQueue(head); cout &lt;&lt; endl; } return 0;} 多叉树多叉树构建英文字典排序快排二分查找kmpdfs/bfs迪杰斯特拉/弗洛伊德克鲁斯卡尔/普瑞姆","link":"/2021/01/14/coding/C_%E5%9F%BA%E7%AE%97%E8%A6%81%E7%B4%A0/"},{"title":"PHP[入门]P01~06html","text":"这是我早期的 php 学习笔记，php 的学习版本版本是 5.6、7，🐟2020/05/06年从有道笔记导出至此。 B/S和C/S的简单认识 网页的工作原理 认识标签 全局架构标签 body常用属性 字体修饰标记(如下都是双边标记) 排版标记 实体符号 无序列表 自定义列表 HTML再认识 URL 超链接 图片img 音频 视频 表格 CSS初认识 CSS 使用css的好处 css的三种链接方式 行内样式 内联样式 外部样式 css语法格式和注释 选择器 尺寸设置 CSS vertical-align 背景 列表 布局 边框 盒子模型 内外边距 B/S和C/S的简单认识client-server : 客户端服务器模式 开发成本比较高、不易于维护、在客户端部署一套软件，服务器端也要部署 browser-server : 浏览器服务器模式 网页的工作原理通过域名或者 ip 然后访问服务器 服务器解析请求返回的是一个html文件 浏览器将 html 文件解析成一个图文并茂的网页 html 文件的组成部分: html css js(javascript) HTML 是 Hypertext Markup Language 组织-&gt;文件夹和搜索选项-&gt;查看-&gt;隐藏已知文件的扩展名（去掉不选中） 认识标签格式： &lt;标签名 属性名1=&quot;属性值1&quot; 属性名2=&quot;属性值2&quot;&gt;要显示的内容&lt;/标签名&gt; 标签注意事项： 以&lt;\\&gt;开始，中间放的是标签名 属性跟属性之间 用空格隔开 属性值 可以用双引号 单引号 或者不引 我建议使用双引号 marquee(direction,scrollamount,width,height,loop) 标签的分类： 双边标签 &lt;marquee&gt;&lt;/marquee&gt; 单边标签 &lt;br /&gt;:换行 全局架构标签12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;是网页的标题&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;/head&gt; &lt;body&gt;要显示在网页的所有内容&lt;/body&gt;&lt;/html&gt;&lt;!-- 这是注释 --&gt; 设置字符集 ：告诉浏览器以utf-8编码格式显示 出现乱码： 文件的编码的格式（编辑器中选择utf-8无bom） 在head头部 增加 &lt;meta charset=&quot;utf-8&quot;&gt; 浏览器中：修改编码 body常用属性 tag desc bgcolor 背景颜色 background 网页的背景图片 text 字体颜色（控制body体中所有的文字颜色） left-margin 左边距 top-margin 上边距 link 正常状态显示的颜色 vlink 访问过后的状态 alink 鼠标点击时候的状态 字体修饰标记(如下都是双边标记)&lt;font&gt;&lt;/font&gt; size: 字体大小 属性值是：1-7face：字体 (楷体，微软雅黑….)color: 字体颜色颜色： #000000 前两位是红色 中间是绿色 结尾两位是蓝色 123456&lt;b&gt;&lt;/b&gt;：字体加粗(strong)&lt;i&gt;&lt;/i&gt;：斜体显示字体(em,cite)&lt;u&gt;&lt;/u&gt;: 是下划线&lt;s&gt;&lt;/s&gt;: 删除线&lt;sub&gt;&lt;/sub&gt;：下标&lt;sup&gt;&lt;/sup&gt;：上标 排版标记12345678&lt;p&gt;段落标记&lt;/p&gt; 会自称一行（段）&lt;span&gt;行标签&lt;/span&gt;&lt;br /&gt;:换行&lt;nobr /&gt;：不换行&lt;hr /&gt;水平线：(align: 对其方式 属性值：center left right color：颜色 width：宽 size：粗细尺寸)&lt;h1&gt;标题&lt;/h1&gt;（从h1到h6）通常网页中只会有一个h1&lt;h6&gt;&lt;h6&gt;(align)&lt;pre&gt;原样输出&lt;/pre&gt;（在学php时候 经常使用输出数据的时候进行格式化） 实体符号诸如 “&lt;” 之类的符号在HTML中拥有特殊的含义，所以在文本中使用它们。 &nbsp; (空格) &lt; &gt; &amp;&copy;&trade; &reg; &times; &divide; 1234567&amp;nbsp; 空格&amp;lt; （&lt;）&amp;gt; (&gt;)&amp;amp;&amp;copy;&amp;trade;&amp;reg; &amp;times; &amp;divide; 无序列表123456&lt;ul&gt; &lt;li&gt; &lt;/li&gt; &lt;li&gt; &lt;/li&gt; &lt;li&gt; &lt;/li&gt; &lt;li&gt; &lt;/li&gt;&lt;/ul&gt; type: disc：默认的黑心圆样式 circle：空心圆 square: 实心方块 10.有序列表 12345&lt;ol&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ol&gt; type: 1 A a Istart: 要显示列表的起始位置 自定义列表 我是简介名 幸福的孩子 杜海涛 刘翔 123456&lt;dl&gt; &lt;dt&gt;我是简介名&lt;/dt&gt; &lt;dd&gt;幸福的孩子&lt;/dd&gt; &lt;dd&gt;杜海涛&lt;/dd&gt; &lt;dd&gt;刘翔&lt;/dd&gt;&lt;/dl&gt; class id style name 他们四个都是属性名 配合我们的 css 跟 js 基本上每个标签都有这四个属性 动态网页： 数据内容展示出来是有变化的，比如：银行 账户余额（每个人都不一样） 静态网页： 做内容展示，所有人访问都是一样叫静态网页 HTML再认识nobr: 双标签 &lt;nobr&gt;中间的内容不允许换行，这就是nobr&lt;/nobr&gt; URLUniform Resource Locator 统一资源定位符 组成部分： 协议 地址 端口号 文件 参数 协议：http:// https:// file:// ftp:// smtp:// 邮件传输协议 news:// 地址：www.baidu.com 域名 ip (cmd -&gt; ping 域名) 端口号：(:80) web http://默认的端口号是80 范围：0-65535通常已经被使用：0-1024 https: 443 ftp: 21 smtp:// 25 文件：要请求的文件 默认一般是：index.html 参数：以？开始 后边跟的就是参数 形式：键1=值1&amp;键2=值2 如果有多个参数的时候 中间用&amp;隔开 http://www.baidu.com:80/index.html?word=qianfeng&amp;sex=1 超链接123456789101112131415&lt;a href=&quot;&quot; &gt;&lt;/a&gt;href:要跳转的地址title: 就是鼠标放上去时候显示的内容（变成小手的时候）target：_self 在本窗口打开 _blank 在新窗口打开锚点：&lt;a href=&quot;#锚点名&quot;&gt;&lt;/a&gt;&lt;a name=&quot;锚点名&quot;&gt;&lt;/a&gt;了解（id=&quot;锚点名&quot;） 图片imgsrc资源地址 绝对路径： 网络绝对：https://www.baidu.com/img/bd_logo1.png 磁盘绝对：C:/wamp64/www/1701/day02-html/code/ly.jpg (也可以使用/) 站点绝对： https://www.baidu.com/bd_logo1.png bd_logo.png == https://www.baidu.com/bd_logo1.png == https://www.baidu.com 相对路径： 以当前html文件为一个基准 寻找图片所在的位置 （路径） ./ 在同一级目录（通常可以省略） ../ 表示上一级目录(上两级 ../../ 层级多用绝对路径) alt:当图片加载失败的时候显示的内容 title：鼠标悬停时候显示的内容 width height 【注】当只设置一个宽或者一个高的时候 图片会等比例缩放如果给定了宽和高就会失帧 会变形 热点地图(了解 ，掌握最好) usemap 音频 视频audio: src： controls:控制条 loop: 循环播放 autoplay:自动播放 video: width height src、controls、loop、autoplay 表格table: bgcolor:表格的背景颜色 border：边框 bordercolor:边框颜色 align：表格的显示 对其方式 cellspacing:单元格间距 cellpadding：单元格中的内容跟边框的距离 width，height tr:width,height, align:水平距离 valign：垂直方向 top bottom middle th--td:width,height,align,valign, rowspan: colspan: caption: valign: top middle bottom day03-表单 表格 tel colspan:合并列，需要将同一行的那个td给干掉 rowspan:合并行，需要将下一行的那个td给干掉 url参数作用: a标签扩展： 123&lt;a href=&quot;tel:132603519038&quot;&gt;dadianhua&lt;/a&gt;&lt;a href=&quot;mailto:wanglijuan@1000phone.com&quot;&gt;发送邮件&lt;/a&gt; 1：iframe(width\\height\\src\\name\\frameborder\\scrolling)frameborder: 0/1scrolling: no/yes/auto2: frameset(cols\\rows\\frameborder\\border\\bordercolor\\noresize)frame(src\\name\\scrolling)3: form表单用途：获取有意义的信息，用户键入信息（注册，登陆，留言等等）属性:(action/method/enctype(multipart/form-data)/target)基本用途：form:action:提交的地址method:提交的方式默认：get(在url中显示?参数) post【注】:拉取信息是时候一般使用getpost:用户提交数据的时候使用enctype=&quot;multipart/form-data&quot;现在记住这个，是上传文件的时候必须使用一个属性target：打开提交页面的方式 (1)input 属性:( type：类型 size:宽 value：输入框的默认值（一般的时候不写，因为就是让用户键入信息） maxlength：允许键入的最大长度 readonly：只读 disabled：禁用状态 :一般时候是用在只能看不能二次修改的值的时候（注册公司名） placeholder：提示信息 placeholder=&quot;默认提示的信息&quot; name:非常重要 要提交的内容的键) type( text:文本信息 password：密码 radio：单选框 必须name值 name要一样 必须value 一般使用习惯：1男 2女 0未知或者保密 123radio(&lt;label for=&quot;id名&quot;&gt;详细见代码&lt;/label&gt; checked)checkbox(checked) 说明:必须有name属性 属性值必须： eg:like value submit hidden：区分，不让用户看见的值用 file:上传文件时候使用 ) 跳过这个坑：name属性一定要给 value input（必须放在form中） button：最多时候配合js使用 reset:重置按钮 （清空表单input中用户键入的内容） 1&lt;button&gt;提交按钮&lt;button\\&gt; (2)select(multiple size name) 下拉菜单 ：name option((value selected)) ：value (3)textarea(cols rows) 双边标记：&lt;textarea&gt;默认中间不要有空格或者回车&lt;/textarea&gt; 提交的都是意义的数据 不包括&lt;p\\&gt;&lt;/p&gt; 4:头元素 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;1.css&quot; /&gt; 链接外部的css样式 &lt;meta charset=&quot;utf-8&quot; /&gt; SEO:搜索引擎优化 &lt;meta name=&quot;keywords&quot; content= &quot;&quot; /&gt; 堆积网站关键字，用来提高网站的排名 &lt;meta name= &quot;description&quot; content= &quot;&quot; /&gt; 关于本网站的描述信息 &lt;meta http-equiv=&quot;refresh&quot; content= &quot;3;url=http://www.baidu.com &quot; /&gt; 在几秒以后跳转 5: 无意义的标签 div span footer header section 都是双标签 CSS初认识CSS层叠样式表，Cascading Style Sheet 网页中HTML CSS JavaScript的分工 html:负责网页中的内容展示 由标签组成 css：负责网页的排版 将内容友好的展示出来 js: 负责网页的特效，一些动画效果 比如说轮播图 使用css的好处可以重复层叠样式 达到我们最终想要展示效果 单独分离出来便于管理跟重复调用 可以提高访问速度 节省服务器的流量开支 css的三种链接方式行内样式格式： style=&quot;属性名1:属性值1;属性名2:属性值2;&quot; 内联样式格式: 在head头中增加 12345&lt;style type=&quot;text/css&quot;&gt;选择器{ 属性:属性值;}&lt;/style&gt; 外部样式格式：&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css文件的路径&quot; /&gt;,里面的格式，跟内联样式一样 123选择器{ 属性:属性值;} css语法格式和注释1234选择器{ 属性:属性值;} /* CSS的注释 */ 选择器自定义名规则：数字 字母 下划线 不能以数字开始 标签选择器：所有的标签都可以做标签选择器 如果使用了标签选择器 当前网页中用这个标签的元素都增加了样式 class选择器： 在标签内增加class属性 属性值自定义 在CSS样式中使用如下 .class属性名{样式} 一个元素可以有多个class名 中间用空格隔开 id选择器： 在标签内增加id属性 属性值自定义 在CSS中使用如下 #id名{样式} 注:通常一个网页中id名是唯一 组合选择器: 标签选择器,class，id选择器…. 形式 ：选择器与选择器之间用逗号隔开 将多个元素增加共同的样式 12345eg: p,.meixi,#daishu{font-size:35px;} 层级选择器：使用具有层级关系 可以从父类找到子类找到孙子类 增加样式 选择器用空格隔开 伪类选择器:(link,hover,active,visited,focus,first-child,last-child) 一般用于给 某些选择器增加特殊效果比如 a链接 超链接状态顺序： a:link{} 正常状态下（默认状态）a:visited{} 访问之后的样式a:hover{} 鼠标悬停的时候的样式a:active{} 鼠标点击时候的样式 注意，a:hover 必须位于 a:link 和 a:visited 之后，a:active 必须位于 a:hover 之后 可靠的顺序是：l(link)ov(visited)e h(hover)a(active)te, 即用喜欢和讨厌两个词来概括 focus:使用一般配合input input:focus{样式} first-child:必须子元素中第一个是要增加样式的元素 last-child:必须子元素中最后一个是要增加的样式的元素 (IEl不支持的时候 可以声明doctype(大写)) 属性选择器: 形式： input[type=&quot;password&quot;]{样式} a[title]{样式} * 通配符:给页面上所有的元素增加样式 [选择器优先级] *&lt;标签选择器&lt;class&lt;id 尺寸设置只有块标签才有宽和高 div p section width height min-height max-height min-width max-width 单位： %:使用的是父级 的百分比 px:像素 一个点就是一个像素 em:设置的是当前元素的父级的字体尺寸 rem： html中的尺寸 倍数 最长使用的字体尺寸: 12px 14px 16px 7.常用属性 字体： font-style：normal 默认状态 italic斜体 font-weight：normal默认状态 bold 加粗 font-size： 字体的大小 谷歌 默认是16px; 最小支持12px; font-family:楷体 微软雅黑 font: style weight size family 文本: text-indent:文本的缩进 最好用em 一般都是2em text-align：文本的水平对齐方式 left right center white-space: nowrap; (了解) 强行在一行显示内容 text-overflow:clip超出部分直接截断 ellipsis：超出部分显示’…’ 配合overflow:hidden使用 text-decoration( overline:上划线 line-through：中划线 underline:下划线 none) text-shadow: 水平偏移的值 垂直偏移值 模糊程度 颜色 line-height：行高 当块标签的高和行高设置值一样会垂直居中 vertical-align： CSSvertical-align背景background-color： 背景颜色 background-image: url(图片地址) background-repeat( repeat：默认平铺 no-repeat:不平铺 repeat-x：横向平铺 repeat-y:纵向平铺 repeat-y:纵向平铺 ) background-attachment( fixed：（了解）相对窗口固定，当显示该div的时候，背景图才显示出来 local：背景图会随着内容的滚动而滚动 scroll：默认属性，背景图不会随着内容的滚动而滚动 ) background-position：一定要有一个背景图 background-image属性（left、center、right、top、bottom、xy值） 简写形式：background:url(erha.jpg) no-repeat pink; 列表list-style：none list-style-image:url() list-style-position：inside列表项目标记放置在文本以内/outside list-style-type 布局float：浮动 left right none clear: 用于清除浮动 both display:把块元素变成行元素 也可以把行元素变成块元素( none inline-block:切换为行内块 block：切换为块 inline：切换为行内元素 none：让标签消失，位置也不再 ) visibility：(visible、hidden:隐藏元素，但是位置依然存在) overflow（ visible:默认不做处理 hidden:超出部分隐藏、 scroll:超出部分出现滚动条 auto:自动判断 如果有内容超出处彰显滚动条，如果没有就不显示滚动条 ） position（ relative：相对自身文档流中的位置进行定位 absolute：相对定位 会脱离文档流 当想从父级定位 在父级中使用position:relative static:默认属性 fixed:相对于当前窗口的 ） z-index：设置元素的层叠顺序 值越大越在上边，这个属性的测试需要都为absolute或者fixed的才有效 如下属性只有当定位是relative、absolute、fixed时有效 top right bottom left 边框border border-width border-style( dotted:点线 solid:实线 dashed:虚线 double:双线 border-color：边框颜色 border-radius: 给一个值：全部变 给两个值：对角 三个值: 左上 右上左下 右下 box-shadow:边框的阴影效果 盒子模型内外边距padding:内边距 padding-top padding-right padding-bottom padding-left margin:外边距 margin: 0 auto; margin-top margin-right margin-left margin-bottom","link":"/2017/01/01/coding/php/php-%E5%85%A5%E9%97%A8/P01~06html/"},{"title":"how to use java","text":"how to use javas install java &amp; nvm mvn run123mvn clean packagecd target java -jar xxxx.jar run stepJava之初始化语句执行顺序application.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344import Hand.LeftHand;public class Application { static { System.out.println(&quot;run {} in header&quot;); for(int i = 10 ;i&lt;100;i++){ System.out.print(i); } System.out.println(); } public static final String handName1 = LeftHand.getName(&quot;1&quot;); public static String handName4 = LeftHand.getName(&quot;2&quot;); public int counter = initCounter(); public int initCounter() { System.out.println(&quot;now init counter&quot;); return 0; } public Application() { System.out.println(&quot;run construct&quot;); } static { System.out.println(&quot;run {} before main&quot;); } public static void main(String[] args){ System.out.println(&quot;run main&quot;); new Application(); } static { System.out.println(&quot;run {} in tail&quot;); }} LeftHand.java 1234567891011121314package Hand;public class LeftHand { static { System.out.println(&quot;this is left head static &quot;); } public static String getName(String who) { System.out.println(&quot;leftHand getName , who:&quot; + who); return &quot;i am you left hand&quot;; }} mvnpom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt; &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 version。 --&gt; &lt;parent&gt; &lt;!--被继承的父项目的构件标识符 --&gt; &lt;artifactId /&gt; &lt;!--被继承的父项目的全球唯一标识符 --&gt; &lt;groupId /&gt; &lt;!--被继承的父项目的版本 --&gt; &lt;version /&gt; &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt; &lt;relativePath /&gt; &lt;/parent&gt; &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt; &lt;groupId&gt;asia.banseon&lt;/groupId&gt; &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt; &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--项目的名称, Maven产生的文档用 --&gt; &lt;name&gt;banseon-maven&lt;/name&gt; &lt;!--项目主页的URL, Maven产生的文档用 --&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt; &lt;description&gt;A maven project to study maven.&lt;/description&gt; &lt;!--描述了这个项目构建环境中的前提条件。 --&gt; &lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven /&gt; &lt;/prerequisites&gt; &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt; &lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字， --&gt; &lt;system&gt;jira&lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL --&gt; &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息 --&gt; &lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum --&gt; &lt;system /&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url /&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;!--传送通知的途径 --&gt; &lt;type /&gt; &lt;!--发生错误时是否通知 --&gt; &lt;sendOnError /&gt; &lt;!--构建失败时是否通知 --&gt; &lt;sendOnFailure /&gt; &lt;!--构建成功时是否通知 --&gt; &lt;sendOnSuccess /&gt; &lt;!--发生警告时是否通知 --&gt; &lt;sendOnWarning /&gt; &lt;!--不赞成使用。通知发送到哪里 --&gt; &lt;address /&gt; &lt;!--扩展配置项 --&gt; &lt;configuration /&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt; &lt;inceptionYear /&gt; &lt;!--项目相关邮件列表信息 --&gt; &lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!--邮件的名称 --&gt; &lt;name&gt;Demo&lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt;banseon@126.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL --&gt; &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表 --&gt; &lt;developers&gt; &lt;!--某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符 --&gt; &lt;id&gt;HELLO WORLD&lt;/id&gt; &lt;!--项目开发者的全名 --&gt; &lt;name&gt;banseon&lt;/name&gt; &lt;!--项目开发者的email --&gt; &lt;email&gt;banseon@126.com&lt;/email&gt; &lt;!--项目开发者的主页的URL --&gt; &lt;url /&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt;Project Manager&lt;/role&gt; &lt;role&gt;Architect&lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织 --&gt; &lt;organization&gt;demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL --&gt; &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt;No&lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt;-5&lt;/timezone&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表 --&gt; &lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;name /&gt; &lt;email /&gt; &lt;url /&gt; &lt;organization /&gt; &lt;organizationUrl /&gt; &lt;roles /&gt; &lt;timezone /&gt; &lt;properties /&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt; &lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;!--license用于法律上的名称 --&gt; &lt;name&gt;Apache 2&lt;/name&gt; &lt;!--官方的license正文页面的URL --&gt; &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;!--关于license的补充信息 --&gt; &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt; &lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag /&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt; &lt;organization&gt; &lt;!--组织的全名 --&gt; &lt;name&gt;demo&lt;/name&gt; &lt;!--组织主页的URL --&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt; &lt;/organization&gt; &lt;!--构建项目需要的信息 --&gt; &lt;build&gt; &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;sourceDirectory /&gt; &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt; &lt;scriptSourceDirectory /&gt; &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;testSourceDirectory /&gt; &lt;!--被编译过的应用程序class文件存放的目录。 --&gt; &lt;outputDirectory /&gt; &lt;!--被编译过的测试class文件存放的目录。 --&gt; &lt;testOutputDirectory /&gt; &lt;!--使用来自该项目的一系列构建扩展 --&gt; &lt;extensions&gt; &lt;!--描述使用到的构建扩展。 --&gt; &lt;extension&gt; &lt;!--构建扩展的groupId --&gt; &lt;groupId /&gt; &lt;!--构建扩展的artifactId --&gt; &lt;artifactId /&gt; &lt;!--构建扩展的版本 --&gt; &lt;version /&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt; &lt;defaultGoal /&gt; &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt; &lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath /&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt; &lt;filtering /&gt; &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory /&gt; &lt;!--包含的模式列表，例如**/*.xml. --&gt; &lt;includes /&gt; &lt;!--排除的模式列表，例如**/*.xml --&gt; &lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt; &lt;testResources&gt; &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--构建产生的所有文件存放的目录 --&gt; &lt;directory /&gt; &lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。 --&gt; &lt;finalName /&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt; &lt;filters /&gt; &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;!--使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt; &lt;extensions /&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id /&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase /&gt; &lt;!--配置的执行目标 --&gt; &lt;goals /&gt; &lt;!--配置是否被传播到子POM --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!--使用的插件列表 --&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt; &lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt; &lt;profile&gt; &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt; &lt;id /&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标志 --&gt; &lt;activeByDefault /&gt; &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt; &lt;jdk /&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--构建项目所需要的信息。参见build元素 --&gt; &lt;build&gt; &lt;defaultGoal /&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory /&gt; &lt;finalName /&gt; &lt;filters /&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules /&gt; &lt;!--发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!--参见repositories/repository元素 --&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports /&gt; &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行&quot;mvn site&quot;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt; &lt;reporting&gt; ...... &lt;/reporting&gt; &lt;!--参见dependencyManagement元素 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--参见distributionManagement元素 --&gt; &lt;distributionManagement&gt; ...... &lt;/distributionManagement&gt; &lt;!--参见properties元素 --&gt; &lt;properties /&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules /&gt; &lt;!--发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; ...... &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID --&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID --&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 --&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行&quot;mvn site&quot;，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt; &lt;reporting&gt; &lt;!--true，则，网站不包括默认的报表。这包括&quot;项目信息&quot;菜单中的报表。 --&gt; &lt;excludeDefaults /&gt; &lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 --&gt; &lt;outputDirectory /&gt; &lt;!--使用的报表插件和他们的配置。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述报表插件需要的信息 --&gt; &lt;plugin&gt; &lt;!--报表插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--报表插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的报表插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--报表插件的配置 --&gt; &lt;configuration /&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到 --&gt; &lt;id /&gt; &lt;!--产生报表集合时，被使用的报表的配置 --&gt; &lt;configuration /&gt; &lt;!--配置是否被继承到子POMs --&gt; &lt;inherited /&gt; &lt;!--这个集合里使用到哪些报表 --&gt; &lt;reports /&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt; &lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt; &lt;uniqueVersion /&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;banseon maven2&lt;/name&gt; &lt;url&gt;file://${basedir}/target/deploy&lt;/url&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion /&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt; &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt; &lt;layout /&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息 --&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt; &lt;id&gt;banseon-site&lt;/id&gt; &lt;!--部署位置的名称 --&gt; &lt;name&gt;business api website&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt; &lt;downloadUrl /&gt; &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt; &lt;relocation&gt; &lt;!--构件新的group ID --&gt; &lt;groupId /&gt; &lt;!--构件新的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--构件新的版本号 --&gt; &lt;version /&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt; &lt;message /&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt; &lt;status /&gt; &lt;/distributionManagement&gt; &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt; &lt;properties /&gt;&lt;/project&gt;","link":"/2021/06/25/amazing_tool/h2u_java/"}],"tags":[{"name":"other","slug":"other","link":"/tags/other/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"tool","slug":"tool","link":"/tags/tool/"},{"name":"windows","slug":"windows","link":"/tags/windows/"},{"name":"blog","slug":"blog","link":"/tags/blog/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"kibaba","slug":"kibaba","link":"/tags/kibaba/"},{"name":"powershell","slug":"powershell","link":"/tags/powershell/"},{"name":"bash","slug":"bash","link":"/tags/bash/"},{"name":"database","slug":"database","link":"/tags/database/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"svn","slug":"svn","link":"/tags/svn/"},{"name":"uwp","slug":"uwp","link":"/tags/uwp/"},{"name":"c#","slug":"c","link":"/tags/c/"},{"name":"Vargrant","slug":"Vargrant","link":"/tags/Vargrant/"},{"name":"win","slug":"win","link":"/tags/win/"},{"name":"wsl","slug":"wsl","link":"/tags/wsl/"},{"name":"book","slug":"book","link":"/tags/book/"},{"name":"other blog","slug":"other-blog","link":"/tags/other-blog/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"react","slug":"react","link":"/tags/react/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"web","slug":"web","link":"/tags/web/"},{"name":"php","slug":"php","link":"/tags/php/"},{"name":"lazyload","slug":"lazyload","link":"/tags/lazyload/"},{"name":"Network protocol","slug":"Network-protocol","link":"/tags/Network-protocol/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"re2c","slug":"re2c","link":"/tags/re2c/"},{"name":"bison","slug":"bison","link":"/tags/bison/"},{"name":"DayDayUp","slug":"DayDayUp","link":"/tags/DayDayUp/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"other","slug":"other","link":"/categories/other/"},{"name":"HowToUse","slug":"HowToUse","link":"/categories/HowToUse/"},{"name":"tool","slug":"tool","link":"/categories/tool/"},{"name":"c","slug":"c","link":"/categories/c/"},{"name":"uwp","slug":"uwp","link":"/categories/uwp/"},{"name":"web","slug":"web","link":"/categories/web/"},{"name":"knowledge","slug":"knowledge","link":"/categories/knowledge/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"随笔","slug":"随笔","link":"/categories/%E9%9A%8F%E7%AC%94/"}]}